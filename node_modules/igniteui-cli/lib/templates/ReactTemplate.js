"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs-extra");
const path = require("path");
const Util_1 = require("../Util");
class ReactTemplate {
    /**
     * Base ReactTemplate constructor
     * @param rootPath The template folder path. Pass in `__dirname`
     */
    constructor(rootPath) {
        this.rootPath = rootPath;
        this.listInComponentTemplates = true;
        this.listInCustomTemplates = false;
        this.dependencies = [];
        this.framework = "react";
        this.hasExtraConfiguration = false;
        this.packages = [];
        this.configFile = "./client/pages/routesTemplate.js";
        this.replacePattern = /\[[\s\S]*\](?=;)/;
    }
    generateFiles(projectPath, name, options) {
        let config = {};
        if (options["extraConfig"]) {
            config = options["extraConfig"];
        }
        const pathsConfig = {};
        config["__path__"] = this.folderName(name); //folder name allowed spaces, any casing
        config["$(name)"] = Util_1.Util.nameFromPath(name); // this name should not have restrictions
        config["$(ClassName)"] = Util_1.Util.className(Util_1.Util.nameFromPath(name)); //first letter capital, no spaces and no dashes,
        config["$(cliVersion)"] = Util_1.Util.version();
        if (this.widget) {
            config["$(widget)"] = this.widget;
            config["$(Control)"] = Util_1.Util.className(this.widget);
        }
        config["$(igniteImports)"] = this.getImports();
        if (this.description) {
            config["$(description)"] = this.description;
        }
        // copy/template files to project
        if (!Util_1.Util.validateTemplate(path.join(this.rootPath, "files"), projectPath, config, pathsConfig)) {
            return Promise.resolve(false);
        }
        return Util_1.Util.processTemplates(path.join(this.rootPath, "files"), projectPath, config, pathsConfig);
    }
    registerInProject(projectPath, name, options) {
        if (options && options.skipRoute) {
            return;
        }
        let configFile = fs.readFileSync(path.join(projectPath, this.configFile), "utf8");
        const viewsArr = JSON.parse(this.replacePattern.exec(configFile)[0]);
        viewsArr.push({
            folder: this.getViewLink(name),
            path: "/" + this.folderName(Util_1.Util.nameFromPath(name)),
            text: this.getToolbarLink(name)
        });
        configFile = configFile.replace(this.replacePattern, JSON.stringify(viewsArr, null, 4));
        fs.writeFileSync(path.join(projectPath, this.configFile), configFile);
    }
    getExtraConfiguration() {
        throw new Error("Method not implemented.");
    }
    setExtraConfiguration(extraConfigKeys) {
        throw new Error("Method not implemented.");
    }
    getImports() {
        const config = require("../packages/components");
        let builder = "";
        builder += "\r\n";
        builder += "// Ignite UI Required Combined JavaScript Files\r\n";
        builder += `import "ignite-ui/js/infragistics.core.js";\r\n`;
        builder += `import "ignite-ui/js/infragistics.lob.js";\r\n`;
        if (this.dependencies.filter(x => config.dv.indexOf(x) !== -1).length) {
            builder += `import "ignite-ui/js/infragistics.dv.js";\r\n`;
        }
        return builder;
    }
    folderName(pathName) {
        //TODO: should remove the spaces
        const parts = path.parse(pathName);
        let folderName = pathName;
        if (parts.dir) {
            folderName = path.join(parts.dir, parts.name);
            folderName = folderName.replace(/\\/g, "/");
            // TODO: config-based "src/app"?
            const relative = path.join(process.cwd(), "client/components", folderName);
            // path.join will also resolve any '..' segments
            // so if relative result doesn't start with CWD it's out of project root
            if (!relative.startsWith(process.cwd())) {
                Util_1.Util.error(`Path ${"client/components/" + folderName} is not valid!`, "red");
                process.exit(1);
            }
            //clean up potential leading spaces in folder names (`path/    name`):
            folderName = folderName.replace(/\/\s+/g, "/");
        }
        return Util_1.Util.lowerDashed(folderName);
    }
    getViewLink(name) {
        const filePath = this.folderName(name) + "/index.js";
        return filePath;
    }
    getToolbarLink(name) {
        name = Util_1.Util.nameFromPath(name);
        const toolbarLink = name.replace(/\w\S*/g, txt => txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase());
        return toolbarLink;
    }
}
exports.ReactTemplate = ReactTemplate;
