"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var FeatureOutputType;
(function (FeatureOutputType) {
    /** JS/JSON array output. */
    FeatureOutputType[FeatureOutputType["JS"] = 0] = "JS";
    /** XML-like output for AngularJS. */
    FeatureOutputType[FeatureOutputType["AngularJS"] = 1] = "AngularJS";
})(FeatureOutputType = exports.FeatureOutputType || (exports.FeatureOutputType = {}));
class GridHelper {
    /**
     * Creates a new grid feature helper
     */
    constructor() {
        /** Request features to add inherit option for hierarchical grid */
        this.hierarchical = false;
        /** Apply feature settings for igTreeGrid - add inherit, paging and selection specifics */
        this.tree = false;
        /** Output type to render */
        this.outputType = FeatureOutputType.JS;
        /** Indent space used for formatting output */
        this.space = "\t";
        this.featureProps = {
            Paging: { type: "local", pageSize: 5 },
            RowSelectors: {
                enableRowNumbering: true,
                rowSelectorColumnWidth: 80
            }
        };
        this.treeGridFeatureProps = {
            Paging: { mode: "allLevels" },
            RowSelectors: { rowSelectorNumberingMode: "hierarchical" }
        };
        this.features = [];
    }
    generateFeatures(gridFeatures, pad = 0) {
        let result;
        if (gridFeatures) {
            for (const name of gridFeatures) {
                this.addFeature(name);
            }
        }
        switch (this.outputType) {
            case FeatureOutputType.AngularJS:
                result = this.generateXML(pad);
                break;
            case FeatureOutputType.JS:
            default:
                result = JSON.stringify(this.features, null, this.space)
                    .replace(/([\r\n]+)/g, `$&${this.space.repeat(pad)}`);
        }
        this.features = [];
        return result;
    }
    addFeature(name, overrideOptions = null) {
        const feature = this.getFeature(name);
        if (overrideOptions) {
            Object.assign(feature, overrideOptions);
        }
        // can add additional properties and handling per case:
        switch (name) {
            case "Selection":
                this.features.push(feature);
                this.features.push(this.getFeature("RowSelectors"));
                break;
            default:
                this.features.push(feature);
                break;
        }
    }
    updateFeature(name, overrideOptions) {
        const feature = this.features.find(x => x.name === name);
        if (feature) {
            Object.assign(feature, overrideOptions);
        }
    }
    /**
     * Returns and object like `{name: "feature"}` with any other default properties
     * @param name Feature name
     */
    getFeature(name) {
        const feature = { name };
        if (this.featureProps[name]) {
            Object.assign(feature, this.featureProps[name]);
        }
        if (this.tree && this.treeGridFeatureProps[name]) {
            Object.assign(feature, this.treeGridFeatureProps[name]);
        }
        if (this.hierarchical) {
            feature["inherit"] = true;
        }
        return feature;
    }
    generateXML(pad) {
        let result = "<features>";
        for (const feature of this.features) {
            result += `\r\n${this.space.repeat(pad + 1)}<feature`;
            result += Object.keys(feature).reduce((str, key) => {
                str += ` ${key}="${feature[key]}"`;
                return str;
            }, "");
            result += ">";
        }
        result += `\r\n${this.space.repeat(pad)}</feature>`;
        return result;
    }
}
exports.GridHelper = GridHelper;
