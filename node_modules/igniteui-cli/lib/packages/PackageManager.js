"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const path = require("path");
const ProjectConfig_1 = require("../ProjectConfig");
const Util_1 = require("../Util");
const componentsConfig = require("./components");
class PackageManager {
    /**
     * Specific for Ignite UI packages handling:
     *
     * Checks if a full version is required, if there's a user for the ProGet registry
     * and swaps the OSS package for the full version.
     * @param installNow Allow the check to also try installing required Ignite UI package
     */
    static ensureIgniteUISource(installNow = false, templateManager, verbose = false) {
        const config = ProjectConfig_1.ProjectConfig.localConfig();
        const fullComponents = config.project.components.filter(x => {
            return componentsConfig.full.indexOf(x) !== -1 || componentsConfig.dv.indexOf(x) !== -1;
        });
        if (!(fullComponents.length && this.isOSSPackage(config.project.igniteuiSource))) {
            //no upgrade required
            return;
        }
        if (installNow) {
            const ossVersion = this.getPackageJSON().dependencies[this.ossPackage];
            const version = ossVersion ? `@"${ossVersion}"` : "";
            if (this.ensureRegistryUser(config) && this.addPackage(this.fullPackage + version, verbose)) {
                if (ossVersion) {
                    // TODO: Check if OSS package uninstalled successfully?
                    this.removePackage(this.ossPackage, verbose);
                }
                config.project.igniteuiSource = `./node_modules/${this.fullPackage}/en`;
                ProjectConfig_1.ProjectConfig.setConfig(config);
                if (!config.project.isBundle) {
                    // TODO make param?
                    const projectLibrary = templateManager.getProjectLibrary(config.project.framework, config.project.projectType);
                    if (projectLibrary) {
                        // TODO multiple projects?
                        let project;
                        if (!config.project.projectTemplate) {
                            // in case project tempale is missing from the config we provide backward.
                            project = projectLibrary.getProject(projectLibrary.projectIds[0]);
                        }
                        else {
                            project = projectLibrary.getProject(config.project.projectTemplate);
                        }
                        project.upgradeIgniteUIPackage(process.cwd(), `./node_modules/${this.fullPackage}/en`);
                    }
                }
            }
            else {
                Util_1.Util.log("Something went wrong with upgrading Ignite UI to the full version." +
                    `As a result only views using OSS components will run correctly.`, "yellow");
                Util_1.Util.log("Please visit https://www.igniteui.com/help/using-ignite-ui-npm-packages" +
                    `for instructions on how to install the full package.`, "yellow");
            }
        }
        else {
            Util_1.Util.log("Template(s) that require the full version of Ignite UI found in the project." +
                "You might be prompted for credentials on build to install it.", "yellow");
        }
    }
    static installPackages(verbose = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const config = ProjectConfig_1.ProjectConfig.localConfig();
            if (!config.packagesInstalled) {
                let command;
                let managerCommand;
                managerCommand = this.getManager();
                switch (managerCommand) {
                    case "npm":
                    /* passes through */
                    default:
                        command = `${managerCommand} install --quiet`;
                        break;
                }
                yield this.flushQueue(false);
                Util_1.Util.log(`Installing ${managerCommand} packages`);
                try {
                    const result = child_process_1.execSync(command, { stdio: "pipe", killSignal: "SIGINT" });
                    Util_1.Util.log(`Packages installed successfully`);
                }
                catch (error) {
                    // ^C (SIGINT) produces status:3221225786 https://github.com/sass/node-sass/issues/1283#issuecomment-169450661
                    if (error.status === 3221225786 || error.status > 128) {
                        // drop process on user interrupt
                        process.exit();
                        return; // just for tests
                    }
                    Util_1.Util.log(`Error installing ${managerCommand} packages.`);
                    if (verbose) {
                        Util_1.Util.log(error.message);
                    }
                }
                config.packagesInstalled = true;
                ProjectConfig_1.ProjectConfig.setConfig(config);
            }
        });
    }
    static removePackage(packageName, verbose = false) {
        let command;
        const managerCommand = this.getManager();
        switch (managerCommand) {
            case "npm":
            /* passes through */
            default:
                command = `${managerCommand} uninstall ${packageName} --quiet --save`;
                break;
        }
        try {
            // tslint:disable-next-line:object-literal-sort-keys
            const result = child_process_1.execSync(command, { stdio: "pipe", encoding: "utf8" });
        }
        catch (error) {
            Util_1.Util.log(`Error uninstalling package ${packageName} with ${managerCommand}`);
            if (verbose) {
                Util_1.Util.log(error.message);
            }
            return false;
        }
        Util_1.Util.log(`Package ${packageName} uninstalled successfully`);
        return true;
    }
    static addPackage(packageName, verbose = false) {
        const managerCommand = this.getManager();
        const command = this.getInstallCommand(managerCommand, packageName);
        try {
            // tslint:disable-next-line:object-literal-sort-keys
            const result = child_process_1.execSync(command, { stdio: "pipe", encoding: "utf8" });
        }
        catch (error) {
            Util_1.Util.log(`Error installing package ${packageName} with ${managerCommand}`);
            if (verbose) {
                Util_1.Util.log(error.message);
            }
            return false;
        }
        Util_1.Util.log(`Package ${packageName} installed successfully`);
        return true;
    }
    static queuePackage(packageName, verbose = false) {
        return __awaiter(this, void 0, void 0, function* () {
            const command = this.getInstallCommand(this.getManager(), packageName);
            const packName = packageName.split(/@[^\/]+$/)[0];
            if (this.getPackageJSON().dependencies[packName] || this.installQueue.find(x => x["packageName"] === packName)) {
                return;
            }
            // D.P. Concurrent install runs should be supported
            // https://github.com/npm/npm/issues/5948
            // https://github.com/npm/npm/issues/2500
            const task = new Promise((resolve, reject) => {
                const child = child_process_1.exec(command, {}, (error, stdout, stderr) => {
                    resolve({ packageName, error, stdout, stderr });
                });
            });
            task["packageName"] = packName;
            this.installQueue.push(task);
        });
    }
    /** Waits for queued installs to finish, optionally log results and clear queue */
    static flushQueue(logSuccess, verbose = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.installQueue.length) {
                Util_1.Util.log(`Waiting for additional packages to install`);
                const results = yield Promise.all(this.installQueue);
                for (const res of results) {
                    if (res.error) {
                        Util_1.Util.log(`Error installing package ${res.packageName}`);
                        if (verbose) {
                            Util_1.Util.log(res.stderr.toString());
                        }
                    }
                    else if (logSuccess) {
                        Util_1.Util.log(`Package ${res.packageName} installed successfully`);
                    }
                }
                this.installQueue = [];
            }
        });
    }
    static ensureRegistryUser(config) {
        const fullPackageRegistry = config.igPackageRegistry;
        try {
            // tslint:disable-next-line:object-literal-sort-keys
            const user = child_process_1.execSync(`npm whoami --registry=${fullPackageRegistry}`, { stdio: "pipe", encoding: "utf8" });
        }
        catch (error) {
            // try registering the user:
            Util_1.Util.log("The project you've created requires the full version of Ignite UI from Infragistics private feed.", "gray");
            Util_1.Util.log("We are initiating the login process for you. This will be required only once per environment.", "gray");
            Util_1.Util.log(`Adding a registry user account for ${fullPackageRegistry}`, "yellow");
            Util_1.Util.log(`Use you Infragistics account credentials. "@" is not supported,` +
                `use "!!", so "username@infragistics.com" should be entered as "username!!infragistics.com"`, "yellow");
            const cmd = /^win/.test(process.platform) ? "npm.cmd" : "npm"; //https://github.com/nodejs/node/issues/3675
            const login = child_process_1.spawnSync(cmd, ["adduser", `--registry=${fullPackageRegistry}`, `--scope=@infragistics`, `--always-auth`], { stdio: "inherit" });
            if (login.status === 0) {
                //make sure scope is configured:
                try {
                    child_process_1.execSync(`npm config set @infragistics:registry ${fullPackageRegistry}`);
                    return true;
                }
                catch (error) {
                    return false;
                }
            }
            else {
                Util_1.Util.log("Something went wrong, " +
                    "please follow the steps in this guide: https://www.igniteui.com/help/using-ignite-ui-npm-packages", "red");
                return false;
            }
        }
        return true;
    }
    static getPackageJSON() {
        const filePath = path.join(process.cwd(), "package.json");
        return require(filePath);
    }
    static getInstallCommand(managerCommand, packageName) {
        switch (managerCommand) {
            case "npm":
            /* passes through */
            default:
                return `${managerCommand} install ${packageName} --quiet --save`;
        }
    }
    static getManager( /*config:Config*/) {
        //stub to potentially swap out managers
        return "npm";
    }
    static isOSSPackage(original) {
        return original === `./node_modules/${this.ossPackage}`;
    }
}
PackageManager.ossPackage = "ignite-ui";
PackageManager.fullPackage = "@infragistics/ignite-ui-full";
PackageManager.installQueue = [];
exports.PackageManager = PackageManager;
