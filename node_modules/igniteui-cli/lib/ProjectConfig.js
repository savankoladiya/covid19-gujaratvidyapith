"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const os = require("os");
const path = require("path");
const Util_1 = require("./Util");
class ProjectConfig {
    /** Returns true if there's a CLI config file in the current working directory */
    static hasLocalConfig() {
        if (os.homedir() === process.cwd()) {
            return false;
        }
        const filePath = path.join(process.cwd(), this.configFile);
        return fs.existsSync(filePath);
    }
    /**
     * Get effective CLI configuration (merged defaults, global and local)
     * @param global return only global values
     */
    static getConfig(global = false) {
        const filePath = path.join(process.cwd(), this.configFile);
        const config = {};
        Util_1.Util.merge(config, this.defaults);
        Util_1.Util.merge(config, this.globalConfig());
        if (!global) {
            Util_1.Util.merge(config, this.localConfig());
        }
        return config;
    }
    /**
     * Write a configuration file (either local or global) with given `Config` object.
     * Will create or overwrite.
     * @param config Config object to set
     * @param global Set global values instead
     */
    static setConfig(config, global = false) {
        const basePath = global ? os.homedir() : process.cwd();
        const filePath = path.join(basePath, this.configFile);
        fs.writeFileSync(filePath, JSON.stringify(config, null, 4) + "\n");
    }
    /*** Get local configuration only */
    static localConfig() {
        const filePath = path.join(process.cwd(), this.configFile);
        let localConfig = {};
        if (fs.existsSync(filePath)) {
            try {
                localConfig = JSON.parse(fs.readFileSync(filePath, "utf8"));
            }
            catch (error) {
                throw new Error(`The ${this.configFile} file is not parsed correctly. ` +
                    `The following error has occurred: ${error.message}`);
            }
        }
        return localConfig;
    }
    /*** Get global configuration only */
    static globalConfig() {
        const globalConfigPath = path.join(os.homedir(), this.configFile);
        let globalConfig = {};
        if (fs.existsSync(globalConfigPath)) {
            try {
                globalConfig = require(globalConfigPath);
            }
            catch (_a) {
                Util_1.Util.error("Invalid global config found!");
            }
        }
        return globalConfig;
    }
    /*** Validates if provided value could be set to provided property against provided schema */
    static validateProperty(property, value) {
        const schema = this.getSchema();
        if (typeof schema !== "object" && schema.properties) {
            throw new Error("Incorrect schema provided. Schema should be object");
        }
        const result = { message: undefined, valid: false, value: undefined };
        if (!schema.properties.hasOwnProperty(property)) {
            result.message = `Property "${property}" is not allowed in "${schema.title}" type!`;
            return result;
        }
        const propertyType = schema.properties[property]["type"];
        if (propertyType !== "string") {
            let parsedValue;
            try {
                parsedValue = JSON.parse(value);
            }
            catch (error) {
                result.message = `Invalid value provided for ${property} property`;
                return result;
            }
            if (propertyType === "array") {
                if (Array.isArray(parsedValue) && parsedValue.length === 0) {
                    result.valid = true;
                    result.value = parsedValue;
                    return result;
                }
                else {
                    result.message = `Provided value should be an empty array for ${property} property`;
                    return result;
                }
            }
            if (typeof parsedValue !== propertyType) {
                result.message = `Invalid value type provided for ${property} property`;
                result.message += `\nValue should be of type ${propertyType}`;
                return result;
            }
        }
        result.valid = true;
        result.value = value;
        return result;
    }
    static getSchema() {
        const absolutePath = path.join(__dirname, this.schemaPath);
        return require(absolutePath);
    }
}
ProjectConfig.configFile = "ignite-ui-cli.json";
ProjectConfig.defaults = require("./config/defaults.json");
ProjectConfig.schemaPath = "./config/Config.schema.json";
exports.ProjectConfig = ProjectConfig;
