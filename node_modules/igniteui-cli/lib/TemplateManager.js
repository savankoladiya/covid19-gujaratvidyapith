"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const ProjectConfig_1 = require("./ProjectConfig");
const AngularTemplate_1 = require("./templates/AngularTemplate");
const IgniteUIForAngularTemplate_1 = require("./templates/IgniteUIForAngularTemplate");
const jQueryTemplate_1 = require("./templates/jQueryTemplate");
const ReactTemplate_1 = require("./templates/ReactTemplate");
const Util_1 = require("./Util");
class TemplateManager {
    constructor(templatesPath) {
        this._templatesPath = "../templates";
        this._quickstartTemplatesPath = "quickstart";
        this.frameworks = [];
        if (templatesPath) {
            this._templatesPath = templatesPath;
        }
        // read dirs and push dir names into frameworks
        const frameworks = Util_1.Util.getDirectoryNames(path.join(__dirname, this._templatesPath))
            .filter(x => x !== this._quickstartTemplatesPath);
        // load and initialize templates
        for (const framework of frameworks) {
            this.frameworks.push(require(path.join(__dirname, this._templatesPath, framework)));
        }
        // load external templates
        this.loadExternalTemplates();
    }
    getFrameworkIds() {
        return this.frameworks.map(f => f.id);
    }
    getFrameworkNames() {
        return this.frameworks.map(f => f.name);
    }
    /**  Returns framework found by its name or undefined. */
    getFrameworkByName(name) {
        return this.frameworks.find(s => s.name === name);
    }
    /**  Returns framework found by its ID or undefined. */
    getFrameworkById(id) {
        return this.frameworks.find(f => f.id === id);
    }
    /**
     * Get ProjectLibrary Names list
     * @param frameworkId
     * @returns Returns projectLibrary names array
     */
    getProjectLibraryNames(frameworkId) {
        let projects = [];
        const framework = this.frameworks.find(f => f.id === frameworkId);
        if (framework) {
            projects = framework.projectLibraries.map(x => x.name);
        }
        return projects;
    }
    /**
     * Get ProjectLibrary by name
     * @param framework
     * @param name
     * @returns Returns matching projectLibrary or undefined
     */
    getProjectLibraryByName(framework, name) {
        let projectLib;
        if (name) {
            projectLib = framework.projectLibraries.find(x => x.name === name);
        }
        return projectLib;
    }
    /**
     * Get a specific project library
     * @param frameworkId
     * @param projectType
     * @returns Returns projectLibrary, or null.
     */
    getProjectLibrary(frameworkId, projectType) {
        const framework = this.frameworks.find(f => f.id === frameworkId);
        if (framework) {
            if (projectType) {
                return framework.projectLibraries.find(x => x.projectType === projectType);
            }
            else {
                return framework.projectLibraries.length > 0 ? framework.projectLibraries[0] : null;
            }
        }
        return null;
    }
    updateProjectConfiguration(template) {
        const config = ProjectConfig_1.ProjectConfig.getConfig();
        // add each separately to avoid duplicates:
        for (const element of template.dependencies) {
            if (typeof element === "string" && config.project.components.indexOf(element) === -1) {
                config.project.components.push(element);
            }
        }
        ProjectConfig_1.ProjectConfig.setConfig(config);
    }
    //#region plugin templates
    /** Read config and load custom templates based on type */
    loadExternalTemplates() {
        const config = ProjectConfig_1.ProjectConfig.getConfig();
        const customTemplates = [];
        for (const entry of config.customTemplates) {
            let template;
            // tslint:disable-next-line:prefer-const
            let [protocol, value] = entry.split(/(^[^:]+):/).filter(x => x);
            switch (protocol) {
                default:
                    // in case just path is passed:
                    value = entry;
                case "file":
                case "path":
                    value = value.replace(/template\.json$/, "");
                    if (Util_1.Util.directoryExists(value)) {
                        // try single template
                        template = this.loadFromConfig(path.join(value, "template.json"));
                        if (template !== null) {
                            customTemplates.push(template);
                            break;
                        }
                        // try folder of templates:
                        for (const folder of Util_1.Util.getDirectoryNames(value)) {
                            template = this.loadFromConfig(path.join(value, folder, "template.json"));
                            if (template !== null) {
                                customTemplates.push(template);
                            }
                        }
                    }
                    else {
                        // TODO: Util.log(`Ignored: Incorrect custom template path for "${entry}".`);
                    }
                    break;
                case "ignored":
                    break;
            }
        }
        this.addTemplates(customTemplates);
    }
    /**
     * Loads properties from a JSON file and initializes a base Template implementation
     * @param filePath Path to a json config file representing a template
     * @returns null if no proper file is found
     */
    loadFromConfig(filePath) {
        let template = null;
        if (Util_1.Util.fileExists(filePath)) {
            const rootPath = path.dirname(filePath);
            const settings = require(filePath);
            switch (`${settings.framework}|${settings.projectType}`) {
                case "jquery|js":
                    template = new jQueryTemplate_1.jQueryTemplate(rootPath);
                    break;
                case "react|es6":
                    template = new ReactTemplate_1.ReactTemplate(rootPath);
                    break;
                case "angular|ig-ts":
                    template = new AngularTemplate_1.AngularTemplate(rootPath);
                    break;
                case "angular|igx-ts":
                    template = new IgniteUIForAngularTemplate_1.IgniteUIForAngularTemplate(rootPath);
                    break;
                default:
                    Util_1.Util.error(`The framework/project type for template with id "${settings.id}" is not supported.`);
                    Util_1.Util.error(`File path: ${filePath}`);
                    break;
            }
            if (template !== null) {
                Object.assign(template, settings);
            }
        }
        return template;
    }
    addTemplates(templates) {
        for (const template of templates) {
            const projectLib = this.getProjectLibrary(template.framework, template.projectType);
            if (!projectLib) {
                Util_1.Util.error(`The framework/project type for template with id "${template.id}" is not supported.`);
                continue;
            }
            if (projectLib.hasTemplate(template.id)) {
                Util_1.Util.error(`Template with id "${template.id}" already exists.`);
                continue;
            }
            if (projectLib.getComponentGroupNames().indexOf(template.controlGroup) === -1 && !template.listInCustomTemplates) {
                Util_1.Util.error(`No supported group for template with id "${template.id}".`);
                continue;
            }
            projectLib.registerTemplate(template);
        }
    }
}
exports.TemplateManager = TemplateManager;
