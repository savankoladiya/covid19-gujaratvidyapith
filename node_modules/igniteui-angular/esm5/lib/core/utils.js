/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Injectable, PLATFORM_ID, Inject } from '@angular/core';
import { isPlatformBrowser } from '@angular/common';
import * as i0 from "@angular/core";
/**
 * @hidden
 * @param {?} array
 * @param {?=} deep
 * @return {?}
 */
export function cloneArray(array, deep) {
    /** @type {?} */
    var arr = [];
    if (!array) {
        return arr;
    }
    /** @type {?} */
    var i = array.length;
    while (i--) {
        arr[i] = deep ? cloneValue(array[i]) : array[i];
    }
    return arr;
}
/**
 * Doesn't clone leaf items
 * @hidden
 * @param {?} array
 * @param {?} childDataKey
 * @return {?}
 */
export function cloneHierarchicalArray(array, childDataKey) {
    var e_1, _a;
    /** @type {?} */
    var result = [];
    if (!array) {
        return result;
    }
    try {
        for (var array_1 = tslib_1.__values(array), array_1_1 = array_1.next(); !array_1_1.done; array_1_1 = array_1.next()) {
            var item = array_1_1.value;
            /** @type {?} */
            var clonedItem = cloneValue(item);
            if (Array.isArray(item[childDataKey])) {
                clonedItem[childDataKey] = cloneHierarchicalArray(clonedItem[childDataKey], childDataKey);
            }
            result.push(clonedItem);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (array_1_1 && !array_1_1.done && (_a = array_1.return)) _a.call(array_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return result;
}
/**
 * Deep clones all first level keys of Obj2 and merges them to Obj1
 * @hidden
 * @param {?} obj1 Object to merge into
 * @param {?} obj2 Object to merge from
 * @return {?} Obj1 with merged cloned keys from Obj2
 */
export function mergeObjects(obj1, obj2) {
    var e_2, _a;
    if (!isObject(obj1)) {
        throw new Error("Cannot merge into " + obj1 + ". First param must be an object.");
    }
    if (!isObject(obj2)) {
        return obj1;
    }
    try {
        for (var _b = tslib_1.__values(Object.keys(obj2)), _c = _b.next(); !_c.done; _c = _b.next()) {
            var key = _c.value;
            obj1[key] = cloneValue(obj2[key]);
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_2) throw e_2.error; }
    }
    return obj1;
}
/**
 * Creates deep clone of provided value.
 * Supports primitive values, dates and objects.
 * If passed value is array returns shallow copy of the array.
 * @hidden
 * @param {?} value value to clone
 * @return {?} Deep copy of provided value
 */
export function cloneValue(value) {
    var e_3, _a;
    if (isDate(value)) {
        return new Date(value.getTime());
    }
    if (Array.isArray(value)) {
        return tslib_1.__spread(value);
    }
    if (value instanceof Map || value instanceof Set) {
        return value;
    }
    if (isObject(value)) {
        /** @type {?} */
        var result = {};
        try {
            for (var _b = tslib_1.__values(Object.keys(value)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var key = _c.value;
                result[key] = cloneValue(value[key]);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return result;
    }
    return value;
}
/**
 * Checks if provided variable is Object
 * @hidden
 * @param {?} value Value to check
 * @return {?} true if provided variable is Object
 */
export function isObject(value) {
    return value && value.toString() === '[object Object]';
}
/**
 * Checks if provided variable is Date
 * @hidden
 * @param {?} value Value to check
 * @return {?} true if provided variable is Date
 */
export function isDate(value) {
    return Object.prototype.toString.call(value) === '[object Date]';
}
/**
 * Checks if the two passed arguments are equal
 * Currently supports date objects
 * \@returns: `boolean`
 * @hidden
 * @param {?} obj1
 * @param {?} obj2
 * @return {?}
 */
export function isEqual(obj1, obj2) {
    if (isDate(obj1) && isDate(obj2)) {
        return obj1.getTime() === obj2.getTime();
    }
    return obj1 === obj2;
}
/** @enum {number} */
var KEYCODES = {
    ENTER: 13,
    SPACE: 32,
    ESCAPE: 27,
    LEFT_ARROW: 37,
    UP_ARROW: 38,
    RIGHT_ARROW: 39,
    DOWN_ARROW: 40,
    F2: 113,
    TAB: 9,
};
export { KEYCODES };
/** @enum {string} */
var KEYS = {
    ENTER: 'Enter',
    SPACE: ' ',
    SPACE_IE: 'Spacebar',
    ESCAPE: 'Escape',
    ESCAPE_IE: 'Esc',
    LEFT_ARROW: 'ArrowLeft',
    LEFT_ARROW_IE: 'Left',
    UP_ARROW: 'ArrowUp',
    UP_ARROW_IE: 'Up',
    RIGHT_ARROW: 'ArrowRight',
    RIGHT_ARROW_IE: 'Right',
    DOWN_ARROW: 'ArrowDown',
    DOWN_ARROW_IE: 'Down',
    F2: 'F2',
    TAB: 'Tab',
};
export { KEYS };
/**
 * @hidden
 * Returns the actual size of the node content, using Range
 * ```typescript
 * let range = document.createRange();
 * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
 *
 * let size = getNodeSizeViaRange(range, column.cells[0].nativeElement);
 * ```
 * @param {?} range
 * @param {?} node
 * @return {?}
 */
export function getNodeSizeViaRange(range, node) {
    /** @type {?} */
    var overflow = null;
    if (!isFirefox()) {
        overflow = node.style.overflow;
        // we need that hack - otherwise content won't be measured correctly in IE/Edge
        node.style.overflow = 'visible';
    }
    range.selectNodeContents(node);
    /** @type {?} */
    var width = range.getBoundingClientRect().width;
    if (!isFirefox()) {
        // we need that hack - otherwise content won't be measured correctly in IE/Edge
        node.style.overflow = overflow;
    }
    return width;
}
/**
 * @hidden
 * Returns the actual size of the node content, using Canvas
 * ```typescript
 * let ctx = document.createElement('canvas').getContext('2d');
 * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
 *
 * let size = valToPxlsUsingCanvas(ctx, column.cells[0].nativeElement);
 * ```
 * @param {?} canvas2dCtx
 * @param {?} node
 * @return {?}
 */
export function getNodeSizeViaCanvas(canvas2dCtx, node) {
    /** @type {?} */
    var s = this.grid.document.defaultView.getComputedStyle(node);
    // need to set the font to get correct width
    canvas2dCtx.font = s.fontSize + ' ' + s.fontFamily;
    return canvas2dCtx.measureText(node.textContent).width;
}
/**
 * @hidden
 * @return {?}
 */
export function isIE() {
    return navigator.appVersion.indexOf('Trident/') > 0;
}
/**
 * @hidden
 * @return {?}
 */
export function isEdge() {
    /** @type {?} */
    var edgeBrowser = /Edge[\/\s](\d+\.\d+)/.test(navigator.userAgent);
    return edgeBrowser;
}
/**
 * @hidden
 * @return {?}
 */
export function isFirefox() {
    /** @type {?} */
    var firefoxBrowser = /Firefox[\/\s](\d+\.\d+)/.test(navigator.userAgent);
    return firefoxBrowser;
}
/**
 * @hidden
 */
var PlatformUtil = /** @class */ (function () {
    function PlatformUtil(platformId) {
        this.platformId = platformId;
        this.isBrowser = isPlatformBrowser(this.platformId);
        this.isIOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !('MSStream' in window);
    }
    PlatformUtil.decorators = [
        { type: Injectable, args: [{ providedIn: 'root' },] }
    ];
    /** @nocollapse */
    PlatformUtil.ctorParameters = function () { return [
        { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
    ]; };
    /** @nocollapse */ PlatformUtil.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function PlatformUtil_Factory() { return new PlatformUtil(i0.ɵɵinject(i0.PLATFORM_ID)); }, token: PlatformUtil, providedIn: "root" });
    return PlatformUtil;
}());
export { PlatformUtil };
if (false) {
    /** @type {?} */
    PlatformUtil.prototype.isBrowser;
    /** @type {?} */
    PlatformUtil.prototype.isIOS;
    /**
     * @type {?}
     * @private
     */
    PlatformUtil.prototype.platformId;
}
/**
 * @hidden
 * @param {?} event
 * @return {?}
 */
export function isLeftClick(event) {
    return event.button === 0;
}
/**
 * @hidden
 * @param {?} key
 * @return {?}
 */
export function isNavigationKey(key) {
    return [
        'down',
        'up',
        'left',
        'right',
        'arrowdown',
        'arrowup',
        'arrowleft',
        'arrowright',
        'home',
        'end',
        'space',
        'spacebar',
        ' '
    ].indexOf(key) !== -1;
}
/**
 * @hidden
 * @param {?} arr
 * @return {?}
 */
export function flatten(arr) {
    /** @type {?} */
    var result = [];
    arr.forEach(function (el) {
        result.push(el);
        if (el.children) {
            /** @type {?} */
            var children = Array.isArray(el.children) ? el.children : el.children.toArray();
            result = result.concat(flatten(children));
        }
    });
    return result;
}
/**
 * @record
 */
export function CancelableEventArgs() { }
if (false) {
    /**
     * Provides the ability to cancel the event.
     * @type {?}
     */
    CancelableEventArgs.prototype.cancel;
}
/**
 * @record
 */
export function IBaseEventArgs() { }
if (false) {
    /**
     * Provides reference to the owner component.
     * @type {?|undefined}
     */
    IBaseEventArgs.prototype.owner;
}
/**
 * @record
 */
export function CancelableBrowserEventArgs() { }
if (false) {
    /**
     * Browser event
     * @type {?|undefined}
     */
    CancelableBrowserEventArgs.prototype.event;
}
/** @type {?} */
export var NAVIGATION_KEYS = new Set([
    'down',
    'up',
    'left',
    'right',
    'arrowdown',
    'arrowup',
    'arrowleft',
    'arrowright',
    'home',
    'end',
    'space',
    'spacebar',
    ' '
]);
/** @type {?} */
export var ROW_EXPAND_KEYS = new Set('right down arrowright arrowdown'.split(' '));
/** @type {?} */
export var ROW_COLLAPSE_KEYS = new Set('left up arrowleft arrowup'.split(' '));
/** @type {?} */
export var SUPPORTED_KEYS = new Set(tslib_1.__spread(Array.from(NAVIGATION_KEYS), ['tab', 'enter', 'f2', 'escape', 'esc']));
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9pZ25pdGV1aS1hbmd1bGFyLyIsInNvdXJjZXMiOlsibGliL2NvcmUvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLFdBQVcsRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDaEUsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0saUJBQWlCLENBQUM7Ozs7Ozs7O0FBS3BELE1BQU0sVUFBVSxVQUFVLENBQUMsS0FBWSxFQUFFLElBQWM7O1FBQzdDLEdBQUcsR0FBRyxFQUFFO0lBQ2QsSUFBSSxDQUFDLEtBQUssRUFBRTtRQUNSLE9BQU8sR0FBRyxDQUFDO0tBQ2Q7O1FBQ0csQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNO0lBQ3BCLE9BQU8sQ0FBQyxFQUFFLEVBQUU7UUFDUixHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUNuRDtJQUNELE9BQU8sR0FBRyxDQUFDO0FBQ2YsQ0FBQzs7Ozs7Ozs7QUFNRCxNQUFNLFVBQVUsc0JBQXNCLENBQUMsS0FBWSxFQUFFLFlBQWlCOzs7UUFDNUQsTUFBTSxHQUFVLEVBQUU7SUFDeEIsSUFBSSxDQUFDLEtBQUssRUFBRTtRQUNSLE9BQU8sTUFBTSxDQUFDO0tBQ2pCOztRQUVELEtBQW1CLElBQUEsVUFBQSxpQkFBQSxLQUFLLENBQUEsNEJBQUEsK0NBQUU7WUFBckIsSUFBTSxJQUFJLGtCQUFBOztnQkFDTCxVQUFVLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQztZQUNuQyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLEVBQUU7Z0JBQ25DLFVBQVUsQ0FBQyxZQUFZLENBQUMsR0FBRyxz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QUFDcEYsTUFBTSxLQUFPLGlCQUFpQixHQUFHLElBQUksR0FBRyxDQUFDLDJCQUEyQixDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQzs7QUFDaEYsTUFBTSxLQUFPLGNBQWMsR0FBRyxJQUFJLEdBQUcsa0JBQUssS0FBSyxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsR0FBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsS0FBSyxHQUFFIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgUExBVEZPUk1fSUQsIEluamVjdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgaXNQbGF0Zm9ybUJyb3dzZXIgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG4vKipcbiAqQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvbmVBcnJheShhcnJheTogYW55W10sIGRlZXA/OiBib29sZWFuKSB7XG4gICAgY29uc3QgYXJyID0gW107XG4gICAgaWYgKCFhcnJheSkge1xuICAgICAgICByZXR1cm4gYXJyO1xuICAgIH1cbiAgICBsZXQgaSA9IGFycmF5Lmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIGFycltpXSA9IGRlZXAgPyBjbG9uZVZhbHVlKGFycmF5W2ldKSA6IGFycmF5W2ldO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuXG4vKipcbiAqIERvZXNuJ3QgY2xvbmUgbGVhZiBpdGVtc1xuICogQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvbmVIaWVyYXJjaGljYWxBcnJheShhcnJheTogYW55W10sIGNoaWxkRGF0YUtleTogYW55KTogYW55W10ge1xuICAgIGNvbnN0IHJlc3VsdDogYW55W10gPSBbXTtcbiAgICBpZiAoIWFycmF5KSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGFycmF5KSB7XG4gICAgICAgIGNvbnN0IGNsb25lZEl0ZW0gPSBjbG9uZVZhbHVlKGl0ZW0pO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtW2NoaWxkRGF0YUtleV0pKSB7XG4gICAgICAgICAgICBjbG9uZWRJdGVtW2NoaWxkRGF0YUtleV0gPSBjbG9uZUhpZXJhcmNoaWNhbEFycmF5KGNsb25lZEl0ZW1bY2hpbGREYXRhS2V5XSwgY2hpbGREYXRhS2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaChjbG9uZWRJdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBEZWVwIGNsb25lcyBhbGwgZmlyc3QgbGV2ZWwga2V5cyBvZiBPYmoyIGFuZCBtZXJnZXMgdGhlbSB0byBPYmoxXG4gKiBAcGFyYW0gb2JqMSBPYmplY3QgdG8gbWVyZ2UgaW50b1xuICogQHBhcmFtIG9iajIgT2JqZWN0IHRvIG1lcmdlIGZyb21cbiAqIEByZXR1cm5zIE9iajEgd2l0aCBtZXJnZWQgY2xvbmVkIGtleXMgZnJvbSBPYmoyXG4gKiBAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZU9iamVjdHMob2JqMToge30sIG9iajI6IHt9KTogYW55IHtcbiAgICBpZiAoIWlzT2JqZWN0KG9iajEpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IG1lcmdlIGludG8gJHtvYmoxfS4gRmlyc3QgcGFyYW0gbXVzdCBiZSBhbiBvYmplY3QuYCk7XG4gICAgfVxuXG4gICAgaWYgKCFpc09iamVjdChvYmoyKSkge1xuICAgICAgICByZXR1cm4gb2JqMTtcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvYmoyKSkge1xuICAgICAgICBvYmoxW2tleV0gPSBjbG9uZVZhbHVlKG9iajJba2V5XSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG9iajE7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBkZWVwIGNsb25lIG9mIHByb3ZpZGVkIHZhbHVlLlxuICogU3VwcG9ydHMgcHJpbWl0aXZlIHZhbHVlcywgZGF0ZXMgYW5kIG9iamVjdHMuXG4gKiBJZiBwYXNzZWQgdmFsdWUgaXMgYXJyYXkgcmV0dXJucyBzaGFsbG93IGNvcHkgb2YgdGhlIGFycmF5LlxuICogQHBhcmFtIHZhbHVlIHZhbHVlIHRvIGNsb25lXG4gKiBAcmV0dXJucyBEZWVwIGNvcHkgb2YgcHJvdmlkZWQgdmFsdWVcbiAqQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gY2xvbmVWYWx1ZSh2YWx1ZTogYW55KTogYW55IHtcbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUodmFsdWUuZ2V0VGltZSgpKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBbLi4udmFsdWVdO1xuICAgIH1cblxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCB8fCB2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcblxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gY2xvbmVWYWx1ZSh2YWx1ZVtrZXldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHByb3ZpZGVkIHZhcmlhYmxlIGlzIE9iamVjdFxuICogQHBhcmFtIHZhbHVlIFZhbHVlIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB0cnVlIGlmIHByb3ZpZGVkIHZhcmlhYmxlIGlzIE9iamVjdFxuICpAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdCh2YWx1ZTogYW55KTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHZhbHVlLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBwcm92aWRlZCB2YXJpYWJsZSBpcyBEYXRlXG4gKiBAcGFyYW0gdmFsdWUgVmFsdWUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHRydWUgaWYgcHJvdmlkZWQgdmFyaWFibGUgaXMgRGF0ZVxuICpAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0RhdGUodmFsdWU6IGFueSkge1xuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSB0d28gcGFzc2VkIGFyZ3VtZW50cyBhcmUgZXF1YWxcbiAqIEN1cnJlbnRseSBzdXBwb3J0cyBkYXRlIG9iamVjdHNcbiAqIEBwYXJhbSBvYmoxXG4gKiBAcGFyYW0gb2JqMlxuICogQHJldHVybnM6IGBib29sZWFuYFxuICogQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNFcXVhbChvYmoxLCBvYmoyKTogYm9vbGVhbiB7XG4gICAgaWYgKGlzRGF0ZShvYmoxKSAmJiBpc0RhdGUob2JqMikpIHtcbiAgICAgICAgcmV0dXJuIG9iajEuZ2V0VGltZSgpID09PSBvYmoyLmdldFRpbWUoKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajEgPT09IG9iajI7XG59XG5cbi8qKlxuICpAaGlkZGVuXG4gKi9cbmV4cG9ydCBjb25zdCBlbnVtIEtFWUNPREVTIHtcbiAgICBFTlRFUiA9IDEzLFxuICAgIFNQQUNFID0gMzIsXG4gICAgRVNDQVBFID0gMjcsXG4gICAgTEVGVF9BUlJPVyA9IDM3LFxuICAgIFVQX0FSUk9XID0gMzgsXG4gICAgUklHSFRfQVJST1cgPSAzOSxcbiAgICBET1dOX0FSUk9XID0gNDAsXG4gICAgRjIgPSAxMTMsXG4gICAgVEFCID0gOVxufVxuXG4vKipcbiAqQGhpZGRlblxuICovXG5leHBvcnQgY29uc3QgZW51bSBLRVlTIHtcbiAgICBFTlRFUiA9ICdFbnRlcicsXG4gICAgU1BBQ0UgPSAnICcsXG4gICAgU1BBQ0VfSUUgPSAnU3BhY2ViYXInLFxuICAgIEVTQ0FQRSA9ICdFc2NhcGUnLFxuICAgIEVTQ0FQRV9JRSA9ICdFc2MnLFxuICAgIExFRlRfQVJST1cgPSAnQXJyb3dMZWZ0JyxcbiAgICBMRUZUX0FSUk9XX0lFID0gJ0xlZnQnLFxuICAgIFVQX0FSUk9XID0gJ0Fycm93VXAnLFxuICAgIFVQX0FSUk9XX0lFID0gJ1VwJyxcbiAgICBSSUdIVF9BUlJPVyA9ICdBcnJvd1JpZ2h0JyxcbiAgICBSSUdIVF9BUlJPV19JRSA9ICdSaWdodCcsXG4gICAgRE9XTl9BUlJPVyA9ICdBcnJvd0Rvd24nLFxuICAgIERPV05fQVJST1dfSUUgPSAnRG93bicsXG4gICAgRjIgPSAnRjInLFxuICAgIFRBQiA9ICdUYWInXG59XG5cbi8qKlxuICpAaGlkZGVuXG4qIFJldHVybnMgdGhlIGFjdHVhbCBzaXplIG9mIHRoZSBub2RlIGNvbnRlbnQsIHVzaW5nIFJhbmdlXG4qIGBgYHR5cGVzY3JpcHRcbiogbGV0IHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiogbGV0IGNvbHVtbiA9IHRoaXMuZ3JpZC5jb2x1bW5MaXN0LmZpbHRlcihjID0+IGMuZmllbGQgPT09ICdJRCcpWzBdO1xuKlxuKiBsZXQgc2l6ZSA9IGdldE5vZGVTaXplVmlhUmFuZ2UocmFuZ2UsIGNvbHVtbi5jZWxsc1swXS5uYXRpdmVFbGVtZW50KTtcbiogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXROb2RlU2l6ZVZpYVJhbmdlKHJhbmdlOiBSYW5nZSwgbm9kZTogYW55KTogbnVtYmVyIHtcbiAgICBsZXQgb3ZlcmZsb3cgPSBudWxsO1xuICAgIGlmICghaXNGaXJlZm94KCkpIHtcbiAgICAgICAgb3ZlcmZsb3cgPSBub2RlLnN0eWxlLm92ZXJmbG93O1xuICAgICAgICAvLyB3ZSBuZWVkIHRoYXQgaGFjayAtIG90aGVyd2lzZSBjb250ZW50IHdvbid0IGJlIG1lYXN1cmVkIGNvcnJlY3RseSBpbiBJRS9FZGdlXG4gICAgICAgIG5vZGUuc3R5bGUub3ZlcmZsb3cgPSAndmlzaWJsZSc7XG4gICAgfVxuXG4gICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKG5vZGUpO1xuICAgIGNvbnN0IHdpZHRoID0gcmFuZ2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG5cbiAgICBpZiAoIWlzRmlyZWZveCgpKSB7XG4gICAgICAgIC8vIHdlIG5lZWQgdGhhdCBoYWNrIC0gb3RoZXJ3aXNlIGNvbnRlbnQgd29uJ3QgYmUgbWVhc3VyZWQgY29ycmVjdGx5IGluIElFL0VkZ2VcbiAgICAgICAgbm9kZS5zdHlsZS5vdmVyZmxvdyA9IG92ZXJmbG93O1xuICAgIH1cblxuICAgIHJldHVybiB3aWR0aDtcbn1cbi8qKlxuICpAaGlkZGVuXG4qIFJldHVybnMgdGhlIGFjdHVhbCBzaXplIG9mIHRoZSBub2RlIGNvbnRlbnQsIHVzaW5nIENhbnZhc1xuKiBgYGB0eXBlc2NyaXB0XG4qIGxldCBjdHggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKS5nZXRDb250ZXh0KCcyZCcpO1xuKiBsZXQgY29sdW1uID0gdGhpcy5ncmlkLmNvbHVtbkxpc3QuZmlsdGVyKGMgPT4gYy5maWVsZCA9PT0gJ0lEJylbMF07XG4qXG4qIGxldCBzaXplID0gdmFsVG9QeGxzVXNpbmdDYW52YXMoY3R4LCBjb2x1bW4uY2VsbHNbMF0ubmF0aXZlRWxlbWVudCk7XG4qIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Tm9kZVNpemVWaWFDYW52YXMoY2FudmFzMmRDdHg6IGFueSwgbm9kZTogYW55KTogbnVtYmVyIHtcbiAgICBjb25zdCBzID0gdGhpcy5ncmlkLmRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG5cbiAgICAvLyBuZWVkIHRvIHNldCB0aGUgZm9udCB0byBnZXQgY29ycmVjdCB3aWR0aFxuICAgIGNhbnZhczJkQ3R4LmZvbnQgPSBzLmZvbnRTaXplICsgJyAnICsgcy5mb250RmFtaWx5O1xuXG4gICAgcmV0dXJuIGNhbnZhczJkQ3R4Lm1lYXN1cmVUZXh0KG5vZGUudGV4dENvbnRlbnQpLndpZHRoO1xufVxuLyoqXG4gKkBoaWRkZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSUUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIG5hdmlnYXRvci5hcHBWZXJzaW9uLmluZGV4T2YoJ1RyaWRlbnQvJykgPiAwO1xufVxuLyoqXG4gKkBoaWRkZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRWRnZSgpOiBib29sZWFuIHtcbiAgICBjb25zdCBlZGdlQnJvd3NlciA9IC9FZGdlW1xcL1xcc10oXFxkK1xcLlxcZCspLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIHJldHVybiBlZGdlQnJvd3Nlcjtcbn1cblxuLyoqXG4gKkBoaWRkZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRmlyZWZveCgpOiBib29sZWFuIHtcbiAgICBjb25zdCBmaXJlZm94QnJvd3NlciA9IC9GaXJlZm94W1xcL1xcc10oXFxkK1xcLlxcZCspLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgIHJldHVybiBmaXJlZm94QnJvd3Nlcjtcbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbkBJbmplY3RhYmxlKHsgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pXG5leHBvcnQgY2xhc3MgUGxhdGZvcm1VdGlsIHtcbiAgICBwdWJsaWMgaXNCcm93c2VyOiBib29sZWFuID0gaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKTtcblxuICAgIHB1YmxpYyBpc0lPUyA9IHRoaXMuaXNCcm93c2VyICYmIC9pUGFkfGlQaG9uZXxpUG9kLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICEoJ01TU3RyZWFtJyBpbiB3aW5kb3cpO1xuXG4gICAgY29uc3RydWN0b3IoQEluamVjdChQTEFURk9STV9JRCkgcHJpdmF0ZSBwbGF0Zm9ybUlkOiBPYmplY3QpIHtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNMZWZ0Q2xpY2soZXZlbnQ6IFBvaW50ZXJFdmVudCkge1xuICAgIHJldHVybiBldmVudC5idXR0b24gPT09IDA7XG59XG5cbi8qKiBAaGlkZGVuICovXG5leHBvcnQgZnVuY3Rpb24gaXNOYXZpZ2F0aW9uS2V5KGtleTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgJ2Rvd24nLFxuICAgICAgICAndXAnLFxuICAgICAgICAnbGVmdCcsXG4gICAgICAgICdyaWdodCcsXG4gICAgICAgICdhcnJvd2Rvd24nLFxuICAgICAgICAnYXJyb3d1cCcsXG4gICAgICAgICdhcnJvd2xlZnQnLFxuICAgICAgICAnYXJyb3dyaWdodCcsXG4gICAgICAgICdob21lJyxcbiAgICAgICAgJ2VuZCcsXG4gICAgICAgICdzcGFjZScsXG4gICAgICAgICdzcGFjZWJhcicsXG4gICAgICAgICcgJ1xuICAgIF0uaW5kZXhPZihrZXkpICE9PSAtMTtcbn1cblxuLyoqXG4gKkBoaWRkZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZsYXR0ZW4oYXJyOiBhbnlbXSkge1xuICAgIGxldCByZXN1bHQgPSBbXTtcblxuICAgIGFyci5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgcmVzdWx0LnB1c2goZWwpO1xuICAgICAgICBpZiAoZWwuY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkcmVuID0gQXJyYXkuaXNBcnJheShlbC5jaGlsZHJlbikgPyBlbC5jaGlsZHJlbiA6IGVsLmNoaWxkcmVuLnRvQXJyYXkoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5jb25jYXQoZmxhdHRlbihjaGlsZHJlbikpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDYW5jZWxhYmxlRXZlbnRBcmdzIHtcbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyB0aGUgYWJpbGl0eSB0byBjYW5jZWwgdGhlIGV2ZW50LlxuICAgICAqL1xuICAgIGNhbmNlbDogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJQmFzZUV2ZW50QXJncyB7XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgcmVmZXJlbmNlIHRvIHRoZSBvd25lciBjb21wb25lbnQuXG4gICAgICovXG4gICAgb3duZXI/OiBhbnk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2FuY2VsYWJsZUJyb3dzZXJFdmVudEFyZ3MgZXh0ZW5kcyBDYW5jZWxhYmxlRXZlbnRBcmdzIHtcbiAgICAvKiogQnJvd3NlciBldmVudCAqL1xuICAgIGV2ZW50PzogRXZlbnQ7XG59XG5cbmV4cG9ydCBjb25zdCBOQVZJR0FUSU9OX0tFWVMgPSBuZXcgU2V0KFtcbiAgICAnZG93bicsXG4gICAgJ3VwJyxcbiAgICAnbGVmdCcsXG4gICAgJ3JpZ2h0JyxcbiAgICAnYXJyb3dkb3duJyxcbiAgICAnYXJyb3d1cCcsXG4gICAgJ2Fycm93bGVmdCcsXG4gICAgJ2Fycm93cmlnaHQnLFxuICAgICdob21lJyxcbiAgICAnZW5kJyxcbiAgICAnc3BhY2UnLFxuICAgICdzcGFjZWJhcicsXG4gICAgJyAnXG5dKTtcbmV4cG9ydCBjb25zdCBST1dfRVhQQU5EX0tFWVMgPSBuZXcgU2V0KCdyaWdodCBkb3duIGFycm93cmlnaHQgYXJyb3dkb3duJy5zcGxpdCgnICcpKTtcbmV4cG9ydCBjb25zdCBST1dfQ09MTEFQU0VfS0VZUyA9IG5ldyBTZXQoJ2xlZnQgdXAgYXJyb3dsZWZ0IGFycm93dXAnLnNwbGl0KCcgJykpO1xuZXhwb3J0IGNvbnN0IFNVUFBPUlRFRF9LRVlTID0gbmV3IFNldChbLi4uQXJyYXkuZnJvbShOQVZJR0FUSU9OX0tFWVMpLCAndGFiJywgJ2VudGVyJywgJ2YyJywgJ2VzY2FwZScsICdlc2MnXSk7XG4iXX0=