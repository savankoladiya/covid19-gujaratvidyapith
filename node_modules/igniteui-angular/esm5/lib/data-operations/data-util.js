/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { IgxSorting, IgxDataRecordSorting } from './sorting-strategy';
import { IgxGrouping } from './grouping-strategy';
import { PagingError } from './paging-state.interface';
import { FilteringStrategy } from './filtering-strategy';
import { cloneValue, mergeObjects } from '../core/utils';
import { TransactionType } from '../services/transaction/transaction';
import { getHierarchy, isHierarchyMatch } from './operations';
/** @enum {string} */
var DataType = {
    String: 'string',
    Number: 'number',
    Boolean: 'boolean',
    Date: 'date',
};
export { DataType };
/**
 * @hidden
 */
var /**
 * @hidden
 */
DataUtil = /** @class */ (function () {
    function DataUtil() {
    }
    /**
     * @template T
     * @param {?} data
     * @param {?} expressions
     * @param {?=} sorting
     * @return {?}
     */
    DataUtil.sort = /**
     * @template T
     * @param {?} data
     * @param {?} expressions
     * @param {?=} sorting
     * @return {?}
     */
    function (data, expressions, sorting) {
        if (sorting === void 0) { sorting = new IgxSorting(); }
        return sorting.sort(data, expressions);
    };
    /**
     * @param {?} hierarchicalData
     * @param {?} expressions
     * @param {?=} parent
     * @return {?}
     */
    DataUtil.treeGridSort = /**
     * @param {?} hierarchicalData
     * @param {?} expressions
     * @param {?=} parent
     * @return {?}
     */
    function (hierarchicalData, expressions, parent) {
        /** @type {?} */
        var res = [];
        hierarchicalData.forEach(function (hr) {
            /** @type {?} */
            var rec = DataUtil.cloneTreeGridRecord(hr);
            rec.parent = parent;
            if (rec.children) {
                rec.children = DataUtil.treeGridSort(rec.children, expressions, rec);
            }
            res.push(rec);
        });
        res = DataUtil.sort(res, expressions, new IgxDataRecordSorting());
        return res;
    };
    /**
     * @param {?} hierarchicalRecord
     * @return {?}
     */
    DataUtil.cloneTreeGridRecord = /**
     * @param {?} hierarchicalRecord
     * @return {?}
     */
    function (hierarchicalRecord) {
        /** @type {?} */
        var rec = {
            rowID: hierarchicalRecord.rowID,
            data: hierarchicalRecord.data,
            children: hierarchicalRecord.children,
            isFilteredOutParent: hierarchicalRecord.isFilteredOutParent,
            level: hierarchicalRecord.level,
            expanded: hierarchicalRecord.expanded
        };
        return rec;
    };
    /**
     * @template T
     * @param {?} data
     * @param {?} state
     * @param {?=} grid
     * @param {?=} groupsRecords
     * @param {?=} fullResult
     * @return {?}
     */
    DataUtil.group = /**
     * @template T
     * @param {?} data
     * @param {?} state
     * @param {?=} grid
     * @param {?=} groupsRecords
     * @param {?=} fullResult
     * @return {?}
     */
    function (data, state, grid, groupsRecords, fullResult) {
        if (grid === void 0) { grid = null; }
        if (groupsRecords === void 0) { groupsRecords = []; }
        if (fullResult === void 0) { fullResult = { data: [], metadata: [] }; }
        /** @type {?} */
        var grouping = new IgxGrouping();
        groupsRecords.splice(0, groupsRecords.length);
        return grouping.groupBy(data, state, grid, groupsRecords, fullResult);
    };
    /**
     * @template T
     * @param {?} data
     * @param {?} state
     * @return {?}
     */
    DataUtil.page = /**
     * @template T
     * @param {?} data
     * @param {?} state
     * @return {?}
     */
    function (data, state) {
        if (!state) {
            return data;
        }
        /** @type {?} */
        var len = data.length;
        /** @type {?} */
        var index = state.index;
        /** @type {?} */
        var res = [];
        /** @type {?} */
        var recordsPerPage = state.recordsPerPage;
        state.metadata = {
            countPages: 0,
            countRecords: data.length,
            error: PagingError.None
        };
        if (index < 0 || isNaN(index)) {
            state.metadata.error = PagingError.IncorrectPageIndex;
            return res;
        }
        if (recordsPerPage <= 0 || isNaN(recordsPerPage)) {
            state.metadata.error = PagingError.IncorrectRecordsPerPage;
            return res;
        }
        state.metadata.countPages = Math.ceil(len / recordsPerPage);
        if (!len) {
            return data;
        }
        if (index >= state.metadata.countPages) {
            state.metadata.error = PagingError.IncorrectPageIndex;
            return res;
        }
        return data.slice(index * recordsPerPage, (index + 1) * recordsPerPage);
    };
    /**
     * @template T
     * @param {?} data
     * @param {?} state
     * @return {?}
     */
    DataUtil.filter = /**
     * @template T
     * @param {?} data
     * @param {?} state
     * @return {?}
     */
    function (data, state) {
        if (!state.strategy) {
            state.strategy = new FilteringStrategy();
        }
        return state.strategy.filter(data, state.expressionsTree, state.advancedExpressionsTree);
    };
    /**
     * @param {?} state
     * @param {?} length
     * @return {?}
     */
    DataUtil.correctPagingState = /**
     * @param {?} state
     * @param {?} length
     * @return {?}
     */
    function (state, length) {
        /** @type {?} */
        var maxPage = Math.ceil(length / state.recordsPerPage) - 1;
        if (!isNaN(maxPage) && state.index > maxPage) {
            state.index = maxPage;
        }
    };
    /**
     * @param {?} gRow
     * @return {?}
     */
    DataUtil.getHierarchy = /**
     * @param {?} gRow
     * @return {?}
     */
    function (gRow) {
        return getHierarchy(gRow);
    };
    /**
     * @param {?} h1
     * @param {?} h2
     * @return {?}
     */
    DataUtil.isHierarchyMatch = /**
     * @param {?} h1
     * @param {?} h2
     * @return {?}
     */
    function (h1, h2) {
        return isHierarchyMatch(h1, h2);
    };
    /**
     * Merges all changes from provided transactions into provided data collection
     * @param data Collection to merge
     * @param transactions Transactions to merge into data
     * @param primaryKey Primary key of the collection, if any
     * @param deleteRows Should delete rows with DELETE transaction type from data
     * @returns Provided data collections updated with all provided transactions
     */
    /**
     * Merges all changes from provided transactions into provided data collection
     * @template T
     * @param {?} data Collection to merge
     * @param {?} transactions Transactions to merge into data
     * @param {?=} primaryKey Primary key of the collection, if any
     * @param {?=} deleteRows Should delete rows with DELETE transaction type from data
     * @return {?} Provided data collections updated with all provided transactions
     */
    DataUtil.mergeTransactions = /**
     * Merges all changes from provided transactions into provided data collection
     * @template T
     * @param {?} data Collection to merge
     * @param {?} transactions Transactions to merge into data
     * @param {?=} primaryKey Primary key of the collection, if any
     * @param {?=} deleteRows Should delete rows with DELETE transaction type from data
     * @return {?} Provided data collections updated with all provided transactions
     */
    function (data, transactions, primaryKey, deleteRows) {
        if (deleteRows === void 0) { deleteRows = false; }
        data.forEach(function (item, index) {
            /** @type {?} */
            var rowId = primaryKey ? item[primaryKey] : item;
            /** @type {?} */
            var transaction = transactions.find(function (t) { return t.id === rowId; });
            if (transaction && transaction.type === TransactionType.UPDATE) {
                data[index] = transaction.newValue;
            }
        });
        if (deleteRows) {
            transactions
                .filter(function (t) { return t.type === TransactionType.DELETE; })
                .forEach(function (t) {
                /** @type {?} */
                var index = primaryKey ? data.findIndex(function (d) { return d[primaryKey] === t.id; }) : data.findIndex(function (d) { return d === t.id; });
                if (0 <= index && index < data.length) {
                    data.splice(index, 1);
                }
            });
        }
        data.push.apply(data, tslib_1.__spread(transactions
            .filter(function (t) { return t.type === TransactionType.ADD; })
            .map(function (t) { return t.newValue; })));
        return data;
    };
    /**
     * Merges all changes from provided transactions into provided hierarchical data collection
     * @param data Collection to merge
     * @param transactions Transactions to merge into data
     * @param childDataKey Data key of child collections
     * @param primaryKey Primary key of the collection, if any
     * @param deleteRows Should delete rows with DELETE transaction type from data
     * @returns Provided data collections updated with all provided transactions
     */
    /**
     * Merges all changes from provided transactions into provided hierarchical data collection
     * @param {?} data Collection to merge
     * @param {?} transactions Transactions to merge into data
     * @param {?} childDataKey Data key of child collections
     * @param {?=} primaryKey Primary key of the collection, if any
     * @param {?=} deleteRows Should delete rows with DELETE transaction type from data
     * @return {?} Provided data collections updated with all provided transactions
     */
    DataUtil.mergeHierarchicalTransactions = /**
     * Merges all changes from provided transactions into provided hierarchical data collection
     * @param {?} data Collection to merge
     * @param {?} transactions Transactions to merge into data
     * @param {?} childDataKey Data key of child collections
     * @param {?=} primaryKey Primary key of the collection, if any
     * @param {?=} deleteRows Should delete rows with DELETE transaction type from data
     * @return {?} Provided data collections updated with all provided transactions
     */
    function (data, transactions, childDataKey, primaryKey, deleteRows) {
        var e_1, _a;
        if (deleteRows === void 0) { deleteRows = false; }
        var _loop_1 = function (transaction) {
            if (transaction.path) {
                /** @type {?} */
                var parent_1 = this_1.findParentFromPath(data, primaryKey, childDataKey, transaction.path);
                /** @type {?} */
                var collection = parent_1 ? parent_1[childDataKey] : data;
                switch (transaction.type) {
                    case TransactionType.ADD:
                        //  if there is no parent this is ADD row at root level
                        if (parent_1 && !parent_1[childDataKey]) {
                            parent_1[childDataKey] = collection = [];
                        }
                        collection.push(transaction.newValue);
                        break;
                    case TransactionType.UPDATE:
                        /** @type {?} */
                        var updateIndex = collection.findIndex(function (x) { return x[primaryKey] === transaction.id; });
                        if (updateIndex !== -1) {
                            collection[updateIndex] = mergeObjects(cloneValue(collection[updateIndex]), transaction.newValue);
                        }
                        break;
                    case TransactionType.DELETE:
                        if (deleteRows) {
                            /** @type {?} */
                            var deleteIndex = collection.findIndex(function (r) { return r[primaryKey] === transaction.id; });
                            if (deleteIndex !== -1) {
                                collection.splice(deleteIndex, 1);
                            }
                        }
                        break;
                }
            }
            else {
                //  if there is no path this is ADD row in root. Push the newValue to data
                data.push(transaction.newValue);
            }
        };
        var this_1 = this;
        try {
            for (var transactions_1 = tslib_1.__values(transactions), transactions_1_1 = transactions_1.next(); !transactions_1_1.done; transactions_1_1 = transactions_1.next()) {
                var transaction = transactions_1_1.value;
                _loop_1(transaction);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (transactions_1_1 && !transactions_1_1.done && (_a = transactions_1.return)) _a.call(transactions_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return data;
    };
    /**
     * @param {?} dataType
     * @param {?} value
     * @return {?}
     */
    DataUtil.parseValue = /**
     * @param {?} dataType
     * @param {?} value
     * @return {?}
     */
    function (dataType, value) {
        if (dataType === DataType.Number) {
            value = parseFloat(value);
        }
        return value;
    };
    /**
     * @private
     * @param {?} data
     * @param {?} primaryKey
     * @param {?} childDataKey
     * @param {?} path
     * @return {?}
     */
    DataUtil.findParentFromPath = /**
     * @private
     * @param {?} data
     * @param {?} primaryKey
     * @param {?} childDataKey
     * @param {?} path
     * @return {?}
     */
    function (data, primaryKey, childDataKey, path) {
        var e_2, _a;
        /** @type {?} */
        var collection = data;
        /** @type {?} */
        var result;
        var _loop_2 = function (id) {
            result = collection && collection.find(function (x) { return x[primaryKey] === id; });
            if (!result) {
                return "break";
            }
            collection = result[childDataKey];
        };
        try {
            for (var path_1 = tslib_1.__values(path), path_1_1 = path_1.next(); !path_1_1.done; path_1_1 = path_1.next()) {
                var id = path_1_1.value;
                var state_1 = _loop_2(id);
                if (state_1 === "break")
                    break;
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (path_1_1 && !path_1_1.done && (_a = path_1.return)) _a.call(path_1);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return result;
    };
    return DataUtil;
}());
/**
 * @hidden
 */
export { DataUtil };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YS11dGlsLmpzIiwic291cmNlUm9vdCI6Im5nOi8vaWduaXRldWktYW5ndWxhci8iLCJzb3VyY2VzIjpbImxpYi9kYXRhLW9wZXJhdGlvbnMvZGF0YS11dGlsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBRUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxvQkFBb0IsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQ3RFLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUdsRCxPQUFPLEVBQWdCLFdBQVcsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBTXJFLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHNCQUFzQixDQUFDO0FBRXpELE9BQU8sRUFBRSxVQUFVLEVBQUUsWUFBWSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3pELE9BQU8sRUFBZSxlQUFlLEVBQTJCLE1BQU0scUNBQXFDLENBQUM7QUFDNUcsT0FBTyxFQUFFLFlBQVksRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGNBQWMsQ0FBQzs7O0lBTTFELFFBQVMsUUFBUTtJQUNqQixRQUFTLFFBQVE7SUFDakIsU0FBVSxTQUFTO0lBQ25CLE1BQU8sTUFBTTs7Ozs7O0FBTWpCOzs7O0lBQUE7SUE0TUEsQ0FBQzs7Ozs7Ozs7SUEzTWlCLGFBQUk7Ozs7Ozs7SUFBbEIsVUFBc0IsSUFBUyxFQUFFLFdBQWlDLEVBQUUsT0FBc0M7UUFBdEMsd0JBQUEsRUFBQSxjQUEwQixVQUFVLEVBQUU7UUFDdEcsT0FBTyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxXQUFXLENBQUMsQ0FBQztJQUMzQyxDQUFDOzs7Ozs7O0lBRWEscUJBQVk7Ozs7OztJQUExQixVQUEyQixnQkFBbUMsRUFDMUQsV0FBaUMsRUFDakMsTUFBd0I7O1lBQ3BCLEdBQUcsR0FBc0IsRUFBRTtRQUMvQixnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsVUFBQyxFQUFtQjs7Z0JBQ25DLEdBQUcsR0FBb0IsUUFBUSxDQUFDLG1C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QyxNQUFNLEVBQUU7WUFDOUIsS0FBSyxHQUFHLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUM3QjtRQUVELE9BQU8sS0FBSyxDQUFDO0lBQ2pCLENBQUM7Ozs7Ozs7OztJQUVjLDJCQUFrQjs7Ozs7Ozs7SUFBakMsVUFBa0MsSUFBVyxFQUFFLFVBQWUsRUFBRSxZQUFpQixFQUFFLElBQVc7OztZQUN0RixVQUFVLEdBQVUsSUFBSTs7WUFDeEIsTUFBVztnQ0FFSixFQUFFO1lBQ1QsTUFBTSxHQUFHLFVBQVUsSUFBSSxVQUFVLENBQUMsSUFBSSxDQUFDLFVBQUEsQ0FBQyxJQUFJLE9BQUEsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxLQUFLLEVBQUUsRUFBcEIsQ0FBb0IsQ0FBQyxDQUFDO1lBQ2xFLElBQUksQ0FBQyxNQUFNLEVBQUU7O2FBRVo7WUFFRCxVQUFVLEdBQUcsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDOzs7WUFOdEMsS0FBaUIsSUFBQSxTQUFBLGlCQUFBLElBQUksQ0FBQSwwQkFBQTtnQkFBaEIsSUFBTSxFQUFFLGlCQUFBO3NDQUFGLEVBQUU7OzthQU9aOzs7Ozs7Ozs7UUFFRCxPQUFPLE1BQU0sQ0FBQztJQUNsQixDQUFDO0lBQ0wsZUFBQztBQUFELENBQUMsQUE1TUQsSUE0TUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJRmlsdGVyaW5nU3RhdGUgfSBmcm9tICcuL2ZpbHRlcmluZy1zdGF0ZS5pbnRlcmZhY2UnO1xuXG5pbXBvcnQgeyBJZ3hTb3J0aW5nLCBJZ3hEYXRhUmVjb3JkU29ydGluZyB9IGZyb20gJy4vc29ydGluZy1zdHJhdGVneSc7XG5pbXBvcnQgeyBJZ3hHcm91cGluZyB9IGZyb20gJy4vZ3JvdXBpbmctc3RyYXRlZ3knO1xuaW1wb3J0IHsgSUdyb3VwQnlSZXN1bHQgfSBmcm9tICcuL2dyb3VwaW5nLXJlc3VsdC5pbnRlcmZhY2UnO1xuXG5pbXBvcnQgeyBJUGFnaW5nU3RhdGUsIFBhZ2luZ0Vycm9yIH0gZnJvbSAnLi9wYWdpbmctc3RhdGUuaW50ZXJmYWNlJztcblxuaW1wb3J0IHsgSUdyb3VwQnlLZXkgfSBmcm9tICcuL2dyb3VwYnktZXhwYW5kLXN0YXRlLmludGVyZmFjZSc7XG5pbXBvcnQgeyBJR3JvdXBCeVJlY29yZCB9IGZyb20gJy4vZ3JvdXBieS1yZWNvcmQuaW50ZXJmYWNlJztcbmltcG9ydCB7IElHcm91cGluZ1N0YXRlIH0gZnJvbSAnLi9ncm91cGJ5LXN0YXRlLmludGVyZmFjZSc7XG5pbXBvcnQgeyBJU29ydGluZ0V4cHJlc3Npb24gfSBmcm9tICcuL3NvcnRpbmctZXhwcmVzc2lvbi5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgRmlsdGVyaW5nU3RyYXRlZ3kgfSBmcm9tICcuL2ZpbHRlcmluZy1zdHJhdGVneSc7XG5pbXBvcnQgeyBJVHJlZUdyaWRSZWNvcmQgfSBmcm9tICcuLi9ncmlkcy90cmVlLWdyaWQnO1xuaW1wb3J0IHsgY2xvbmVWYWx1ZSwgbWVyZ2VPYmplY3RzIH0gZnJvbSAnLi4vY29yZS91dGlscyc7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbiwgVHJhbnNhY3Rpb25UeXBlLCBIaWVyYXJjaGljYWxUcmFuc2FjdGlvbiB9IGZyb20gJy4uL3NlcnZpY2VzL3RyYW5zYWN0aW9uL3RyYW5zYWN0aW9uJztcbmltcG9ydCB7IGdldEhpZXJhcmNoeSwgaXNIaWVyYXJjaHlNYXRjaCB9IGZyb20gJy4vb3BlcmF0aW9ucyc7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgZW51bSBEYXRhVHlwZSB7XG4gICAgU3RyaW5nID0gJ3N0cmluZycsXG4gICAgTnVtYmVyID0gJ251bWJlcicsXG4gICAgQm9vbGVhbiA9ICdib29sZWFuJyxcbiAgICBEYXRlID0gJ2RhdGUnXG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5leHBvcnQgY2xhc3MgRGF0YVV0aWwge1xuICAgIHB1YmxpYyBzdGF0aWMgc29ydDxUPihkYXRhOiBUW10sIGV4cHJlc3Npb25zOiBJU29ydGluZ0V4cHJlc3Npb25bXSwgc29ydGluZzogSWd4U29ydGluZyA9IG5ldyBJZ3hTb3J0aW5nKCkpOiBUW10ge1xuICAgICAgICByZXR1cm4gc29ydGluZy5zb3J0KGRhdGEsIGV4cHJlc3Npb25zKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIHRyZWVHcmlkU29ydChoaWVyYXJjaGljYWxEYXRhOiBJVHJlZUdyaWRSZWNvcmRbXSxcbiAgICAgICAgZXhwcmVzc2lvbnM6IElTb3J0aW5nRXhwcmVzc2lvbltdLFxuICAgICAgICBwYXJlbnQ/OiBJVHJlZUdyaWRSZWNvcmQpOiBJVHJlZUdyaWRSZWNvcmRbXSB7XG4gICAgICAgIGxldCByZXM6IElUcmVlR3JpZFJlY29yZFtdID0gW107XG4gICAgICAgIGhpZXJhcmNoaWNhbERhdGEuZm9yRWFjaCgoaHI6IElUcmVlR3JpZFJlY29yZCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVjOiBJVHJlZUdyaWRSZWNvcmQgPSBEYXRhVXRpbC5jbG9uZVRyZWVHcmlkUmVjb3JkKGhyKTtcbiAgICAgICAgICAgIHJlYy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgICAgICBpZiAocmVjLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgcmVjLmNoaWxkcmVuID0gRGF0YVV0aWwudHJlZUdyaWRTb3J0KHJlYy5jaGlsZHJlbiwgZXhwcmVzc2lvbnMsIHJlYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXMucHVzaChyZWMpO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXMgPSBEYXRhVXRpbC5zb3J0KHJlcywgZXhwcmVzc2lvbnMsIG5ldyBJZ3hEYXRhUmVjb3JkU29ydGluZygpKTtcblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgY2xvbmVUcmVlR3JpZFJlY29yZChoaWVyYXJjaGljYWxSZWNvcmQ6IElUcmVlR3JpZFJlY29yZCkge1xuICAgICAgICBjb25zdCByZWM6IElUcmVlR3JpZFJlY29yZCA9IHtcbiAgICAgICAgICAgIHJvd0lEOiBoaWVyYXJjaGljYWxSZWNvcmQucm93SUQsXG4gICAgICAgICAgICBkYXRhOiBoaWVyYXJjaGljYWxSZWNvcmQuZGF0YSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiBoaWVyYXJjaGljYWxSZWNvcmQuY2hpbGRyZW4sXG4gICAgICAgICAgICBpc0ZpbHRlcmVkT3V0UGFyZW50OiBoaWVyYXJjaGljYWxSZWNvcmQuaXNGaWx0ZXJlZE91dFBhcmVudCxcbiAgICAgICAgICAgIGxldmVsOiBoaWVyYXJjaGljYWxSZWNvcmQubGV2ZWwsXG4gICAgICAgICAgICBleHBhbmRlZDogaGllcmFyY2hpY2FsUmVjb3JkLmV4cGFuZGVkXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZWM7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBncm91cDxUPihkYXRhOiBUW10sIHN0YXRlOiBJR3JvdXBpbmdTdGF0ZSwgZ3JpZDogYW55ID0gbnVsbCxcbiAgICAgICAgZ3JvdXBzUmVjb3JkczogYW55W10gPSBbXSwgZnVsbFJlc3VsdDogSUdyb3VwQnlSZXN1bHQgPSB7IGRhdGE6IFtdLCBtZXRhZGF0YTogW10gfSk6IElHcm91cEJ5UmVzdWx0IHtcbiAgICAgICAgY29uc3QgZ3JvdXBpbmcgPSBuZXcgSWd4R3JvdXBpbmcoKTtcbiAgICAgICAgZ3JvdXBzUmVjb3Jkcy5zcGxpY2UoMCwgZ3JvdXBzUmVjb3Jkcy5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gZ3JvdXBpbmcuZ3JvdXBCeShkYXRhLCBzdGF0ZSwgZ3JpZCwgZ3JvdXBzUmVjb3JkcywgZnVsbFJlc3VsdCk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBwYWdlPFQ+KGRhdGE6IFRbXSwgc3RhdGU6IElQYWdpbmdTdGF0ZSk6IFRbXSB7XG4gICAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBjb25zdCBpbmRleCA9IHN0YXRlLmluZGV4O1xuICAgICAgICBjb25zdCByZXMgPSBbXTtcbiAgICAgICAgY29uc3QgcmVjb3Jkc1BlclBhZ2UgPSBzdGF0ZS5yZWNvcmRzUGVyUGFnZTtcbiAgICAgICAgc3RhdGUubWV0YWRhdGEgPSB7XG4gICAgICAgICAgICBjb3VudFBhZ2VzOiAwLFxuICAgICAgICAgICAgY291bnRSZWNvcmRzOiBkYXRhLmxlbmd0aCxcbiAgICAgICAgICAgIGVycm9yOiBQYWdpbmdFcnJvci5Ob25lXG4gICAgICAgIH07XG4gICAgICAgIGlmIChpbmRleCA8IDAgfHwgaXNOYU4oaW5kZXgpKSB7XG4gICAgICAgICAgICBzdGF0ZS5tZXRhZGF0YS5lcnJvciA9IFBhZ2luZ0Vycm9yLkluY29ycmVjdFBhZ2VJbmRleDtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlY29yZHNQZXJQYWdlIDw9IDAgfHwgaXNOYU4ocmVjb3Jkc1BlclBhZ2UpKSB7XG4gICAgICAgICAgICBzdGF0ZS5tZXRhZGF0YS5lcnJvciA9IFBhZ2luZ0Vycm9yLkluY29ycmVjdFJlY29yZHNQZXJQYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tZXRhZGF0YS5jb3VudFBhZ2VzID0gTWF0aC5jZWlsKGxlbiAvIHJlY29yZHNQZXJQYWdlKTtcbiAgICAgICAgaWYgKCFsZW4pIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCA+PSBzdGF0ZS5tZXRhZGF0YS5jb3VudFBhZ2VzKSB7XG4gICAgICAgICAgICBzdGF0ZS5tZXRhZGF0YS5lcnJvciA9IFBhZ2luZ0Vycm9yLkluY29ycmVjdFBhZ2VJbmRleDtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGEuc2xpY2UoaW5kZXggKiByZWNvcmRzUGVyUGFnZSwgKGluZGV4ICsgMSkgKiByZWNvcmRzUGVyUGFnZSk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXRpYyBmaWx0ZXI8VD4oZGF0YTogVFtdLCBzdGF0ZTogSUZpbHRlcmluZ1N0YXRlKTogVFtdIHtcbiAgICAgICAgaWYgKCFzdGF0ZS5zdHJhdGVneSkge1xuICAgICAgICAgICAgc3RhdGUuc3RyYXRlZ3kgPSBuZXcgRmlsdGVyaW5nU3RyYXRlZ3koKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGUuc3RyYXRlZ3kuZmlsdGVyKGRhdGEsIHN0YXRlLmV4cHJlc3Npb25zVHJlZSwgc3RhdGUuYWR2YW5jZWRFeHByZXNzaW9uc1RyZWUpO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgY29ycmVjdFBhZ2luZ1N0YXRlKHN0YXRlOiBJUGFnaW5nU3RhdGUsIGxlbmd0aDogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IG1heFBhZ2UgPSBNYXRoLmNlaWwobGVuZ3RoIC8gc3RhdGUucmVjb3Jkc1BlclBhZ2UpIC0gMTtcbiAgICAgICAgaWYgKCFpc05hTihtYXhQYWdlKSAmJiBzdGF0ZS5pbmRleCA+IG1heFBhZ2UpIHtcbiAgICAgICAgICAgIHN0YXRlLmluZGV4ID0gbWF4UGFnZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgZ2V0SGllcmFyY2h5KGdSb3c6IElHcm91cEJ5UmVjb3JkKTogQXJyYXk8SUdyb3VwQnlLZXk+IHtcbiAgICAgICAgcmV0dXJuIGdldEhpZXJhcmNoeShnUm93KTtcbiAgICB9XG5cbiAgICBwdWJsaWMgc3RhdGljIGlzSGllcmFyY2h5TWF0Y2goaDE6IEFycmF5PElHcm91cEJ5S2V5PiwgaDI6IEFycmF5PElHcm91cEJ5S2V5Pik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gaXNIaWVyYXJjaHlNYXRjaChoMSwgaDIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1lcmdlcyBhbGwgY2hhbmdlcyBmcm9tIHByb3ZpZGVkIHRyYW5zYWN0aW9ucyBpbnRvIHByb3ZpZGVkIGRhdGEgY29sbGVjdGlvblxuICAgICAqIEBwYXJhbSBkYXRhIENvbGxlY3Rpb24gdG8gbWVyZ2VcbiAgICAgKiBAcGFyYW0gdHJhbnNhY3Rpb25zIFRyYW5zYWN0aW9ucyB0byBtZXJnZSBpbnRvIGRhdGFcbiAgICAgKiBAcGFyYW0gcHJpbWFyeUtleSBQcmltYXJ5IGtleSBvZiB0aGUgY29sbGVjdGlvbiwgaWYgYW55XG4gICAgICogQHBhcmFtIGRlbGV0ZVJvd3MgU2hvdWxkIGRlbGV0ZSByb3dzIHdpdGggREVMRVRFIHRyYW5zYWN0aW9uIHR5cGUgZnJvbSBkYXRhXG4gICAgICogQHJldHVybnMgUHJvdmlkZWQgZGF0YSBjb2xsZWN0aW9ucyB1cGRhdGVkIHdpdGggYWxsIHByb3ZpZGVkIHRyYW5zYWN0aW9uc1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgbWVyZ2VUcmFuc2FjdGlvbnM8VD4oZGF0YTogVFtdLCB0cmFuc2FjdGlvbnM6IFRyYW5zYWN0aW9uW10sIHByaW1hcnlLZXk/OiBhbnksIGRlbGV0ZVJvd3M6IGJvb2xlYW4gPSBmYWxzZSk6IFRbXSB7XG4gICAgICAgIGRhdGEuZm9yRWFjaCgoaXRlbTogYW55LCBpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByb3dJZCA9IHByaW1hcnlLZXkgPyBpdGVtW3ByaW1hcnlLZXldIDogaXRlbTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb25zLmZpbmQodCA9PiB0LmlkID09PSByb3dJZCk7XG4gICAgICAgICAgICBpZiAodHJhbnNhY3Rpb24gJiYgdHJhbnNhY3Rpb24udHlwZSA9PT0gVHJhbnNhY3Rpb25UeXBlLlVQREFURSkge1xuICAgICAgICAgICAgICAgIGRhdGFbaW5kZXhdID0gdHJhbnNhY3Rpb24ubmV3VmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChkZWxldGVSb3dzKSB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbnNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKHQgPT4gdC50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuREVMRVRFKVxuICAgICAgICAgICAgICAgIC5mb3JFYWNoKHQgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHByaW1hcnlLZXkgPyBkYXRhLmZpbmRJbmRleChkID0+IGRbcHJpbWFyeUtleV0gPT09IHQuaWQpIDogZGF0YS5maW5kSW5kZXgoZCA9PiBkID09PSB0LmlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKDAgPD0gaW5kZXggJiYgaW5kZXggPCBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhLnB1c2goLi4udHJhbnNhY3Rpb25zXG4gICAgICAgICAgICAuZmlsdGVyKHQgPT4gdC50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuQUREKVxuICAgICAgICAgICAgLm1hcCh0ID0+IHQubmV3VmFsdWUpKTtcblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXJnZXMgYWxsIGNoYW5nZXMgZnJvbSBwcm92aWRlZCB0cmFuc2FjdGlvbnMgaW50byBwcm92aWRlZCBoaWVyYXJjaGljYWwgZGF0YSBjb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIGRhdGEgQ29sbGVjdGlvbiB0byBtZXJnZVxuICAgICAqIEBwYXJhbSB0cmFuc2FjdGlvbnMgVHJhbnNhY3Rpb25zIHRvIG1lcmdlIGludG8gZGF0YVxuICAgICAqIEBwYXJhbSBjaGlsZERhdGFLZXkgRGF0YSBrZXkgb2YgY2hpbGQgY29sbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0gcHJpbWFyeUtleSBQcmltYXJ5IGtleSBvZiB0aGUgY29sbGVjdGlvbiwgaWYgYW55XG4gICAgICogQHBhcmFtIGRlbGV0ZVJvd3MgU2hvdWxkIGRlbGV0ZSByb3dzIHdpdGggREVMRVRFIHRyYW5zYWN0aW9uIHR5cGUgZnJvbSBkYXRhXG4gICAgICogQHJldHVybnMgUHJvdmlkZWQgZGF0YSBjb2xsZWN0aW9ucyB1cGRhdGVkIHdpdGggYWxsIHByb3ZpZGVkIHRyYW5zYWN0aW9uc1xuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgbWVyZ2VIaWVyYXJjaGljYWxUcmFuc2FjdGlvbnMoXG4gICAgICAgIGRhdGE6IGFueVtdLFxuICAgICAgICB0cmFuc2FjdGlvbnM6IEhpZXJhcmNoaWNhbFRyYW5zYWN0aW9uW10sXG4gICAgICAgIGNoaWxkRGF0YUtleTogYW55LFxuICAgICAgICBwcmltYXJ5S2V5PzogYW55LFxuICAgICAgICBkZWxldGVSb3dzOiBib29sZWFuID0gZmFsc2UpOiBhbnlbXSB7XG4gICAgICAgIGZvciAoY29uc3QgdHJhbnNhY3Rpb24gb2YgdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgICBpZiAodHJhbnNhY3Rpb24ucGF0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuZmluZFBhcmVudEZyb21QYXRoKGRhdGEsIHByaW1hcnlLZXksIGNoaWxkRGF0YUtleSwgdHJhbnNhY3Rpb24ucGF0aCk7XG4gICAgICAgICAgICAgICAgbGV0IGNvbGxlY3Rpb246IGFueVtdID0gcGFyZW50ID8gcGFyZW50W2NoaWxkRGF0YUtleV0gOiBkYXRhO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodHJhbnNhY3Rpb24udHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFRyYW5zYWN0aW9uVHlwZS5BREQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgaWYgdGhlcmUgaXMgbm8gcGFyZW50IHRoaXMgaXMgQUREIHJvdyBhdCByb290IGxldmVsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50ICYmICFwYXJlbnRbY2hpbGREYXRhS2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFtjaGlsZERhdGFLZXldID0gY29sbGVjdGlvbiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbi5wdXNoKHRyYW5zYWN0aW9uLm5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFRyYW5zYWN0aW9uVHlwZS5VUERBVEU6XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVJbmRleCA9IGNvbGxlY3Rpb24uZmluZEluZGV4KHggPT4geFtwcmltYXJ5S2V5XSA9PT0gdHJhbnNhY3Rpb24uaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVwZGF0ZUluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25bdXBkYXRlSW5kZXhdID0gbWVyZ2VPYmplY3RzKGNsb25lVmFsdWUoY29sbGVjdGlvblt1cGRhdGVJbmRleF0pLCB0cmFuc2FjdGlvbi5uZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBUcmFuc2FjdGlvblR5cGUuREVMRVRFOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRlbGV0ZVJvd3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWxldGVJbmRleCA9IGNvbGxlY3Rpb24uZmluZEluZGV4KHIgPT4gcltwcmltYXJ5S2V5XSA9PT0gdHJhbnNhY3Rpb24uaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWxldGVJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbi5zcGxpY2UoZGVsZXRlSW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gIGlmIHRoZXJlIGlzIG5vIHBhdGggdGhpcyBpcyBBREQgcm93IGluIHJvb3QuIFB1c2ggdGhlIG5ld1ZhbHVlIHRvIGRhdGFcbiAgICAgICAgICAgICAgICBkYXRhLnB1c2godHJhbnNhY3Rpb24ubmV3VmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIHB1YmxpYyBzdGF0aWMgcGFyc2VWYWx1ZShkYXRhVHlwZTogRGF0YVR5cGUsIHZhbHVlOiBhbnkpOiBhbnkge1xuICAgICAgICBpZiAoZGF0YVR5cGUgPT09IERhdGFUeXBlLk51bWJlcikge1xuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN0YXRpYyBmaW5kUGFyZW50RnJvbVBhdGgoZGF0YTogYW55W10sIHByaW1hcnlLZXk6IGFueSwgY2hpbGREYXRhS2V5OiBhbnksIHBhdGg6IGFueVtdKTogYW55IHtcbiAgICAgICAgbGV0IGNvbGxlY3Rpb246IGFueVtdID0gZGF0YTtcbiAgICAgICAgbGV0IHJlc3VsdDogYW55O1xuXG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgcGF0aCkge1xuICAgICAgICAgICAgcmVzdWx0ID0gY29sbGVjdGlvbiAmJiBjb2xsZWN0aW9uLmZpbmQoeCA9PiB4W3ByaW1hcnlLZXldID09PSBpZCk7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb2xsZWN0aW9uID0gcmVzdWx0W2NoaWxkRGF0YUtleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbiJdfQ==