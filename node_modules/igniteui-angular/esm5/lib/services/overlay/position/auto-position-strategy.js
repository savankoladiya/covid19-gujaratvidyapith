/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { VerticalAlignment, HorizontalAlignment } from './../utilities';
import { BaseFitPositionStrategy } from './base-fit-position-strategy';
/**
 * Positions the element as in **Connected** positioning strategy and re-positions the element in
 * the view port (calculating a different start point) in case the element is partially getting out of view
 */
var /**
 * Positions the element as in **Connected** positioning strategy and re-positions the element in
 * the view port (calculating a different start point) in case the element is partially getting out of view
 */
AutoPositionStrategy = /** @class */ (function (_super) {
    tslib_1.__extends(AutoPositionStrategy, _super);
    function AutoPositionStrategy() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    /**
     * \@inheritdoc
     * @protected
     * @param {?} element
     * @param {?} connectedFit
     * @return {?}
     */
    AutoPositionStrategy.prototype.fitInViewport = /**
     * \@inheritdoc
     * @protected
     * @param {?} element
     * @param {?} connectedFit
     * @return {?}
     */
    function (element, connectedFit) {
        /** @type {?} */
        var transformString = [];
        if (!connectedFit.fitHorizontal) {
            if (this.canFlipHorizontal(connectedFit)) {
                this.flipHorizontal();
            }
            else {
                /** @type {?} */
                var horizontalPush = this.horizontalPush(connectedFit);
                transformString.push("translateX(" + horizontalPush + "px)");
            }
        }
        if (!connectedFit.fitVertical) {
            if (this.canFlipVertical(connectedFit)) {
                this.flipVertical();
            }
            else {
                /** @type {?} */
                var verticalPush = this.verticalPush(connectedFit);
                transformString.push("translateY(" + verticalPush + "px)");
            }
        }
        element.style.transform = transformString.join(' ').trim();
    };
    /**
     * Checks if element can be flipped without get off the viewport
     * @param connectedFit connectedFit object containing all necessary parameters
     * @returns true if element can be flipped and stain in viewport
     */
    /**
     * Checks if element can be flipped without get off the viewport
     * @private
     * @param {?} connectedFit connectedFit object containing all necessary parameters
     * @return {?} true if element can be flipped and stain in viewport
     */
    AutoPositionStrategy.prototype.canFlipHorizontal = /**
     * Checks if element can be flipped without get off the viewport
     * @private
     * @param {?} connectedFit connectedFit object containing all necessary parameters
     * @return {?} true if element can be flipped and stain in viewport
     */
    function (connectedFit) {
        //  HorizontalAlignment can be Left = -1; Center = -0.5 or Right = 0.
        //  To virtually flip direction and start point (both are HorizontalAlignment) we can do this:
        //  flippedAlignment = (-1) * (HorizontalAlignment + 1)
        //  this way:
        //  (-1) * (Left + 1) = 0 = Right
        //  (-1) * (Center + 1) = -0.5 = Center
        //  (-1) * (Right + 1) = -1 = Left
        /** @type {?} */
        var flippedStartPoint = (-1) * (this.settings.horizontalStartPoint + 1);
        /** @type {?} */
        var flippedDirection = (-1) * (this.settings.horizontalDirection + 1);
        /** @type {?} */
        var leftBorder = this.calculateLeft(connectedFit.targetRect, connectedFit.contentElementRect, flippedStartPoint, flippedDirection);
        /** @type {?} */
        var rightBorder = leftBorder + connectedFit.contentElementRect.width;
        return 0 < leftBorder && rightBorder < connectedFit.viewPortRect.width;
    };
    /**
     * Checks if element can be flipped without get off the viewport
     * @param connectedFit connectedFit object containing all necessary parameters
     * @returns true if element can be flipped and stain in viewport
     */
    /**
     * Checks if element can be flipped without get off the viewport
     * @private
     * @param {?} connectedFit connectedFit object containing all necessary parameters
     * @return {?} true if element can be flipped and stain in viewport
     */
    AutoPositionStrategy.prototype.canFlipVertical = /**
     * Checks if element can be flipped without get off the viewport
     * @private
     * @param {?} connectedFit connectedFit object containing all necessary parameters
     * @return {?} true if element can be flipped and stain in viewport
     */
    function (connectedFit) {
        /** @type {?} */
        var flippedStartPoint = (-1) * (this.settings.verticalStartPoint + 1);
        /** @type {?} */
        var flippedDirection = (-1) * (this.settings.verticalDirection + 1);
        /** @type {?} */
        var topBorder = this.calculateTop(connectedFit.targetRect, connectedFit.contentElementRect, flippedStartPoint, flippedDirection);
        /** @type {?} */
        var bottomBorder = topBorder + connectedFit.contentElementRect.height;
        return 0 < topBorder && bottomBorder < connectedFit.viewPortRect.height;
    };
    /**
     * Flips direction and start point of the position settings
     */
    /**
     * Flips direction and start point of the position settings
     * @private
     * @return {?}
     */
    AutoPositionStrategy.prototype.flipHorizontal = /**
     * Flips direction and start point of the position settings
     * @private
     * @return {?}
     */
    function () {
        switch (this.settings.horizontalDirection) {
            case HorizontalAlignment.Left:
                this.settings.horizontalDirection = HorizontalAlignment.Right;
                break;
            case HorizontalAlignment.Right:
                this.settings.horizontalDirection = HorizontalAlignment.Left;
                break;
        }
        switch (this.settings.horizontalStartPoint) {
            case HorizontalAlignment.Left:
                this.settings.horizontalStartPoint = HorizontalAlignment.Right;
                break;
            case HorizontalAlignment.Right:
                this.settings.horizontalStartPoint = HorizontalAlignment.Left;
                break;
        }
    };
    /**
     * Flips direction and start point of the position settings
     */
    /**
     * Flips direction and start point of the position settings
     * @private
     * @return {?}
     */
    AutoPositionStrategy.prototype.flipVertical = /**
     * Flips direction and start point of the position settings
     * @private
     * @return {?}
     */
    function () {
        switch (this.settings.verticalDirection) {
            case VerticalAlignment.Top:
                this.settings.verticalDirection = VerticalAlignment.Bottom;
                break;
            case VerticalAlignment.Bottom:
                this.settings.verticalDirection = VerticalAlignment.Top;
                break;
        }
        switch (this.settings.verticalStartPoint) {
            case VerticalAlignment.Top:
                this.settings.verticalStartPoint = VerticalAlignment.Bottom;
                break;
            case VerticalAlignment.Bottom:
                this.settings.verticalStartPoint = VerticalAlignment.Top;
                break;
        }
    };
    /**
     * Calculates necessary horizontal push according to provided connectedFit
     * @param connectedFit connectedFit object containing all necessary parameters
     * @returns amount of necessary translation which will push the element into viewport
     */
    /**
     * Calculates necessary horizontal push according to provided connectedFit
     * @private
     * @param {?} connectedFit connectedFit object containing all necessary parameters
     * @return {?} amount of necessary translation which will push the element into viewport
     */
    AutoPositionStrategy.prototype.horizontalPush = /**
     * Calculates necessary horizontal push according to provided connectedFit
     * @private
     * @param {?} connectedFit connectedFit object containing all necessary parameters
     * @return {?} amount of necessary translation which will push the element into viewport
     */
    function (connectedFit) {
        /** @type {?} */
        var leftExtend = connectedFit.left;
        /** @type {?} */
        var rightExtend = connectedFit.right - connectedFit.viewPortRect.right;
        //  if leftExtend < 0 overlay goes beyond left end of the screen. We should push it back with exactly
        //  as much as it is beyond the screen.
        //  if rightExtend > 0 overlay goes beyond right end of the screen. We should push it back with the
        //  extend but with amount not bigger than what left between left border of screen and left border of
        //  overlay, e.g. leftExtend
        if (leftExtend < 0) {
            return Math.abs(leftExtend);
        }
        else if (rightExtend > 0) {
            return -Math.min(rightExtend, leftExtend);
        }
        else {
            return 0;
        }
    };
    /**
     * Calculates necessary vertical push according to provided connectedFit
     * @param connectedFit connectedFit object containing all necessary parameters
     * @returns amount of necessary translation which will push the element into viewport
     */
    /**
     * Calculates necessary vertical push according to provided connectedFit
     * @private
     * @param {?} connectedFit connectedFit object containing all necessary parameters
     * @return {?} amount of necessary translation which will push the element into viewport
     */
    AutoPositionStrategy.prototype.verticalPush = /**
     * Calculates necessary vertical push according to provided connectedFit
     * @private
     * @param {?} connectedFit connectedFit object containing all necessary parameters
     * @return {?} amount of necessary translation which will push the element into viewport
     */
    function (connectedFit) {
        /** @type {?} */
        var topExtend = connectedFit.top;
        /** @type {?} */
        var bottomExtend = connectedFit.bottom - connectedFit.viewPortRect.bottom;
        if (topExtend < 0) {
            return Math.abs(topExtend);
        }
        else if (bottomExtend > 0) {
            return -Math.min(bottomExtend, topExtend);
        }
        else {
            return 0;
        }
    };
    return AutoPositionStrategy;
}(BaseFitPositionStrategy));
/**
 * Positions the element as in **Connected** positioning strategy and re-positions the element in
 * the view port (calculating a different start point) in case the element is partially getting out of view
 */
export { AutoPositionStrategy };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0by1wb3NpdGlvbi1zdHJhdGVneS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvc2VydmljZXMvb3ZlcmxheS9wb3NpdGlvbi9hdXRvLXBvc2l0aW9uLXN0cmF0ZWd5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFFLGlCQUFpQixFQUFFLG1CQUFtQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDeEUsT0FBTyxFQUFFLHVCQUF1QixFQUFnQixNQUFNLDhCQUE4QixDQUFDOzs7OztBQU1yRjs7Ozs7SUFBMEMsZ0RBQXVCO0lBQWpFOztJQWlKQSxDQUFDO0lBL0lHLGtCQUFrQjs7Ozs7Ozs7SUFDUiw0Q0FBYTs7Ozs7OztJQUF2QixVQUF3QixPQUFvQixFQUFFLFlBQTBCOztZQUM5RCxlQUFlLEdBQWEsRUFBRTtRQUNwQyxJQUFJLENBQUMsWUFBWSxDQUFDLGFBQWEsRUFBRTtZQUM3QixJQUFJLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxZQUFZLENBQUMsRUFBRTtnQkFDdEMsSUFBSSxDQUFDLGNBQWMsRUFBRSxDQUFDO2FBQ3pCO2lCQUFNOztvQkFDRyxjQUFjLEdBQUcsSUFBSSxDQUFDLGNBQWMsQ0FBQyxZQUFZLENBQUM7Z0JBQ3hELGVBQWUsQ0FBQyxJQUFJLENBQUMsZ0JBQWMsY0FBYyxRQUFLLENBQUMsQ0FBQzthQUMzRDtTQUNKO1FBRUQsSUFBSSxDQUFDLFlBQVksQ0FBQyxXQUFXLEVBQUU7WUFDM0IsSUFBSSxJQUFJLENBQUMsZUFBZSxDQUFDLFlBQVksQ0FBQyxFQUFFO2dCQUNwQyxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7YUFDdkI7aUJBQU07O29CQUNHLFlBQVksR0FBRyxJQUFJLENBQUMsWUFBWSxDQUFDLFlBQVksQ0FBQztnQkFDcEQsZUFBZSxDQUFDLElBQUksQ0FBQyxnQkFBYyxZQUFZLFFBQUssQ0FBQyxDQUFDO2FBQ3pEO1NBQ0o7UUFFRCxP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QVksQ0FBQyxNQUFNO1FBQzNFLElBQUksU0FBUyxHQUFHLENBQUMsRUFBRTtZQUNmLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxTQUFTLENBQUMsQ0FBQztTQUM5QjthQUFNLElBQUksWUFBWSxHQUFHLENBQUMsRUFBRTtZQUN6QixPQUFPLENBQUUsSUFBSSxDQUFDLEdBQUcsQ0FBQyxZQUFZLEVBQUUsU0FBUyxDQUFDLENBQUM7U0FDOUM7YUFBTTtZQUNILE9BQU8sQ0FBQyxDQUFDO1NBQ1o7SUFDTCxDQUFDO0lBQ0wsMkJBQUM7QUFBRCxDQUFDLEFBakpELENBQTBDLHVCQUF1QixHQWlKaEUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBWZXJ0aWNhbEFsaWdubWVudCwgSG9yaXpvbnRhbEFsaWdubWVudCB9IGZyb20gJy4vLi4vdXRpbGl0aWVzJztcbmltcG9ydCB7IEJhc2VGaXRQb3NpdGlvblN0cmF0ZWd5LCBDb25uZWN0ZWRGaXQgfSBmcm9tICcuL2Jhc2UtZml0LXBvc2l0aW9uLXN0cmF0ZWd5JztcblxuLyoqXG4gKiBQb3NpdGlvbnMgdGhlIGVsZW1lbnQgYXMgaW4gKipDb25uZWN0ZWQqKiBwb3NpdGlvbmluZyBzdHJhdGVneSBhbmQgcmUtcG9zaXRpb25zIHRoZSBlbGVtZW50IGluXG4gKiB0aGUgdmlldyBwb3J0IChjYWxjdWxhdGluZyBhIGRpZmZlcmVudCBzdGFydCBwb2ludCkgaW4gY2FzZSB0aGUgZWxlbWVudCBpcyBwYXJ0aWFsbHkgZ2V0dGluZyBvdXQgb2Ygdmlld1xuICovXG5leHBvcnQgY2xhc3MgQXV0b1Bvc2l0aW9uU3RyYXRlZ3kgZXh0ZW5kcyBCYXNlRml0UG9zaXRpb25TdHJhdGVneSB7XG5cbiAgICAvKiogQGluaGVyaXRkb2MgKi9cbiAgICBwcm90ZWN0ZWQgZml0SW5WaWV3cG9ydChlbGVtZW50OiBIVE1MRWxlbWVudCwgY29ubmVjdGVkRml0OiBDb25uZWN0ZWRGaXQpIHtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtU3RyaW5nOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBpZiAoIWNvbm5lY3RlZEZpdC5maXRIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jYW5GbGlwSG9yaXpvbnRhbChjb25uZWN0ZWRGaXQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mbGlwSG9yaXpvbnRhbCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBob3Jpem9udGFsUHVzaCA9IHRoaXMuaG9yaXpvbnRhbFB1c2goY29ubmVjdGVkRml0KTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1TdHJpbmcucHVzaChgdHJhbnNsYXRlWCgke2hvcml6b250YWxQdXNofXB4KWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFjb25uZWN0ZWRGaXQuZml0VmVydGljYWwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbkZsaXBWZXJ0aWNhbChjb25uZWN0ZWRGaXQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mbGlwVmVydGljYWwoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmVydGljYWxQdXNoID0gdGhpcy52ZXJ0aWNhbFB1c2goY29ubmVjdGVkRml0KTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1TdHJpbmcucHVzaChgdHJhbnNsYXRlWSgke3ZlcnRpY2FsUHVzaH1weClgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtU3RyaW5nLmpvaW4oJyAnKS50cmltKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGVsZW1lbnQgY2FuIGJlIGZsaXBwZWQgd2l0aG91dCBnZXQgb2ZmIHRoZSB2aWV3cG9ydFxuICAgICAqIEBwYXJhbSBjb25uZWN0ZWRGaXQgY29ubmVjdGVkRml0IG9iamVjdCBjb250YWluaW5nIGFsbCBuZWNlc3NhcnkgcGFyYW1ldGVyc1xuICAgICAqIEByZXR1cm5zIHRydWUgaWYgZWxlbWVudCBjYW4gYmUgZmxpcHBlZCBhbmQgc3RhaW4gaW4gdmlld3BvcnRcbiAgICAgKi9cbiAgICBwcml2YXRlIGNhbkZsaXBIb3Jpem9udGFsKGNvbm5lY3RlZEZpdDogQ29ubmVjdGVkRml0KTogYm9vbGVhbiB7XG4gICAgICAgIC8vICBIb3Jpem9udGFsQWxpZ25tZW50IGNhbiBiZSBMZWZ0ID0gLTE7IENlbnRlciA9IC0wLjUgb3IgUmlnaHQgPSAwLlxuICAgICAgICAvLyAgVG8gdmlydHVhbGx5IGZsaXAgZGlyZWN0aW9uIGFuZCBzdGFydCBwb2ludCAoYm90aCBhcmUgSG9yaXpvbnRhbEFsaWdubWVudCkgd2UgY2FuIGRvIHRoaXM6XG4gICAgICAgIC8vICBmbGlwcGVkQWxpZ25tZW50ID0gKC0xKSAqIChIb3Jpem9udGFsQWxpZ25tZW50ICsgMSlcbiAgICAgICAgLy8gIHRoaXMgd2F5OlxuICAgICAgICAvLyAgKC0xKSAqIChMZWZ0ICsgMSkgPSAwID0gUmlnaHRcbiAgICAgICAgLy8gICgtMSkgKiAoQ2VudGVyICsgMSkgPSAtMC41ID0gQ2VudGVyXG4gICAgICAgIC8vICAoLTEpICogKFJpZ2h0ICsgMSkgPSAtMSA9IExlZnRcbiAgICAgICAgY29uc3QgZmxpcHBlZFN0YXJ0UG9pbnQgPSAoLTEpICogKHRoaXMuc2V0dGluZ3MuaG9yaXpvbnRhbFN0YXJ0UG9pbnQgKyAxKTtcbiAgICAgICAgY29uc3QgZmxpcHBlZERpcmVjdGlvbiA9ICgtMSkgKiAodGhpcy5zZXR0aW5ncy5ob3Jpem9udGFsRGlyZWN0aW9uICsgMSk7XG5cbiAgICAgICAgY29uc3QgbGVmdEJvcmRlciA9IHRoaXMuY2FsY3VsYXRlTGVmdChcbiAgICAgICAgICAgIGNvbm5lY3RlZEZpdC50YXJnZXRSZWN0LCBjb25uZWN0ZWRGaXQuY29udGVudEVsZW1lbnRSZWN0LCBmbGlwcGVkU3RhcnRQb2ludCwgZmxpcHBlZERpcmVjdGlvbik7XG4gICAgICAgIGNvbnN0IHJpZ2h0Qm9yZGVyID0gbGVmdEJvcmRlciArIGNvbm5lY3RlZEZpdC5jb250ZW50RWxlbWVudFJlY3Qud2lkdGg7XG4gICAgICAgIHJldHVybiAwIDwgbGVmdEJvcmRlciAmJiByaWdodEJvcmRlciA8IGNvbm5lY3RlZEZpdC52aWV3UG9ydFJlY3Qud2lkdGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGVsZW1lbnQgY2FuIGJlIGZsaXBwZWQgd2l0aG91dCBnZXQgb2ZmIHRoZSB2aWV3cG9ydFxuICAgICAqIEBwYXJhbSBjb25uZWN0ZWRGaXQgY29ubmVjdGVkRml0IG9iamVjdCBjb250YWluaW5nIGFsbCBuZWNlc3NhcnkgcGFyYW1ldGVyc1xuICAgICAqIEByZXR1cm5zIHRydWUgaWYgZWxlbWVudCBjYW4gYmUgZmxpcHBlZCBhbmQgc3RhaW4gaW4gdmlld3BvcnRcbiAgICAgKi9cbiAgICBwcml2YXRlIGNhbkZsaXBWZXJ0aWNhbChjb25uZWN0ZWRGaXQ6IENvbm5lY3RlZEZpdCk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBmbGlwcGVkU3RhcnRQb2ludCA9ICgtMSkgKiAodGhpcy5zZXR0aW5ncy52ZXJ0aWNhbFN0YXJ0UG9pbnQgKyAxKTtcbiAgICAgICAgY29uc3QgZmxpcHBlZERpcmVjdGlvbiA9ICgtMSkgKiAodGhpcy5zZXR0aW5ncy52ZXJ0aWNhbERpcmVjdGlvbiArIDEpO1xuXG4gICAgICAgIGNvbnN0IHRvcEJvcmRlciA9IHRoaXMuY2FsY3VsYXRlVG9wKFxuICAgICAgICAgICAgY29ubmVjdGVkRml0LnRhcmdldFJlY3QsIGNvbm5lY3RlZEZpdC5jb250ZW50RWxlbWVudFJlY3QsIGZsaXBwZWRTdGFydFBvaW50LCBmbGlwcGVkRGlyZWN0aW9uKTtcbiAgICAgICAgY29uc3QgYm90dG9tQm9yZGVyID0gdG9wQm9yZGVyICsgY29ubmVjdGVkRml0LmNvbnRlbnRFbGVtZW50UmVjdC5oZWlnaHQ7XG4gICAgICAgIHJldHVybiAwIDwgdG9wQm9yZGVyICYmIGJvdHRvbUJvcmRlciA8IGNvbm5lY3RlZEZpdC52aWV3UG9ydFJlY3QuaGVpZ2h0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZsaXBzIGRpcmVjdGlvbiBhbmQgc3RhcnQgcG9pbnQgb2YgdGhlIHBvc2l0aW9uIHNldHRpbmdzXG4gICAgICovXG4gICAgcHJpdmF0ZSBmbGlwSG9yaXpvbnRhbCgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnNldHRpbmdzLmhvcml6b250YWxEaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgSG9yaXpvbnRhbEFsaWdubWVudC5MZWZ0OlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MuaG9yaXpvbnRhbERpcmVjdGlvbiA9IEhvcml6b250YWxBbGlnbm1lbnQuUmlnaHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEhvcml6b250YWxBbGlnbm1lbnQuUmlnaHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5ob3Jpem9udGFsRGlyZWN0aW9uID0gSG9yaXpvbnRhbEFsaWdubWVudC5MZWZ0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodGhpcy5zZXR0aW5ncy5ob3Jpem9udGFsU3RhcnRQb2ludCkge1xuICAgICAgICAgICAgY2FzZSBIb3Jpem9udGFsQWxpZ25tZW50LkxlZnQ6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5ob3Jpem9udGFsU3RhcnRQb2ludCA9IEhvcml6b250YWxBbGlnbm1lbnQuUmlnaHQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIEhvcml6b250YWxBbGlnbm1lbnQuUmlnaHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5ob3Jpem9udGFsU3RhcnRQb2ludCA9IEhvcml6b250YWxBbGlnbm1lbnQuTGVmdDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZsaXBzIGRpcmVjdGlvbiBhbmQgc3RhcnQgcG9pbnQgb2YgdGhlIHBvc2l0aW9uIHNldHRpbmdzXG4gICAgICovXG4gICAgcHJpdmF0ZSBmbGlwVmVydGljYWwoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5zZXR0aW5ncy52ZXJ0aWNhbERpcmVjdGlvbikge1xuICAgICAgICAgICAgY2FzZSBWZXJ0aWNhbEFsaWdubWVudC5Ub3A6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy52ZXJ0aWNhbERpcmVjdGlvbiA9IFZlcnRpY2FsQWxpZ25tZW50LkJvdHRvbTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgVmVydGljYWxBbGlnbm1lbnQuQm90dG9tOlxuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MudmVydGljYWxEaXJlY3Rpb24gPSBWZXJ0aWNhbEFsaWdubWVudC5Ub3A7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0aGlzLnNldHRpbmdzLnZlcnRpY2FsU3RhcnRQb2ludCkge1xuICAgICAgICAgICAgY2FzZSBWZXJ0aWNhbEFsaWdubWVudC5Ub3A6XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy52ZXJ0aWNhbFN0YXJ0UG9pbnQgPSBWZXJ0aWNhbEFsaWdubWVudC5Cb3R0b207XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFZlcnRpY2FsQWxpZ25tZW50LkJvdHRvbTpcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzLnZlcnRpY2FsU3RhcnRQb2ludCA9IFZlcnRpY2FsQWxpZ25tZW50LlRvcDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgbmVjZXNzYXJ5IGhvcml6b250YWwgcHVzaCBhY2NvcmRpbmcgdG8gcHJvdmlkZWQgY29ubmVjdGVkRml0XG4gICAgICogQHBhcmFtIGNvbm5lY3RlZEZpdCBjb25uZWN0ZWRGaXQgb2JqZWN0IGNvbnRhaW5pbmcgYWxsIG5lY2Vzc2FyeSBwYXJhbWV0ZXJzXG4gICAgICogQHJldHVybnMgYW1vdW50IG9mIG5lY2Vzc2FyeSB0cmFuc2xhdGlvbiB3aGljaCB3aWxsIHB1c2ggdGhlIGVsZW1lbnQgaW50byB2aWV3cG9ydFxuICAgICAqL1xuICAgIHByaXZhdGUgaG9yaXpvbnRhbFB1c2goY29ubmVjdGVkRml0OiBDb25uZWN0ZWRGaXQpOiBudW1iZXIge1xuICAgICAgICBjb25zdCBsZWZ0RXh0ZW5kID0gY29ubmVjdGVkRml0LmxlZnQ7XG4gICAgICAgIGNvbnN0IHJpZ2h0RXh0ZW5kID0gY29ubmVjdGVkRml0LnJpZ2h0IC0gY29ubmVjdGVkRml0LnZpZXdQb3J0UmVjdC5yaWdodDtcbiAgICAgICAgLy8gIGlmIGxlZnRFeHRlbmQgPCAwIG92ZXJsYXkgZ29lcyBiZXlvbmQgbGVmdCBlbmQgb2YgdGhlIHNjcmVlbi4gV2Ugc2hvdWxkIHB1c2ggaXQgYmFjayB3aXRoIGV4YWN0bHlcbiAgICAgICAgLy8gIGFzIG11Y2ggYXMgaXQgaXMgYmV5b25kIHRoZSBzY3JlZW4uXG4gICAgICAgIC8vICBpZiByaWdodEV4dGVuZCA+IDAgb3ZlcmxheSBnb2VzIGJleW9uZCByaWdodCBlbmQgb2YgdGhlIHNjcmVlbi4gV2Ugc2hvdWxkIHB1c2ggaXQgYmFjayB3aXRoIHRoZVxuICAgICAgICAvLyAgZXh0ZW5kIGJ1dCB3aXRoIGFtb3VudCBub3QgYmlnZ2VyIHRoYW4gd2hhdCBsZWZ0IGJldHdlZW4gbGVmdCBib3JkZXIgb2Ygc2NyZWVuIGFuZCBsZWZ0IGJvcmRlciBvZlxuICAgICAgICAvLyAgb3ZlcmxheSwgZS5nLiBsZWZ0RXh0ZW5kXG4gICAgICAgIGlmIChsZWZ0RXh0ZW5kIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguYWJzKGxlZnRFeHRlbmQpO1xuICAgICAgICB9IGVsc2UgaWYgKHJpZ2h0RXh0ZW5kID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIC0gTWF0aC5taW4ocmlnaHRFeHRlbmQsIGxlZnRFeHRlbmQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGVzIG5lY2Vzc2FyeSB2ZXJ0aWNhbCBwdXNoIGFjY29yZGluZyB0byBwcm92aWRlZCBjb25uZWN0ZWRGaXRcbiAgICAgKiBAcGFyYW0gY29ubmVjdGVkRml0IGNvbm5lY3RlZEZpdCBvYmplY3QgY29udGFpbmluZyBhbGwgbmVjZXNzYXJ5IHBhcmFtZXRlcnNcbiAgICAgKiBAcmV0dXJucyBhbW91bnQgb2YgbmVjZXNzYXJ5IHRyYW5zbGF0aW9uIHdoaWNoIHdpbGwgcHVzaCB0aGUgZWxlbWVudCBpbnRvIHZpZXdwb3J0XG4gICAgICovXG4gICAgcHJpdmF0ZSB2ZXJ0aWNhbFB1c2goY29ubmVjdGVkRml0OiBDb25uZWN0ZWRGaXQpOiBudW1iZXIge1xuICAgICAgICBjb25zdCB0b3BFeHRlbmQgPSBjb25uZWN0ZWRGaXQudG9wO1xuICAgICAgICBjb25zdCBib3R0b21FeHRlbmQgPSBjb25uZWN0ZWRGaXQuYm90dG9tIC0gY29ubmVjdGVkRml0LnZpZXdQb3J0UmVjdC5ib3R0b207XG4gICAgICAgIGlmICh0b3BFeHRlbmQgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5hYnModG9wRXh0ZW5kKTtcbiAgICAgICAgfSBlbHNlIGlmIChib3R0b21FeHRlbmQgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gLSBNYXRoLm1pbihib3R0b21FeHRlbmQsIHRvcEV4dGVuZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdfQ==