/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { CommonModule } from '@angular/common';
import { Component, ContentChildren, ElementRef, EventEmitter, forwardRef, HostBinding, Input, NgModule, Output, QueryList, ViewChild, ViewChildren, NgZone } from '@angular/core';
import { IgxBadgeModule } from '../badge/badge.component';
import { IgxRippleModule } from '../directives/ripple/ripple.directive';
import { IgxIconModule } from '../icon/index';
import { IgxTabItemComponent } from './tab-item.component';
import { IgxTabsGroupComponent } from './tabs-group.component';
import { IgxLeftButtonStyleDirective, IgxRightButtonStyleDirective, IgxTabItemTemplateDirective } from './tabs.directives';
import { IgxTabsBase } from './tabs.common';
import ResizeObserver from 'resize-observer-polyfill';
import { PlatformUtil } from '../core/utils';
/** @enum {string} */
var TabsType = {
    FIXED: 'fixed',
    CONTENTFIT: 'contentfit',
};
export { TabsType };
var IgxTabsComponent = /** @class */ (function () {
    function IgxTabsComponent(_element, _ngZone, platformUtil) {
        this._element = _element;
        this._ngZone = _ngZone;
        this.platformUtil = platformUtil;
        /**
         * @hidden
         */
        this.selectedIndexChange = new EventEmitter();
        /**
         * Defines the tab header sizing mode. You can choose between `contentfit` or `fixed`.
         * By default the header sizing mode is `contentfit`.
         * ```html
         * <igx-tabs tabsType="fixed">
         *     <igx-tabs-group label="HOME">Home</igx-tabs-group>
         * </igx-tabs>
         * ```
         */
        this.tabsType = 'contentfit';
        /**
         * @hidden
         */
        this.class = '';
        /**
         * Emitted when a tab item is deselected.
         * ```html
         * <igx-tabs (onTabItemDeselected)="itemDeselected($event)">
         *      <igx-tabs-group label="Tab 1">This is Tab 1 content.</igx-tabs-group>
         *      <igx-tabs-group label="Tab 2">This is Tab 2 content.</igx-tabs-group>
         * </igx-tabs>
         * ```
         * ```typescript
         * itemDeselected(e){
         *      const tabGroup = e.group;
         *      const tabItem = e.tab;
         * }
         * ```
         */
        this.onTabItemDeselected = new EventEmitter();
        /**
         * Emitted when a tab item is selected.
         * ```html
         * <igx-tabs (onTabItemSelected)="itemSelected($event)">
         *      <igx-tabs-group label="Tab 1">This is Tab 1 content.</igx-tabs-group>
         *      <igx-tabs-group label="Tab 2">This is Tab 2 content.</igx-tabs-group>
         * </igx-tabs>
         * ```
         * ```typescript
         * itemSelected(e){
         *      const tabGroup = e.group;
         *      const tabItem = e.tab;
         * }
         * ```
         */
        this.onTabItemSelected = new EventEmitter();
        /**
         * @hidden
         */
        this.offset = 0;
        this._selectedIndex = -1;
    }
    Object.defineProperty(IgxTabsComponent.prototype, "selectedIndex", {
        /**
        * An @Input property that sets the value of the `selectedIndex`.
        * Default value is 0.
        * ```html
        * <igx-tabs selectedIndex="1">
        * ```
        *
        * Two-way data binding.
        * ```html
        * <igx-tabs [(selectedIndex)]="model.selectedIndex">
        * ```
        */
        get: /**
         * An \@Input property that sets the value of the `selectedIndex`.
         * Default value is 0.
         * ```html
         * <igx-tabs selectedIndex="1">
         * ```
         *
         * Two-way data binding.
         * ```html
         * <igx-tabs [(selectedIndex)]="model.selectedIndex">
         * ```
         * @return {?}
         */
        function () {
            return this._selectedIndex;
        },
        set: /**
         * @param {?} index
         * @return {?}
         */
        function (index) {
            /** @type {?} */
            var newIndex = typeof index !== 'number' ? parseInt(index, 10) : index;
            if (this._selectedIndex !== newIndex) {
                if (this.tabs && this.tabs.length > 0) {
                    /** @type {?} */
                    var newTab = this.tabs.toArray()[newIndex];
                    if (newTab) {
                        this.performSelectionChange(newTab);
                    }
                }
                else {
                    this._selectedIndex = newIndex;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTabsComponent.prototype, "tabs", {
        /**
         * Provides an observable collection of all `IgxTabItemComponent`s.
         * First try to get them as content children if not available get them as view children.
         * ```typescript
         * const tabItems = this.myTabComponent.tabs;
         * ```
         */
        get: /**
         * Provides an observable collection of all `IgxTabItemComponent`s.
         * First try to get them as content children if not available get them as view children.
         * ```typescript
         * const tabItems = this.myTabComponent.tabs;
         * ```
         * @return {?}
         */
        function () {
            if (this.hasContentTabs) {
                return this.contentTabs;
            }
            return this.viewTabs;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTabsComponent.prototype, "hasContentTabs", {
        /**
         *@hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return (this.contentTabs && this.contentTabs.length > 0);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxTabsComponent.prototype, "cssClass", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            /** @type {?} */
            var defaultStyle = "igx-tabs";
            /** @type {?} */
            var fixedStyle = "igx-tabs--fixed";
            /** @type {?} */
            var iconStyle = "igx-tabs--icons";
            /** @type {?} */
            var iconLabelFoundInGroups = this.groups.find(function (group) { return group.icon != null && group.label != null; });
            /** @type {?} */
            var iconLabelFoundInTabs = this.contentTabs.find(function (tab) { return tab.icon != null && tab.label != null; });
            /** @type {?} */
            var css;
            switch (TabsType[this.tabsType.toUpperCase()]) {
                case TabsType.FIXED: {
                    css = fixedStyle;
                    break;
                }
                default: {
                    css = defaultStyle;
                    break;
                }
            }
            // Layout fix for items with icons
            if (iconLabelFoundInGroups !== undefined || iconLabelFoundInTabs !== undefined) {
                css = css + " " + iconStyle;
            }
            return css + " " + this.class;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxTabsComponent.prototype.scrollLeft = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.scroll(false);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxTabsComponent.prototype.scrollRight = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.scroll(true);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} element
     * @param {?} scrollRight
     * @return {?}
     */
    IgxTabsComponent.prototype.scrollElement = /**
     * @hidden
     * @param {?} element
     * @param {?} scrollRight
     * @return {?}
     */
    function (element, scrollRight) {
        /** @type {?} */
        var viewPortWidth = this.viewPort.nativeElement.offsetWidth;
        this.offset = (scrollRight) ? element.offsetWidth + element.offsetLeft - viewPortWidth : element.offsetLeft;
        this.itemsContainer.nativeElement.style.transform = "translate(" + -this.offset + "px)";
    };
    Object.defineProperty(IgxTabsComponent.prototype, "selectedTabItem", {
        /**
         * Gets the selected `IgxTabItemComponent`.
         * ```
         * const selectedItem = this.myTabComponent.selectedTabItem;
         * ```
         */
        get: /**
         * Gets the selected `IgxTabItemComponent`.
         * ```
         * const selectedItem = this.myTabComponent.selectedTabItem;
         * ```
         * @return {?}
         */
        function () {
            if (this.tabs && this.selectedIndex !== undefined) {
                return this.tabs.toArray()[this.selectedIndex];
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTabsComponent.prototype.ngAfterViewInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._selectedIndex === -1) {
            this.tabs.forEach(function (t) {
                if (t.isSelected) {
                    _this._selectedIndex = t.index;
                }
            });
        }
        if (!this.hasContentTabs && (this.selectedIndex < 0 || this.selectedIndex >= this.groups.length)) {
            this._selectedIndex = 0;
        }
        if (this.platformUtil.isBrowser) {
            requestAnimationFrame(function () {
                /** @type {?} */
                var newTab = _this.tabs.toArray()[_this._selectedIndex];
                if (newTab) {
                    _this.performSelection(newTab);
                }
                else {
                    _this.hideIndicator();
                }
            });
            this._ngZone.runOutsideAngular(function () {
                _this._resizeObserver = new ResizeObserver(function () {
                    if (!_this.hasContentTabs && _this._selectedIndex >= 0 && _this._selectedIndex < _this.tabs.length) {
                        /** @type {?} */
                        var newTab = _this.tabs.toArray()[_this._selectedIndex];
                        _this.transformContentAnimation(newTab, 0);
                    }
                });
                _this._resizeObserver.observe(_this.tabsContainer.nativeElement);
            });
        }
        this._groupChanges$ = this.groups.changes.subscribe(function () {
            _this.resetSelectionOnCollectionChanged();
        });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTabsComponent.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._groupChanges$) {
            this._groupChanges$.unsubscribe();
        }
        if (this._resizeObserver) {
            this._ngZone.runOutsideAngular(function () {
                _this._resizeObserver.disconnect();
            });
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxTabsComponent.prototype.resetSelectionOnCollectionChanged = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        requestAnimationFrame(function () {
            /** @type {?} */
            var currentTab = _this.tabs.toArray()[_this.selectedIndex];
            if (currentTab) {
                _this.performSelectionChange(currentTab);
            }
            else if (_this.selectedIndex >= _this.tabs.length) {
                _this.performSelectionChange(_this.tabs.last);
            }
            else {
                _this.hideIndicator();
            }
        });
    };
    /**
     * @private
     * @param {?} scrollRight
     * @return {?}
     */
    IgxTabsComponent.prototype.scroll = /**
     * @private
     * @param {?} scrollRight
     * @return {?}
     */
    function (scrollRight) {
        var e_1, _a;
        /** @type {?} */
        var tabsArray = this.tabs.toArray();
        try {
            for (var tabsArray_1 = tslib_1.__values(tabsArray), tabsArray_1_1 = tabsArray_1.next(); !tabsArray_1_1.done; tabsArray_1_1 = tabsArray_1.next()) {
                var tab = tabsArray_1_1.value;
                /** @type {?} */
                var element = tab.nativeTabItem.nativeElement;
                if (scrollRight) {
                    if (element.offsetWidth + element.offsetLeft > this.viewPort.nativeElement.offsetWidth + this.offset) {
                        this.scrollElement(element, scrollRight);
                        break;
                    }
                }
                else {
                    if (element.offsetWidth + element.offsetLeft >= this.offset) {
                        this.scrollElement(element, scrollRight);
                        break;
                    }
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (tabsArray_1_1 && !tabsArray_1_1.done && (_a = tabsArray_1.return)) _a.call(tabsArray_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} newTab
     * @return {?}
     */
    IgxTabsComponent.prototype.performSelectionChange = /**
     * @hidden
     * @param {?} newTab
     * @return {?}
     */
    function (newTab) {
        /** @type {?} */
        var oldTab = this.selectedTabItem;
        if (oldTab) {
            this.performDeselection(oldTab);
        }
        if (newTab) {
            this.performSelection(newTab);
        }
        else {
            // if there is no new selected tab hide the selection indicator
            this.hideIndicator();
        }
        this.selectedIndexChange.emit(this._selectedIndex);
    };
    /**
     * @private
     * @param {?} oldTab
     * @return {?}
     */
    IgxTabsComponent.prototype.performDeselection = /**
     * @private
     * @param {?} oldTab
     * @return {?}
     */
    function (oldTab) {
        oldTab.setSelectedInternal(false);
        /** @type {?} */
        var oldTabRelatedGroup = this.groups.toArray()[oldTab.index];
        if (oldTabRelatedGroup) {
            oldTabRelatedGroup.setSelectedInternal(false);
        }
        this._selectedIndex = -1;
        this.onTabItemDeselected.emit({ tab: oldTab, group: oldTabRelatedGroup });
    };
    /**
     * @private
     * @param {?} newTab
     * @return {?}
     */
    IgxTabsComponent.prototype.performSelection = /**
     * @private
     * @param {?} newTab
     * @return {?}
     */
    function (newTab) {
        var _this = this;
        newTab.setSelectedInternal(true);
        this._selectedIndex = newTab.index;
        /** @type {?} */
        var newTabRelatedGroup = null;
        if (!this.hasContentTabs && this.groups) {
            newTabRelatedGroup = this.groups.toArray()[newTab.index];
            if (newTabRelatedGroup) {
                newTabRelatedGroup.setSelectedInternal(true);
            }
        }
        this.onTabItemSelected.emit({ tab: newTab, group: newTabRelatedGroup });
        requestAnimationFrame(function () {
            // bring the new selected tab into view if it is not
            _this.bringNewTabIntoView(newTab);
            // animate the new selection indicator
            _this.transformIndicatorAnimation(newTab.nativeTabItem.nativeElement);
            // animate the new tab's group content
            if (!_this.hasContentTabs) {
                _this.transformContentAnimation(newTab, 0.2);
            }
        });
    };
    /**
     * @private
     * @param {?} newTab
     * @return {?}
     */
    IgxTabsComponent.prototype.bringNewTabIntoView = /**
     * @private
     * @param {?} newTab
     * @return {?}
     */
    function (newTab) {
        /** @type {?} */
        var tabNativeElement = newTab.nativeTabItem.nativeElement;
        // Scroll left if there is need
        if (tabNativeElement.offsetLeft < this.offset) {
            this.scrollElement(tabNativeElement, false);
        }
        // Scroll right if there is need
        /** @type {?} */
        var viewPortOffsetWidth = this.viewPort.nativeElement.offsetWidth;
        /** @type {?} */
        var delta = (tabNativeElement.offsetLeft + tabNativeElement.offsetWidth) - (viewPortOffsetWidth + this.offset);
        // Fix for IE 11, a difference is accumulated from the widths calculations
        if (delta > 1) {
            this.scrollElement(tabNativeElement, true);
        }
    };
    /**
     * @hidden
     */
    // animation for the new panel/group (not needed for tab only mode)
    /**
     * @hidden
     * @param {?} tab
     * @param {?} duration
     * @return {?}
     */
    // animation for the new panel/group (not needed for tab only mode)
    IgxTabsComponent.prototype.transformContentAnimation = /**
     * @hidden
     * @param {?} tab
     * @param {?} duration
     * @return {?}
     */
    // animation for the new panel/group (not needed for tab only mode)
    function (tab, duration) {
        /** @type {?} */
        var contentOffset = this.tabsContainer.nativeElement.offsetWidth * tab.index;
        this.contentsContainer.nativeElement.style.transitionDuration = duration > 0 ? duration + "s" : 'initial';
        this.contentsContainer.nativeElement.style.transform = "translate(" + -contentOffset + "px)";
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} element
     * @param {?=} duration
     * @return {?}
     */
    IgxTabsComponent.prototype.transformIndicatorAnimation = /**
     * @hidden
     * @param {?} element
     * @param {?=} duration
     * @return {?}
     */
    function (element, duration) {
        if (duration === void 0) { duration = 0.3; }
        if (this.selectedIndicator) {
            this.selectedIndicator.nativeElement.style.visibility = 'visible';
            this.selectedIndicator.nativeElement.style.transitionDuration = duration > 0 ? duration + "s" : 'initial';
            this.selectedIndicator.nativeElement.style.width = element.offsetWidth + "px";
            this.selectedIndicator.nativeElement.style.transform = "translate(" + element.offsetLeft + "px)";
        }
    };
    /**
     * @return {?}
     */
    IgxTabsComponent.prototype.hideIndicator = /**
     * @return {?}
     */
    function () {
        if (this.selectedIndicator) {
            this.selectedIndicator.nativeElement.style.visibility = 'hidden';
        }
    };
    IgxTabsComponent.decorators = [
        { type: Component, args: [{
                    selector: 'igx-tabs',
                    template: "<!-- TODO Remove tab container from here -->\n<div #tabsContainer>\n    <div class=\"igx-tabs__header\" #headerContainer>\n        <button igxRipple class=\"igx-tabs__header-button\" igxButton=\"icon\" (click)=\"scrollLeft($event)\" igxLeftButtonStyle>\n            <igx-icon fontSet=\"material\">navigate_before</igx-icon>\n        </button>\n        <div class=\"igx-tabs__header-wrapper-fixed\" #viewPort>\n            <div #itemsContainer class=\"igx-tabs__header-wrapper-fluid\">\n                <ng-container *ngIf=\"!hasContentTabs\">\n                    <igx-tab-item igxRipple *ngFor=\"let group of groups\" [relatedGroup]=\"group\">\n                    </igx-tab-item>\n                </ng-container>\n                <ng-content select=\"igx-tab-item\"></ng-content>\n                <div #selectedIndicator *ngIf=\"groups.length > 0 || contentTabs.length > 0\" class=\"igx-tabs__header-menu-item-indicator\"></div>\n            </div>\n        </div>\n        <button igxRipple class=\"igx-tabs__header-button\" igxButton=\"icon\" (click)=\"scrollRight($event)\" igxRightButtonStyle>\n            <igx-icon fontSet=\"material\">navigate_next</igx-icon>\n        </button>\n    </div>\n    <div class=\"igx-tabs__content-fixed\">\n        <div #contentsContainer class=\"igx-tabs__content-fluid\">\n            <ng-content></ng-content>\n        </div>\n    </div>\n</div>",
                    providers: [{ provide: IgxTabsBase, useExisting: IgxTabsComponent }]
                }] }
    ];
    /** @nocollapse */
    IgxTabsComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: NgZone },
        { type: PlatformUtil }
    ]; };
    IgxTabsComponent.propDecorators = {
        groups: [{ type: ContentChildren, args: [forwardRef(function () { return IgxTabsGroupComponent; }),] }],
        contentTabs: [{ type: ContentChildren, args: [forwardRef(function () { return IgxTabItemComponent; }),] }],
        selectedIndex: [{ type: Input }],
        selectedIndexChange: [{ type: Output }],
        tabsType: [{ type: Input, args: ['tabsType',] }],
        class: [{ type: Input }],
        onTabItemDeselected: [{ type: Output }],
        onTabItemSelected: [{ type: Output }],
        contentsContainer: [{ type: ViewChild, args: ['contentsContainer', { static: true },] }],
        headerContainer: [{ type: ViewChild, args: ['headerContainer', { static: true },] }],
        itemsContainer: [{ type: ViewChild, args: ['itemsContainer', { static: true },] }],
        selectedIndicator: [{ type: ViewChild, args: ['selectedIndicator', { static: false },] }],
        tabsContainer: [{ type: ViewChild, args: ['tabsContainer', { static: true },] }],
        viewPort: [{ type: ViewChild, args: ['viewPort', { static: true },] }],
        viewTabs: [{ type: ViewChildren, args: [forwardRef(function () { return IgxTabItemComponent; }),] }],
        cssClass: [{ type: HostBinding, args: ['attr.class',] }]
    };
    return IgxTabsComponent;
}());
export { IgxTabsComponent };
if (false) {
    /**
     * Provides an observable collection of all `IgxTabsGroupComponent`s.
     * ```typescript
     * const groupItems = this.myTabComponent.groups;
     * ```
     * @type {?}
     */
    IgxTabsComponent.prototype.groups;
    /**
     * Provides an observable collection of all `IgxTabItemComponent`s defined in the page.
     * ```typescript
     * const tabItems = this.myTabComponent.contentTabs;
     * ```
     * @type {?}
     */
    IgxTabsComponent.prototype.contentTabs;
    /**
     * @hidden
     * @type {?}
     */
    IgxTabsComponent.prototype.selectedIndexChange;
    /**
     * Defines the tab header sizing mode. You can choose between `contentfit` or `fixed`.
     * By default the header sizing mode is `contentfit`.
     * ```html
     * <igx-tabs tabsType="fixed">
     *     <igx-tabs-group label="HOME">Home</igx-tabs-group>
     * </igx-tabs>
     * ```
     * @type {?}
     */
    IgxTabsComponent.prototype.tabsType;
    /**
     * @hidden
     * @type {?}
     */
    IgxTabsComponent.prototype.class;
    /**
     * Emitted when a tab item is deselected.
     * ```html
     * <igx-tabs (onTabItemDeselected)="itemDeselected($event)">
     *      <igx-tabs-group label="Tab 1">This is Tab 1 content.</igx-tabs-group>
     *      <igx-tabs-group label="Tab 2">This is Tab 2 content.</igx-tabs-group>
     * </igx-tabs>
     * ```
     * ```typescript
     * itemDeselected(e){
     *      const tabGroup = e.group;
     *      const tabItem = e.tab;
     * }
     * ```
     * @type {?}
     */
    IgxTabsComponent.prototype.onTabItemDeselected;
    /**
     * Emitted when a tab item is selected.
     * ```html
     * <igx-tabs (onTabItemSelected)="itemSelected($event)">
     *      <igx-tabs-group label="Tab 1">This is Tab 1 content.</igx-tabs-group>
     *      <igx-tabs-group label="Tab 2">This is Tab 2 content.</igx-tabs-group>
     * </igx-tabs>
     * ```
     * ```typescript
     * itemSelected(e){
     *      const tabGroup = e.group;
     *      const tabItem = e.tab;
     * }
     * ```
     * @type {?}
     */
    IgxTabsComponent.prototype.onTabItemSelected;
    /**
     * @hidden
     * @type {?}
     */
    IgxTabsComponent.prototype.contentsContainer;
    /**
     * @hidden
     * @type {?}
     */
    IgxTabsComponent.prototype.headerContainer;
    /**
     * @hidden
     * @type {?}
     */
    IgxTabsComponent.prototype.itemsContainer;
    /**
     * @hidden
     * @type {?}
     */
    IgxTabsComponent.prototype.selectedIndicator;
    /**
     * @hidden
     * @type {?}
     */
    IgxTabsComponent.prototype.tabsContainer;
    /**
     * @hidden
     * @type {?}
     */
    IgxTabsComponent.prototype.viewPort;
    /**
     * Provides an observable collection of all `IgxTabItemComponent`s.
     * ```typescript
     * const tabItems = this.myTabComponent.viewTabs;
     * ```
     * @type {?}
     */
    IgxTabsComponent.prototype.viewTabs;
    /**
     * @hidden
     * @type {?}
     */
    IgxTabsComponent.prototype.calculatedWidth;
    /**
     * @hidden
     * @type {?}
     */
    IgxTabsComponent.prototype.visibleItemsWidth;
    /**
     * @hidden
     * @type {?}
     */
    IgxTabsComponent.prototype.offset;
    /**
     * @type {?}
     * @private
     */
    IgxTabsComponent.prototype._groupChanges$;
    /**
     * @type {?}
     * @private
     */
    IgxTabsComponent.prototype._selectedIndex;
    /**
     * @type {?}
     * @private
     */
    IgxTabsComponent.prototype._resizeObserver;
    /**
     * @type {?}
     * @private
     */
    IgxTabsComponent.prototype._element;
    /**
     * @type {?}
     * @private
     */
    IgxTabsComponent.prototype._ngZone;
    /**
     * @type {?}
     * @private
     */
    IgxTabsComponent.prototype.platformUtil;
}
/**
 * @hidden
 */
var IgxTabsModule = /** @class */ (function () {
    function IgxTabsModule() {
    }
    IgxTabsModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxTabsComponent,
                        IgxTabsGroupComponent,
                        IgxTabItemComponent,
                        IgxTabItemTemplateDirective,
                        IgxRightButtonStyleDirective,
                        IgxLeftButtonStyleDirective],
                    exports: [IgxTabsComponent,
                        IgxTabsGroupComponent,
                        IgxTabItemComponent,
                        IgxTabItemTemplateDirective,
                        IgxRightButtonStyleDirective,
                        IgxLeftButtonStyleDirective],
                    imports: [CommonModule, IgxBadgeModule, IgxIconModule, IgxRippleModule]
                },] }
    ];
    return IgxTabsModule;
}());
export { IgxTabsModule };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFicy5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9pZ25pdGV1aS1hbmd1bGFyLyIsInNvdXJjZXMiOlsibGliL3RhYnMvdGFicy5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDL0MsT0FBTyxFQUVILFNBQVMsRUFDVCxlQUFlLEVBQ2YsVUFBVSxFQUNWLFlBQVksRUFDWixVQUFVLEVBQ1YsV0FBVyxFQUNYLEtBQUssRUFDTCxRQUFRLEVBQ1IsTUFBTSxFQUNOLFNBQVMsRUFDVCxTQUFTLEVBQ1QsWUFBWSxFQUVaLE1BQU0sRUFDVCxNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsY0FBYyxFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDMUQsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHVDQUF1QyxDQUFDO0FBQ3hFLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDOUMsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sc0JBQXNCLENBQUM7QUFDM0QsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDL0QsT0FBTyxFQUFFLDJCQUEyQixFQUFFLDRCQUE0QixFQUFFLDJCQUEyQixFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDM0gsT0FBTyxFQUFFLFdBQVcsRUFBa0IsTUFBTSxlQUFlLENBQUM7QUFDNUQsT0FBTyxjQUFjLE1BQU0sMEJBQTBCLENBQUM7QUFDdEQsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGVBQWUsQ0FBQzs7O0lBR3pDLE9BQVEsT0FBTztJQUNmLFlBQWEsWUFBWTs7O0FBRzdCO0lBMlFJLDBCQUFvQixRQUFvQixFQUFVLE9BQWUsRUFBVSxZQUEwQjtRQUFqRixhQUFRLEdBQVIsUUFBUSxDQUFZO1FBQVUsWUFBTyxHQUFQLE9BQU8sQ0FBUTtRQUFVLGlCQUFZLEdBQVosWUFBWSxDQUFjOzs7O1FBL005Rix3QkFBbUIsR0FBRyxJQUFJLFlBQVksRUFBVSxDQUFDOzs7Ozs7Ozs7O1FBWWpELGFBQVEsR0FBc0IsWUFBWSxDQUFDOzs7O1FBTTNDLFVBQUssR0FBRyxFQUFFLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7UUFrQlgsd0JBQW1CLEdBQUcsSUFBSSxZQUFZLEVBQUUsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7OztRQWtCekMsc0JBQWlCLEdBQUcsSUFBSSxZQUFZLEVBQUUsQ0FBQzs7OztRQWlGdkMsV0FBTSxHQUFHLENBQUMsQ0FBQztRQUdWLG1CQUFjLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFzRTVCLENBQUM7SUF2T0Qsc0JBQ1csMkNBQWE7UUFieEI7Ozs7Ozs7Ozs7O1VBV0U7Ozs7Ozs7Ozs7Ozs7O1FBQ0Y7WUFFSSxPQUFPLElBQUksQ0FBQyxjQUFjLENBQUM7UUFDL0IsQ0FBQzs7Ozs7UUFFRCxVQUF5QixLQUFhOztnQkFDNUIsUUFBUSxHQUFHLE9BQU8sS0FBSyxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSztZQUN4RSxJQUFJLElBQUksQ0FBQyxjQUFjLEtBQUssUUFBUSxFQUFFO2dCQUNsQyxJQUFJLElBQUksQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFOzt3QkFDN0IsTUFBTSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsUUFBUSxDQUFDO29CQUM1QyxJQUFJLE1BQU0sRUFBRTt3QkFDVCxJQUFJLENBQUMsc0JBQXNCLENBQUMsTUFBTSxDQUFDLENBQUM7cUJBQ3RDO2lCQUNKO3FCQUFNO29CQUNILElBQUksQ0FBQyxjQUFjLEdBQUcsUUFBUSxDQUFDO2lCQUNsQzthQUNKO1FBQ0wsQ0FBQzs7O09BZEE7SUFnSUQsc0JBQVcsa0NBQUk7UUFQZjs7Ozs7O1dBTUc7Ozs7Ozs7OztRQUNIO1lBQ0ksSUFBSSxJQUFJLENBQUMsY0FBYyxFQUFFO2dCQUNyQixPQUFPLElBQUksQ0FBQyxXQUFXLENBQUM7YUFDM0I7WUFDRCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUM7UUFDekIsQ0FBQzs7O09BQUE7SUFLRCxzQkFBVyw0Q0FBYztRQUh6Qjs7V0FFRzs7Ozs7UUFDSDtZQUNJLE9BQU8sQ0FBQyxJQUFJLENBQUMsV0FBVyxJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQzdELENBQUM7OztPQUFBO0lBd0JELHNCQUNXLHNDQUFRO1FBSm5COztXQUVHOzs7OztRQUNIOztnQkFFVSxZQUFZLEdBQUcsVUFBVTs7Z0JBQ3pCLFVBQVUsR0FBRyxpQkFBaUI7O2dCQUM5QixTQUFTLEdBQUcsaUJBQWlCOztnQkFDN0Isc0JBQXNCLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBQyxLQUFLLElBQUssT0FBQSxLQUFLLENBQUMsSUFBSSxJQUFJLElBQUksSUFBSSxLQUFLLENBQUMsS0FBSyxJQUFJLElBQUksRUFBekMsQ0FBeUMsQ0FBQzs7Z0JBQy9GLG9CQUFvQixHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFVBQUMsR0FBRyxJQUFLLE9BQUEsR0FBRyxDQUFDLElBQUksSUFBSSxJQUFJLElBQUksR0FBRyxDQUFDLEtBQUssSUFBSSxJQUFJLEVBQXJDLENBQXFDLENBQUM7O2dCQUM5RixHQUFHO1lBQ1AsUUFBUSxRQUFRLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxFQUFFO2dCQUMzQyxLQUFLLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztvQkFDakIsR0FBRyxHQUFHLFVBQVUsQ0FBQztvQkFDakIsTUFBTTtpQkFDVDtnQkFDRCxPQUFPLENBQUMsQ0FBQztvQkFDTCxHQUFHLEdBQUcsWUFBWSxDQUFDO29CQUNuQixNQUFNO2lCQUNUO2FBQ0o7WUFFRCxrQ0FBa0M7WUFDbEMsSUFBSSxzQkFBc0IsS0FBSyxTQUFTLElBQUksb0JBQW9CLEtBQUssU0FBUyxFQUFFO2dCQUM1RSxHQUFHLEdBQU0sR0FBRyxTQUFJLFNBQVcsQ0FBQzthQUMvQjtZQUVELE9BQVUsR0FBRyxTQUFJLElBQUksQ0FBQyxLQUFPLENBQUM7UUFDbEMsQ0FBQzs7O09BQUE7SUFFRDs7T0FFRzs7Ozs7O0lBQ0kscUNBQVU7Ozs7O0lBQWpCLFVBQWtCLEtBQUs7UUFDbkIsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN2QixDQUFDO0lBRUQ7O09BRUc7Ozs7OztJQUNJLHNDQUFXOzs7OztJQUFsQixVQUFtQixLQUFLO1FBQ3BCLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDdEIsQ0FBQztJQUVEOztPQUVHOzs7Ozs7O0lBQ0ksd0NBQWE7Ozs7OztJQUFwQixVQUFxQixPQUFZLEVBQUUsV0FBb0I7O1lBQzdDLGFBQWEsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxXQUFXO1FBRTdELElBQUksQ0FBQyxNQUFNLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLFdBQVcsR0FBRyxPQUFPLENBQUMsVUFBVSxHQUFHLGFBQWEsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQztRQUM1RyxJQUFJLENBQUMsY0FBYyxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsU0FBUyxHQUFHLGVBQWEsQ0FBQyxJQUFJLENBQUMsTUFBTSxRQUFLLENBQUM7SUFDdkYsQ0FBQztJQVFELHNCQUFJLDZDQUFlO1FBTm5COzs7OztXQUtHOzs7Ozs7OztRQUNIO1lBQ0ksSUFBSSxJQUFJLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxhQUFhLEtBQUssU0FBUyxFQUFFO2dCQUMvQyxPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDO2FBQ2xEO1FBQ0wsQ0FBQzs7O09BQUE7SUFLRDs7T0FFRzs7Ozs7SUFDSSwwQ0FBZTs7OztJQUF0QjtRQUFBLGlCQXFDQztRQXBDRyxJQUFJLElBQUksQ0FBQyxjQUFjLEtBQUssQ0FBQyxDQUFDLEVBQUU7WUFDNUIsSUFBSSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsVUFBQyxDQUFDO2dCQUNoQixJQUFJLENBQUMsQ0FBQyxVQUFVLEVBQUU7b0JBQ2QsS0FBSSxDQUFDLGNBQWMsR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDO2lCQUNqQztZQUNMLENBQUMsQ0FBQyxDQUFDO1NBQ047UUFFRCxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFhLEdBQUcsQ0FBQyxJQUFJLElBQUksQ0FBQyxhQUFhLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUM5RixJQUFJLENBQUMsY0FBYyxHQUFHLENBQUMsQ0FBQztTQUMzQjtRQUVELElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLEVBQUU7WUFDN0IscUJBQXFCLENBQUM7O29CQUNaLE1BQU0sR0FBRyxLQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLEtBQUksQ0FBQyxjQUFjLENBQUM7Z0JBQ3ZELElBQUksTUFBTSxFQUFFO29CQUNSLEtBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztpQkFDakM7cUJBQU07b0JBQ0gsS0FBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO2lCQUN4QjtZQUNMLENBQUMsQ0FBQyxDQUFDO1lBQ0gsSUFBSSxDQUFDLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQztnQkFDM0IsS0FBSSxDQUFDLGVBQWUsR0FBRyxJQUFJLGNBQWMsQ0FBQztvQkFDdEMsSUFBSSxDQUFDLEtBQUksQ0FBQyxjQUFjLElBQUksS0FBSSxDQUFDLGNBQWMsSUFBSSxDQUFDLElBQUksS0FBSSxDQUFDLGNBQWMsR0FBRyxLQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRTs7NEJBQ3RGLE1BQU0sR0FBRyxLQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLEtBQUksQ0FBQyxjQUFjLENBQUM7d0JBQ3ZELEtBQUksQ0FBQyx5QkFBeUIsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDLENBQUM7cUJBQzdDO2dCQUNMLENBQUMsQ0FBQyxDQUFDO2dCQUVILEtBQUksQ0FBQyxlQUFlLENBQUMsT0FBTyxDQUFDLEtBQUksQ0FBQyxhQUFhLENBQUMsYUFBYSxDQUFDLENBQUM7WUFDbkUsQ0FBQyxDQUFDLENBQUM7U0FDTjtRQUVELElBQUksQ0FBQyxjQUFjLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDO1lBQ2hELEtBQUksQ0FBQyxpQ0FBaUMsRUFBRSxDQUFDO1FBQzdDLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztJQUVEOztPQUVHOzs7OztJQUNJLHNDQUFXOzs7O0lBQWxCO1FBQUEsaUJBU0M7UUFSRyxJQUFJLElBQUksQ0FBQyxjQUFjLEVBQUU7WUFDckIsSUFBSSxDQUFDLGNBQWMsQ0FBQyxXQUFXLEVBQUUsQ0FBQztTQUNyQztRQUNELElBQUksSUFBSSxDQUFDLGVBQWUsRUFBRTtZQUN0QixJQUFJLENBQUMsT0FBTyxDQUFDLGlCQUFpQixDQUFDO2dCQUMzQixLQUFJLENBQUMsZUFBZSxDQUFDLFVBQVUsRUFBRSxDQUFDO1lBQ3RDLENBQUMsQ0FBQyxDQUFDO1NBQ047SUFDTCxDQUFDOzs7OztJQUVPLDREQUFpQzs7OztJQUF6QztRQUFBLGlCQVdDO1FBVkcscUJBQXFCLENBQUM7O2dCQUNaLFVBQVUsR0FBRyxLQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDLEtBQUksQ0FBQyxhQUFhLENBQUM7WUFDMUQsSUFBSSxVQUFVLEVBQUU7Z0JBQ1osS0FBSSxDQUFDLHNCQUFzQixDQUFDLFVBQVUsQ0FBQyxDQUFDO2FBQzNDO2lCQUFNLElBQUksS0FBSSxDQUFDLGFBQWEsSUFBSSxLQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRTtnQkFDL0MsS0FBSSxDQUFDLHNCQUFzQixDQUFDLEtBQUksQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7YUFDL0M7aUJBQU07Z0JBQ0gsS0FBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO2FBQ3hCO1FBQ0wsQ0FBQyxDQUFDLENBQUM7SUFDUCxDQUFDOzs7Ozs7SUFFTyxpQ0FBTTs7Ozs7SUFBZCxVQUFlLFdBQW9COzs7WUFDekIsU0FBUyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFOztZQUNyQyxLQUFrQixJQUFBLGNBQUEsaUJBQUEsU0FBUyxDQUFBLG9DQUFBLDJEQUFFO2dCQUF4QixJQUFNLEdBQUcsc0JBQUE7O29CQUNKLE9BQU8sR0FBRyxHQUFHLENBQUMsYUFBYSxDQUFDLGFBQWE7Z0JBQy9DLElBQUksV0FBVyxFQUFFO29CQUNiLElBQUksT0FBTyxDQUFDLFdBQVcsR0FBRyxPQUFPLENBQUMsVUFBVSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDLFdBQVcsR0FBRyxJQUFJLENBQUMsTUFBTSxFQUFFO3dCQUNsRyxJQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sRUFBRSxXQUFXLENBQUMsQ0FBQzt3QkFDekMsTUFBTTtxQkFDVDtpQkFDSjtxQkFBTTtvQkFDSCxJQUFJLE9BQU8sQ0FBQyxXQUFXLEdBQUcsT0FBTyxDQUFDLFVBQVUsSUFBSSxJQUFJLENBQUMsTUFBTSxFQUFFO3dCQUN6RCxJQUFJLENBQUMsYUFBYSxDQUFDLE9BQU8sRUFBRSxXQUFXLENBQUMsQ0FBQzt3QkFDekMsTUFBTTtxQkFDVDtpQkFDSjthQUNKOzs7Ozs7Ozs7SUFDTCxDQUFDO0lBRUQ7O09BRUc7Ozs7OztJQUNJLGlEQUFzQjs7Ozs7SUFBN0IsVUFBOEIsTUFBc0I7O1lBQzFDLE1BQU0sR0FBRyxJQUFJLENBQUMsZUFBZTtRQUNuQyxJQUFJLE1BQU0sRUFBRTtZQUNSLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUNuQztRQUNELElBQUksTUFBTSxFQUFFO1lBQ1IsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQ2pDO2FBQU07WUFDSCwrREFBK0Q7WUFDL0QsSUFBSSxDQUFDLGFBQWEsRUFBRSxDQUFDO1NBQ3hCO1FBQ0QsSUFBSSxDQUFDLG1CQUFtQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7SUFDdkQsQ0FBQzs7Ozs7O0lBRU8sNkNBQWtCOzs7OztJQUExQixVQUEyQixNQUFzQjtRQUM3QyxNQUFNLENBQUMsbUJBQW1CLENBQUMsS0FBSyxDQUFDLENBQUM7O1lBQzVCLGtCQUFrQixHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxFQUFFLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQztRQUM5RCxJQUFJLGtCQUFrQixFQUFFO1lBQ3BCLGtCQUFrQixDQUFDLG1CQUFtQixDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQ2pEO1FBQ0QsSUFBSSxDQUFDLGNBQWMsR0FBRyxDQUFDLENBQUMsQ0FBQztRQUN6QixJQUFJLENBQUMsbUJBQW1CLENBQUMsSUFBSSxDQUFDLEVBQUUsR0FBRyxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsa0JBQWtCLEVBQUUsQ0FBQyxDQUFDO0lBQzlFLENBQUM7Ozs7OztJQUVPLDJDQUFnQjs7Ozs7SUFBeEIsVUFBeUIsTUFBc0I7UUFBL0MsaUJBd0JDO1FBdkJHLE1BQU0sQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNqQyxJQUFJLENBQUMsY0FBYyxHQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUM7O1lBRS9CLGtCQUFrQixHQUFHLElBQUk7UUFDN0IsSUFBSSxDQUFDLElBQUksQ0FBQyxjQUFjLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNyQyxrQkFBa0IsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sRUFBRSxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUN6RCxJQUFJLGtCQUFrQixFQUFFO2dCQUNwQixrQkFBa0IsQ0FBQyxtQkFBbUIsQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUNoRDtTQUNKO1FBRUQsSUFBSSxDQUFDLGlCQUFpQixDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLGtCQUFrQixFQUFFLENBQUMsQ0FBQztRQUV4RSxxQkFBcUIsQ0FBQztZQUNsQixvREFBb0Q7WUFDcEQsS0FBSSxDQUFDLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBQ2pDLHNDQUFzQztZQUN0QyxLQUFJLENBQUMsMkJBQTJCLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxhQUFhLENBQUMsQ0FBQztZQUNyRSxzQ0FBc0M7WUFDdEMsSUFBSSxDQUFDLEtBQUksQ0FBQyxjQUFjLEVBQUU7Z0JBQ3RCLEtBQUksQ0FBQyx5QkFBeUIsQ0FBQyxNQUFNLEVBQUUsR0FBRyxDQUFDLENBQUM7YUFDL0M7UUFDTCxDQUFDLENBQUMsQ0FBQztJQUNQLENBQUM7Ozs7OztJQUVPLDhDQUFtQjs7Ozs7SUFBM0IsVUFBNEIsTUFBc0I7O1lBQ3hDLGdCQUFnQixHQUFHLE1BQU0sQ0FBQyxhQUFhLENBQUMsYUFBYTtRQUUzRCwrQkFBK0I7UUFDL0IsSUFBSSxnQkFBZ0IsQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUMzQyxJQUFJLENBQUMsYUFBYSxDQUFDLGdCQUFnQixFQUFFLEtBQUssQ0FBQyxDQUFDO1NBQy9DOzs7WUFHSyxtQkFBbUIsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxXQUFXOztZQUM3RCxLQUFLLEdBQUcsQ0FBQyxnQkFBZ0IsQ0FBQyxVQUFVLEdBQUcsZ0JBQWdCLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxtQkFBbUIsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO1FBRWhILDBFQUEwRTtRQUMxRSxJQUFJLEtBQUssR0FBRyxDQUFDLEVBQUU7WUFDWCxJQUFJLENBQUMsYUFBYSxDQUFDLGdCQUFnQixFQUFFLElBQUksQ0FBQyxDQUFDO1NBQzlDO0lBQ0wsQ0FBQztJQUVEOztPQUVHO0lBQ0gsbUVBQW1FOzs7Ozs7OztJQUM1RCxvREFBeUI7Ozs7Ozs7SUFBaEMsVUFBaUMsR0FBbUIsRUFBRSxRQUFnQjs7WUFDNUQsYUFBYSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUMsYUFBYSxDQUFDLFdBQVcsR0FBRyxHQUFHLENBQUMsS0FBSztRQUM5RSxJQUFJLENBQUMsaUJBQWlCLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxrQkFBa0IsR0FBRyxRQUFRLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBSSxRQUFRLE1BQUcsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO1FBQzFHLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLFNBQVMsR0FBRyxlQUFhLENBQUMsYUFBYSxRQUFLLENBQUM7SUFDNUYsQ0FBQztJQUVEOztPQUVHOzs7Ozs7O0lBQ0ksc0RBQTJCOzs7Ozs7SUFBbEMsVUFBbUMsT0FBb0IsRUFBRSxRQUFjO1FBQWQseUJBQUEsRUFBQSxjQUFjO1FBQ25FLElBQUksSUFBSSxDQUFDLGlCQUFpQixFQUFFO1lBQ3hCLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLFVBQVUsR0FBRyxTQUFTLENBQUM7WUFDbEUsSUFBSSxDQUFDLGlCQUFpQixDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsa0JBQWtCLEdBQUcsUUFBUSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUksUUFBUSxNQUFHLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQztZQUMxRyxJQUFJLENBQUMsaUJBQWlCLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQU0sT0FBTyxDQUFDLFdBQVcsT0FBSSxDQUFDO1lBQzlFLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxhQUFhLENBQUMsS0FBSyxDQUFDLFNBQVMsR0FBRyxlQUFhLE9BQU8sQ0FBQyxVQUFVLFFBQUssQ0FBQztTQUMvRjtJQUNMLENBQUM7Ozs7SUFFTSx3Q0FBYTs7O0lBQXBCO1FBQ0ksSUFBSSxJQUFJLENBQUMsaUJBQWlCLEVBQUU7WUFDeEIsSUFBSSxDQUFDLGlCQUFpQixDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsVUFBVSxHQUFHLFFBQVEsQ0FBQztTQUNwRTtJQUNMLENBQUM7O2dCQXRjSixTQUFTLFNBQUM7b0JBQ1AsUUFBUSxFQUFFLFVBQVU7b0JBQ3BCLHUzQ0FBa0M7b0JBQ2xDLFNBQVMsRUFBRSxDQUFDLEVBQUUsT0FBTyxFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUUsZ0JBQWdCLEVBQUUsQ0FBQztpQkFDdkU7Ozs7Z0JBakNHLFVBQVU7Z0JBV1YsTUFBTTtnQkFXRCxZQUFZOzs7eUJBb0JoQixlQUFlLFNBQUMsVUFBVSxDQUFDLGNBQU0sT0FBQSxxQkFBcUIsRUFBckIsQ0FBcUIsQ0FBQzs4QkFTdkQsZUFBZSxTQUFDLFVBQVUsQ0FBQyxjQUFNLE9BQUEsbUJBQW1CLEVBQW5CLENBQW1CLENBQUM7Z0NBZXJELEtBQUs7c0NBc0JMLE1BQU07MkJBWU4sS0FBSyxTQUFDLFVBQVU7d0JBTWhCLEtBQUs7c0NBa0JMLE1BQU07b0NBa0JOLE1BQU07b0NBTU4sU0FBUyxTQUFDLG1CQUFtQixFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRTtrQ0FNL0MsU0FBUyxTQUFDLGlCQUFpQixFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRTtpQ0FNN0MsU0FBUyxTQUFDLGdCQUFnQixFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRTtvQ0FNNUMsU0FBUyxTQUFDLG1CQUFtQixFQUFFLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRTtnQ0FNaEQsU0FBUyxTQUFDLGVBQWUsRUFBRSxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7MkJBTTNDLFNBQVMsU0FBQyxVQUFVLEVBQUUsRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFOzJCQVN0QyxZQUFZLFNBQUMsVUFBVSxDQUFDLGNBQU0sT0FBQSxtQkFBbUIsRUFBbkIsQ0FBbUIsQ0FBQzsyQkE4Q2xELFdBQVcsU0FBQyxZQUFZOztJQTRQN0IsdUJBQUM7Q0FBQSxBQXhjRCxJQXdjQztTQWxjWSxnQkFBZ0I7Ozs7Ozs7OztJQU96QixrQ0FDZ0Q7Ozs7Ozs7O0lBUWhELHVDQUNtRDs7Ozs7SUFvQ25ELCtDQUN3RDs7Ozs7Ozs7Ozs7SUFXeEQsb0NBQ2tEOzs7OztJQUtsRCxpQ0FDa0I7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBaUJsQiwrQ0FDZ0Q7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBaUJoRCw2Q0FDOEM7Ozs7O0lBSzlDLDZDQUNxQzs7Ozs7SUFLckMsMkNBQ21DOzs7OztJQUtuQywwQ0FDa0M7Ozs7O0lBS2xDLDZDQUNxQzs7Ozs7SUFLckMseUNBQ2lDOzs7OztJQUtqQyxvQ0FDNEI7Ozs7Ozs7O0lBUTVCLG9DQUNnRDs7Ozs7SUEwQmhELDJDQUErQjs7Ozs7SUFLL0IsNkNBQWlDOzs7OztJQUtqQyxrQ0FBa0I7Ozs7O0lBRWxCLDBDQUFxQzs7Ozs7SUFDckMsMENBQTRCOzs7OztJQUM1QiwyQ0FBd0M7Ozs7O0lBb0U1QixvQ0FBNEI7Ozs7O0lBQUUsbUNBQXVCOzs7OztJQUFFLHdDQUFrQzs7Ozs7QUFrTXpHO0lBQUE7SUFpQkEsQ0FBQzs7Z0JBakJBLFFBQVEsU0FBQztvQkFDTixZQUFZLEVBQUUsQ0FBQyxnQkFBZ0I7d0JBQzNCLHFCQUFxQjt3QkFDckIsbUJBQW1CO3dCQUNuQiwyQkFBMkI7d0JBQzNCLDRCQUE0Qjt3QkFDNUIsMkJBQTJCLENBQUM7b0JBQ2hDLE9BQU8sRUFBRSxDQUFDLGdCQUFnQjt3QkFDdEIscUJBQXFCO3dCQUNyQixtQkFBbUI7d0JBQ25CLDJCQUEyQjt3QkFDM0IsNEJBQTRCO3dCQUM1QiwyQkFBMkIsQ0FBQztvQkFDaEMsT0FBTyxFQUFFLENBQUMsWUFBWSxFQUFFLGNBQWMsRUFBRSxhQUFhLEVBQUUsZUFBZSxDQUFDO2lCQUMxRTs7SUFHRCxvQkFBQztDQUFBLEFBakJELElBaUJDO1NBRFksYUFBYSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1xuICAgIEFmdGVyVmlld0luaXQsXG4gICAgQ29tcG9uZW50LFxuICAgIENvbnRlbnRDaGlsZHJlbixcbiAgICBFbGVtZW50UmVmLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBmb3J3YXJkUmVmLFxuICAgIEhvc3RCaW5kaW5nLFxuICAgIElucHV0LFxuICAgIE5nTW9kdWxlLFxuICAgIE91dHB1dCxcbiAgICBRdWVyeUxpc3QsXG4gICAgVmlld0NoaWxkLFxuICAgIFZpZXdDaGlsZHJlbixcbiAgICBPbkRlc3Ryb3ksXG4gICAgTmdab25lXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3Vic2NyaXB0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBJZ3hCYWRnZU1vZHVsZSB9IGZyb20gJy4uL2JhZGdlL2JhZGdlLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hSaXBwbGVNb2R1bGUgfSBmcm9tICcuLi9kaXJlY3RpdmVzL3JpcHBsZS9yaXBwbGUuZGlyZWN0aXZlJztcbmltcG9ydCB7IElneEljb25Nb2R1bGUgfSBmcm9tICcuLi9pY29uL2luZGV4JztcbmltcG9ydCB7IElneFRhYkl0ZW1Db21wb25lbnQgfSBmcm9tICcuL3RhYi1pdGVtLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hUYWJzR3JvdXBDb21wb25lbnQgfSBmcm9tICcuL3RhYnMtZ3JvdXAuY29tcG9uZW50JztcbmltcG9ydCB7IElneExlZnRCdXR0b25TdHlsZURpcmVjdGl2ZSwgSWd4UmlnaHRCdXR0b25TdHlsZURpcmVjdGl2ZSwgSWd4VGFiSXRlbVRlbXBsYXRlRGlyZWN0aXZlIH0gZnJvbSAnLi90YWJzLmRpcmVjdGl2ZXMnO1xuaW1wb3J0IHsgSWd4VGFic0Jhc2UsIElneFRhYkl0ZW1CYXNlIH0gZnJvbSAnLi90YWJzLmNvbW1vbic7XG5pbXBvcnQgUmVzaXplT2JzZXJ2ZXIgZnJvbSAncmVzaXplLW9ic2VydmVyLXBvbHlmaWxsJztcbmltcG9ydCB7IFBsYXRmb3JtVXRpbCB9IGZyb20gJy4uL2NvcmUvdXRpbHMnO1xuXG5leHBvcnQgZW51bSBUYWJzVHlwZSB7XG4gICAgRklYRUQgPSAnZml4ZWQnLFxuICAgIENPTlRFTlRGSVQgPSAnY29udGVudGZpdCdcbn1cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdpZ3gtdGFicycsXG4gICAgdGVtcGxhdGVVcmw6ICd0YWJzLmNvbXBvbmVudC5odG1sJyxcbiAgICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IElneFRhYnNCYXNlLCB1c2VFeGlzdGluZzogSWd4VGFic0NvbXBvbmVudCB9XVxufSlcblxuZXhwb3J0IGNsYXNzIElneFRhYnNDb21wb25lbnQgaW1wbGVtZW50cyBJZ3hUYWJzQmFzZSwgQWZ0ZXJWaWV3SW5pdCwgT25EZXN0cm95IHtcbiAgICAvKipcbiAgICAqIFByb3ZpZGVzIGFuIG9ic2VydmFibGUgY29sbGVjdGlvbiBvZiBhbGwgYElneFRhYnNHcm91cENvbXBvbmVudGBzLlxuICAgICogYGBgdHlwZXNjcmlwdFxuICAgICogY29uc3QgZ3JvdXBJdGVtcyA9IHRoaXMubXlUYWJDb21wb25lbnQuZ3JvdXBzO1xuICAgICogYGBgXG4gICAgKi9cbiAgICBAQ29udGVudENoaWxkcmVuKGZvcndhcmRSZWYoKCkgPT4gSWd4VGFic0dyb3VwQ29tcG9uZW50KSlcbiAgICBwdWJsaWMgZ3JvdXBzOiBRdWVyeUxpc3Q8SWd4VGFic0dyb3VwQ29tcG9uZW50PjtcblxuICAgIC8qKlxuICAgICogUHJvdmlkZXMgYW4gb2JzZXJ2YWJsZSBjb2xsZWN0aW9uIG9mIGFsbCBgSWd4VGFiSXRlbUNvbXBvbmVudGBzIGRlZmluZWQgaW4gdGhlIHBhZ2UuXG4gICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgKiBjb25zdCB0YWJJdGVtcyA9IHRoaXMubXlUYWJDb21wb25lbnQuY29udGVudFRhYnM7XG4gICAgKiBgYGBcbiAgICAqL1xuICAgIEBDb250ZW50Q2hpbGRyZW4oZm9yd2FyZFJlZigoKSA9PiBJZ3hUYWJJdGVtQ29tcG9uZW50KSlcbiAgICBwdWJsaWMgY29udGVudFRhYnM6IFF1ZXJ5TGlzdDxJZ3hUYWJJdGVtQ29tcG9uZW50PjtcblxuICAgIC8qKlxuICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgdmFsdWUgb2YgdGhlIGBzZWxlY3RlZEluZGV4YC5cbiAgICAqIERlZmF1bHQgdmFsdWUgaXMgMC5cbiAgICAqIGBgYGh0bWxcbiAgICAqIDxpZ3gtdGFicyBzZWxlY3RlZEluZGV4PVwiMVwiPlxuICAgICogYGBgXG4gICAgKlxuICAgICogVHdvLXdheSBkYXRhIGJpbmRpbmcuXG4gICAgKiBgYGBodG1sXG4gICAgKiA8aWd4LXRhYnMgWyhzZWxlY3RlZEluZGV4KV09XCJtb2RlbC5zZWxlY3RlZEluZGV4XCI+XG4gICAgKiBgYGBcbiAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBzZWxlY3RlZEluZGV4KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZWxlY3RlZEluZGV4O1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgc2VsZWN0ZWRJbmRleChpbmRleDogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IG5ld0luZGV4ID0gdHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJyA/IHBhcnNlSW50KGluZGV4LCAxMCkgOiBpbmRleDtcbiAgICAgICAgaWYgKHRoaXMuX3NlbGVjdGVkSW5kZXggIT09IG5ld0luZGV4KSB7XG4gICAgICAgICAgICBpZiAodGhpcy50YWJzICYmIHRoaXMudGFicy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3VGFiID0gdGhpcy50YWJzLnRvQXJyYXkoKVtuZXdJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKG5ld1RhYikge1xuICAgICAgICAgICAgICAgICAgIHRoaXMucGVyZm9ybVNlbGVjdGlvbkNoYW5nZShuZXdUYWIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRJbmRleCA9IG5ld0luZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpAaGlkZGVuXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHNlbGVjdGVkSW5kZXhDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPG51bWJlcj4oKTtcblxuICAgIC8qKlxuICAgICAqIERlZmluZXMgdGhlIHRhYiBoZWFkZXIgc2l6aW5nIG1vZGUuIFlvdSBjYW4gY2hvb3NlIGJldHdlZW4gYGNvbnRlbnRmaXRgIG9yIGBmaXhlZGAuXG4gICAgICogQnkgZGVmYXVsdCB0aGUgaGVhZGVyIHNpemluZyBtb2RlIGlzIGBjb250ZW50Zml0YC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC10YWJzIHRhYnNUeXBlPVwiZml4ZWRcIj5cbiAgICAgKiAgICAgPGlneC10YWJzLWdyb3VwIGxhYmVsPVwiSE9NRVwiPkhvbWU8L2lneC10YWJzLWdyb3VwPlxuICAgICAqIDwvaWd4LXRhYnM+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KCd0YWJzVHlwZScpXG4gICAgcHVibGljIHRhYnNUeXBlOiBzdHJpbmcgfCBUYWJzVHlwZSA9ICdjb250ZW50Zml0JztcblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgY2xhc3MgPSAnJztcblxuICAgIC8qKlxuICAgICAqIEVtaXR0ZWQgd2hlbiBhIHRhYiBpdGVtIGlzIGRlc2VsZWN0ZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtdGFicyAob25UYWJJdGVtRGVzZWxlY3RlZCk9XCJpdGVtRGVzZWxlY3RlZCgkZXZlbnQpXCI+XG4gICAgICogICAgICA8aWd4LXRhYnMtZ3JvdXAgbGFiZWw9XCJUYWIgMVwiPlRoaXMgaXMgVGFiIDEgY29udGVudC48L2lneC10YWJzLWdyb3VwPlxuICAgICAqICAgICAgPGlneC10YWJzLWdyb3VwIGxhYmVsPVwiVGFiIDJcIj5UaGlzIGlzIFRhYiAyIGNvbnRlbnQuPC9pZ3gtdGFicy1ncm91cD5cbiAgICAgKiA8L2lneC10YWJzPlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBpdGVtRGVzZWxlY3RlZChlKXtcbiAgICAgKiAgICAgIGNvbnN0IHRhYkdyb3VwID0gZS5ncm91cDtcbiAgICAgKiAgICAgIGNvbnN0IHRhYkl0ZW0gPSBlLnRhYjtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIG9uVGFiSXRlbURlc2VsZWN0ZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAqIEVtaXR0ZWQgd2hlbiBhIHRhYiBpdGVtIGlzIHNlbGVjdGVkLlxuICAgICogYGBgaHRtbFxuICAgICogPGlneC10YWJzIChvblRhYkl0ZW1TZWxlY3RlZCk9XCJpdGVtU2VsZWN0ZWQoJGV2ZW50KVwiPlxuICAgICogICAgICA8aWd4LXRhYnMtZ3JvdXAgbGFiZWw9XCJUYWIgMVwiPlRoaXMgaXMgVGFiIDEgY29udGVudC48L2lneC10YWJzLWdyb3VwPlxuICAgICogICAgICA8aWd4LXRhYnMtZ3JvdXAgbGFiZWw9XCJUYWIgMlwiPlRoaXMgaXMgVGFiIDIgY29udGVudC48L2lneC10YWJzLWdyb3VwPlxuICAgICogPC9pZ3gtdGFicz5cbiAgICAqIGBgYFxuICAgICogYGBgdHlwZXNjcmlwdFxuICAgICogaXRlbVNlbGVjdGVkKGUpe1xuICAgICogICAgICBjb25zdCB0YWJHcm91cCA9IGUuZ3JvdXA7XG4gICAgKiAgICAgIGNvbnN0IHRhYkl0ZW0gPSBlLnRhYjtcbiAgICAqIH1cbiAgICAqIGBgYFxuICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIG9uVGFiSXRlbVNlbGVjdGVkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGQoJ2NvbnRlbnRzQ29udGFpbmVyJywgeyBzdGF0aWM6IHRydWUgfSlcbiAgICBwdWJsaWMgY29udGVudHNDb250YWluZXI6IEVsZW1lbnRSZWY7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgnaGVhZGVyQ29udGFpbmVyJywgeyBzdGF0aWM6IHRydWUgfSlcbiAgICBwdWJsaWMgaGVhZGVyQ29udGFpbmVyOiBFbGVtZW50UmVmO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGQoJ2l0ZW1zQ29udGFpbmVyJywgeyBzdGF0aWM6IHRydWUgfSlcbiAgICBwdWJsaWMgaXRlbXNDb250YWluZXI6IEVsZW1lbnRSZWY7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgnc2VsZWN0ZWRJbmRpY2F0b3InLCB7IHN0YXRpYzogZmFsc2UgfSlcbiAgICBwdWJsaWMgc2VsZWN0ZWRJbmRpY2F0b3I6IEVsZW1lbnRSZWY7XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqL1xuICAgIEBWaWV3Q2hpbGQoJ3RhYnNDb250YWluZXInLCB7IHN0YXRpYzogdHJ1ZSB9KVxuICAgIHB1YmxpYyB0YWJzQ29udGFpbmVyOiBFbGVtZW50UmVmO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGQoJ3ZpZXdQb3J0JywgeyBzdGF0aWM6IHRydWUgfSlcbiAgICBwdWJsaWMgdmlld1BvcnQ6IEVsZW1lbnRSZWY7XG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBhbiBvYnNlcnZhYmxlIGNvbGxlY3Rpb24gb2YgYWxsIGBJZ3hUYWJJdGVtQ29tcG9uZW50YHMuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IHRhYkl0ZW1zID0gdGhpcy5teVRhYkNvbXBvbmVudC52aWV3VGFicztcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAVmlld0NoaWxkcmVuKGZvcndhcmRSZWYoKCkgPT4gSWd4VGFiSXRlbUNvbXBvbmVudCkpXG4gICAgcHVibGljIHZpZXdUYWJzOiBRdWVyeUxpc3Q8SWd4VGFiSXRlbUNvbXBvbmVudD47XG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBhbiBvYnNlcnZhYmxlIGNvbGxlY3Rpb24gb2YgYWxsIGBJZ3hUYWJJdGVtQ29tcG9uZW50YHMuXG4gICAgICogRmlyc3QgdHJ5IHRvIGdldCB0aGVtIGFzIGNvbnRlbnQgY2hpbGRyZW4gaWYgbm90IGF2YWlsYWJsZSBnZXQgdGhlbSBhcyB2aWV3IGNoaWxkcmVuLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBjb25zdCB0YWJJdGVtcyA9IHRoaXMubXlUYWJDb21wb25lbnQudGFicztcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHRhYnMoKTogUXVlcnlMaXN0PElneFRhYkl0ZW1Db21wb25lbnQ+IHtcbiAgICAgICAgaWYgKHRoaXMuaGFzQ29udGVudFRhYnMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRUYWJzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnZpZXdUYWJzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgaGFzQ29udGVudFRhYnMoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAodGhpcy5jb250ZW50VGFicyAmJiB0aGlzLmNvbnRlbnRUYWJzLmxlbmd0aCA+IDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgY2FsY3VsYXRlZFdpZHRoOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHZpc2libGVJdGVtc1dpZHRoOiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG9mZnNldCA9IDA7XG5cbiAgICBwcml2YXRlIF9ncm91cENoYW5nZXMkOiBTdWJzY3JpcHRpb247XG4gICAgcHJpdmF0ZSBfc2VsZWN0ZWRJbmRleCA9IC0xO1xuICAgIHByaXZhdGUgX3Jlc2l6ZU9ic2VydmVyOiBSZXNpemVPYnNlcnZlcjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuY2xhc3MnKVxuICAgIHB1YmxpYyBnZXQgY3NzQ2xhc3MoKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRTdHlsZSA9IGBpZ3gtdGFic2A7XG4gICAgICAgIGNvbnN0IGZpeGVkU3R5bGUgPSBgaWd4LXRhYnMtLWZpeGVkYDtcbiAgICAgICAgY29uc3QgaWNvblN0eWxlID0gYGlneC10YWJzLS1pY29uc2A7XG4gICAgICAgIGNvbnN0IGljb25MYWJlbEZvdW5kSW5Hcm91cHMgPSB0aGlzLmdyb3Vwcy5maW5kKChncm91cCkgPT4gZ3JvdXAuaWNvbiAhPSBudWxsICYmIGdyb3VwLmxhYmVsICE9IG51bGwpO1xuICAgICAgICBjb25zdCBpY29uTGFiZWxGb3VuZEluVGFicyA9IHRoaXMuY29udGVudFRhYnMuZmluZCgodGFiKSA9PiB0YWIuaWNvbiAhPSBudWxsICYmIHRhYi5sYWJlbCAhPSBudWxsKTtcbiAgICAgICAgbGV0IGNzcztcbiAgICAgICAgc3dpdGNoIChUYWJzVHlwZVt0aGlzLnRhYnNUeXBlLnRvVXBwZXJDYXNlKCldKSB7XG4gICAgICAgICAgICBjYXNlIFRhYnNUeXBlLkZJWEVEOiB7XG4gICAgICAgICAgICAgICAgY3NzID0gZml4ZWRTdHlsZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBjc3MgPSBkZWZhdWx0U3R5bGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMYXlvdXQgZml4IGZvciBpdGVtcyB3aXRoIGljb25zXG4gICAgICAgIGlmIChpY29uTGFiZWxGb3VuZEluR3JvdXBzICE9PSB1bmRlZmluZWQgfHwgaWNvbkxhYmVsRm91bmRJblRhYnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY3NzID0gYCR7Y3NzfSAke2ljb25TdHlsZX1gO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGAke2Nzc30gJHt0aGlzLmNsYXNzfWA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBzY3JvbGxMZWZ0KGV2ZW50KTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2Nyb2xsKGZhbHNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHNjcm9sbFJpZ2h0KGV2ZW50KTogdm9pZCB7XG4gICAgICAgIHRoaXMuc2Nyb2xsKHRydWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgc2Nyb2xsRWxlbWVudChlbGVtZW50OiBhbnksIHNjcm9sbFJpZ2h0OiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHZpZXdQb3J0V2lkdGggPSB0aGlzLnZpZXdQb3J0Lm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGg7XG5cbiAgICAgICAgdGhpcy5vZmZzZXQgPSAoc2Nyb2xsUmlnaHQpID8gZWxlbWVudC5vZmZzZXRXaWR0aCArIGVsZW1lbnQub2Zmc2V0TGVmdCAtIHZpZXdQb3J0V2lkdGggOiBlbGVtZW50Lm9mZnNldExlZnQ7XG4gICAgICAgIHRoaXMuaXRlbXNDb250YWluZXIubmF0aXZlRWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7LXRoaXMub2Zmc2V0fXB4KWA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc2VsZWN0ZWQgYElneFRhYkl0ZW1Db21wb25lbnRgLlxuICAgICAqIGBgYFxuICAgICAqIGNvbnN0IHNlbGVjdGVkSXRlbSA9IHRoaXMubXlUYWJDb21wb25lbnQuc2VsZWN0ZWRUYWJJdGVtO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBzZWxlY3RlZFRhYkl0ZW0oKTogSWd4VGFiSXRlbUNvbXBvbmVudCB7XG4gICAgICAgIGlmICh0aGlzLnRhYnMgJiYgdGhpcy5zZWxlY3RlZEluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRhYnMudG9BcnJheSgpW3RoaXMuc2VsZWN0ZWRJbmRleF07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbGVtZW50OiBFbGVtZW50UmVmLCBwcml2YXRlIF9uZ1pvbmU6IE5nWm9uZSwgcHJpdmF0ZSBwbGF0Zm9ybVV0aWw6IFBsYXRmb3JtVXRpbCkge1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdBZnRlclZpZXdJbml0KCkge1xuICAgICAgICBpZiAodGhpcy5fc2VsZWN0ZWRJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMudGFicy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHQuaXNTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZWxlY3RlZEluZGV4ID0gdC5pbmRleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5oYXNDb250ZW50VGFicyAmJiAodGhpcy5zZWxlY3RlZEluZGV4IDwgMCB8fCB0aGlzLnNlbGVjdGVkSW5kZXggPj0gdGhpcy5ncm91cHMubGVuZ3RoKSkge1xuICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRJbmRleCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5wbGF0Zm9ybVV0aWwuaXNCcm93c2VyKSB7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1RhYiA9IHRoaXMudGFicy50b0FycmF5KClbdGhpcy5fc2VsZWN0ZWRJbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKG5ld1RhYikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBlcmZvcm1TZWxlY3Rpb24obmV3VGFiKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGVJbmRpY2F0b3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX25nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaGFzQ29udGVudFRhYnMgJiYgdGhpcy5fc2VsZWN0ZWRJbmRleCA+PSAwICYmIHRoaXMuX3NlbGVjdGVkSW5kZXggPCB0aGlzLnRhYnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdUYWIgPSB0aGlzLnRhYnMudG9BcnJheSgpW3RoaXMuX3NlbGVjdGVkSW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1Db250ZW50QW5pbWF0aW9uKG5ld1RhYiwgMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyLm9ic2VydmUodGhpcy50YWJzQ29udGFpbmVyLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9ncm91cENoYW5nZXMkID0gdGhpcy5ncm91cHMuY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXNldFNlbGVjdGlvbk9uQ29sbGVjdGlvbkNoYW5nZWQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuX2dyb3VwQ2hhbmdlcyQpIHtcbiAgICAgICAgICAgIHRoaXMuX2dyb3VwQ2hhbmdlcyQudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fcmVzaXplT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX25nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHJlc2V0U2VsZWN0aW9uT25Db2xsZWN0aW9uQ2hhbmdlZCgpOiB2b2lkIHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUYWIgPSB0aGlzLnRhYnMudG9BcnJheSgpW3RoaXMuc2VsZWN0ZWRJbmRleF07XG4gICAgICAgICAgICBpZiAoY3VycmVudFRhYikge1xuICAgICAgICAgICAgICAgIHRoaXMucGVyZm9ybVNlbGVjdGlvbkNoYW5nZShjdXJyZW50VGFiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5zZWxlY3RlZEluZGV4ID49IHRoaXMudGFicy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlcmZvcm1TZWxlY3Rpb25DaGFuZ2UodGhpcy50YWJzLmxhc3QpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVJbmRpY2F0b3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzY3JvbGwoc2Nyb2xsUmlnaHQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICAgICAgY29uc3QgdGFic0FycmF5ID0gdGhpcy50YWJzLnRvQXJyYXkoKTtcbiAgICAgICAgZm9yIChjb25zdCB0YWIgb2YgdGFic0FycmF5KSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGFiLm5hdGl2ZVRhYkl0ZW0ubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIGlmIChzY3JvbGxSaWdodCkge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50Lm9mZnNldFdpZHRoICsgZWxlbWVudC5vZmZzZXRMZWZ0ID4gdGhpcy52aWV3UG9ydC5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoICsgdGhpcy5vZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxFbGVtZW50KGVsZW1lbnQsIHNjcm9sbFJpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5vZmZzZXRXaWR0aCArIGVsZW1lbnQub2Zmc2V0TGVmdCA+PSB0aGlzLm9mZnNldCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbEVsZW1lbnQoZWxlbWVudCwgc2Nyb2xsUmlnaHQpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHBlcmZvcm1TZWxlY3Rpb25DaGFuZ2UobmV3VGFiOiBJZ3hUYWJJdGVtQmFzZSk6IHZvaWQge1xuICAgICAgICBjb25zdCBvbGRUYWIgPSB0aGlzLnNlbGVjdGVkVGFiSXRlbTtcbiAgICAgICAgaWYgKG9sZFRhYikge1xuICAgICAgICAgICAgdGhpcy5wZXJmb3JtRGVzZWxlY3Rpb24ob2xkVGFiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmV3VGFiKSB7XG4gICAgICAgICAgICB0aGlzLnBlcmZvcm1TZWxlY3Rpb24obmV3VGFiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIG5vIG5ldyBzZWxlY3RlZCB0YWIgaGlkZSB0aGUgc2VsZWN0aW9uIGluZGljYXRvclxuICAgICAgICAgICAgdGhpcy5oaWRlSW5kaWNhdG9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWxlY3RlZEluZGV4Q2hhbmdlLmVtaXQodGhpcy5fc2VsZWN0ZWRJbmRleCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwZXJmb3JtRGVzZWxlY3Rpb24ob2xkVGFiOiBJZ3hUYWJJdGVtQmFzZSk6IHZvaWQge1xuICAgICAgICBvbGRUYWIuc2V0U2VsZWN0ZWRJbnRlcm5hbChmYWxzZSk7XG4gICAgICAgIGNvbnN0IG9sZFRhYlJlbGF0ZWRHcm91cCA9IHRoaXMuZ3JvdXBzLnRvQXJyYXkoKVtvbGRUYWIuaW5kZXhdO1xuICAgICAgICBpZiAob2xkVGFiUmVsYXRlZEdyb3VwKSB7XG4gICAgICAgICAgICBvbGRUYWJSZWxhdGVkR3JvdXAuc2V0U2VsZWN0ZWRJbnRlcm5hbChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2VsZWN0ZWRJbmRleCA9IC0xO1xuICAgICAgICB0aGlzLm9uVGFiSXRlbURlc2VsZWN0ZWQuZW1pdCh7IHRhYjogb2xkVGFiLCBncm91cDogb2xkVGFiUmVsYXRlZEdyb3VwIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgcGVyZm9ybVNlbGVjdGlvbihuZXdUYWI6IElneFRhYkl0ZW1CYXNlKTogdm9pZCB7XG4gICAgICAgIG5ld1RhYi5zZXRTZWxlY3RlZEludGVybmFsKHRydWUpO1xuICAgICAgICB0aGlzLl9zZWxlY3RlZEluZGV4ID0gbmV3VGFiLmluZGV4O1xuXG4gICAgICAgIGxldCBuZXdUYWJSZWxhdGVkR3JvdXAgPSBudWxsO1xuICAgICAgICBpZiAoIXRoaXMuaGFzQ29udGVudFRhYnMgJiYgdGhpcy5ncm91cHMpIHtcbiAgICAgICAgICAgIG5ld1RhYlJlbGF0ZWRHcm91cCA9IHRoaXMuZ3JvdXBzLnRvQXJyYXkoKVtuZXdUYWIuaW5kZXhdO1xuICAgICAgICAgICAgaWYgKG5ld1RhYlJlbGF0ZWRHcm91cCkge1xuICAgICAgICAgICAgICAgIG5ld1RhYlJlbGF0ZWRHcm91cC5zZXRTZWxlY3RlZEludGVybmFsKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vblRhYkl0ZW1TZWxlY3RlZC5lbWl0KHsgdGFiOiBuZXdUYWIsIGdyb3VwOiBuZXdUYWJSZWxhdGVkR3JvdXAgfSk7XG5cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIC8vIGJyaW5nIHRoZSBuZXcgc2VsZWN0ZWQgdGFiIGludG8gdmlldyBpZiBpdCBpcyBub3RcbiAgICAgICAgICAgIHRoaXMuYnJpbmdOZXdUYWJJbnRvVmlldyhuZXdUYWIpO1xuICAgICAgICAgICAgLy8gYW5pbWF0ZSB0aGUgbmV3IHNlbGVjdGlvbiBpbmRpY2F0b3JcbiAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtSW5kaWNhdG9yQW5pbWF0aW9uKG5ld1RhYi5uYXRpdmVUYWJJdGVtLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgLy8gYW5pbWF0ZSB0aGUgbmV3IHRhYidzIGdyb3VwIGNvbnRlbnRcbiAgICAgICAgICAgIGlmICghdGhpcy5oYXNDb250ZW50VGFicykge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNmb3JtQ29udGVudEFuaW1hdGlvbihuZXdUYWIsIDAuMik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgYnJpbmdOZXdUYWJJbnRvVmlldyhuZXdUYWI6IElneFRhYkl0ZW1CYXNlKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHRhYk5hdGl2ZUVsZW1lbnQgPSBuZXdUYWIubmF0aXZlVGFiSXRlbS5uYXRpdmVFbGVtZW50O1xuXG4gICAgICAgIC8vIFNjcm9sbCBsZWZ0IGlmIHRoZXJlIGlzIG5lZWRcbiAgICAgICAgaWYgKHRhYk5hdGl2ZUVsZW1lbnQub2Zmc2V0TGVmdCA8IHRoaXMub2Zmc2V0KSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEVsZW1lbnQodGFiTmF0aXZlRWxlbWVudCwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2Nyb2xsIHJpZ2h0IGlmIHRoZXJlIGlzIG5lZWRcbiAgICAgICAgY29uc3Qgdmlld1BvcnRPZmZzZXRXaWR0aCA9IHRoaXMudmlld1BvcnQubmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICAgICAgY29uc3QgZGVsdGEgPSAodGFiTmF0aXZlRWxlbWVudC5vZmZzZXRMZWZ0ICsgdGFiTmF0aXZlRWxlbWVudC5vZmZzZXRXaWR0aCkgLSAodmlld1BvcnRPZmZzZXRXaWR0aCArIHRoaXMub2Zmc2V0KTtcblxuICAgICAgICAvLyBGaXggZm9yIElFIDExLCBhIGRpZmZlcmVuY2UgaXMgYWNjdW11bGF0ZWQgZnJvbSB0aGUgd2lkdGhzIGNhbGN1bGF0aW9uc1xuICAgICAgICBpZiAoZGVsdGEgPiAxKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbEVsZW1lbnQodGFiTmF0aXZlRWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgLy8gYW5pbWF0aW9uIGZvciB0aGUgbmV3IHBhbmVsL2dyb3VwIChub3QgbmVlZGVkIGZvciB0YWIgb25seSBtb2RlKVxuICAgIHB1YmxpYyB0cmFuc2Zvcm1Db250ZW50QW5pbWF0aW9uKHRhYjogSWd4VGFiSXRlbUJhc2UsIGR1cmF0aW9uOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgY29udGVudE9mZnNldCA9IHRoaXMudGFic0NvbnRhaW5lci5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoICogdGFiLmluZGV4O1xuICAgICAgICB0aGlzLmNvbnRlbnRzQ29udGFpbmVyLm5hdGl2ZUVsZW1lbnQuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gZHVyYXRpb24gPiAwID8gYCR7ZHVyYXRpb259c2AgOiAnaW5pdGlhbCc7XG4gICAgICAgIHRoaXMuY29udGVudHNDb250YWluZXIubmF0aXZlRWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7LWNvbnRlbnRPZmZzZXR9cHgpYDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHRyYW5zZm9ybUluZGljYXRvckFuaW1hdGlvbihlbGVtZW50OiBIVE1MRWxlbWVudCwgZHVyYXRpb24gPSAwLjMpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRJbmRpY2F0b3IpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRJbmRpY2F0b3IubmF0aXZlRWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGljYXRvci5uYXRpdmVFbGVtZW50LnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9IGR1cmF0aW9uID4gMCA/IGAke2R1cmF0aW9ufXNgIDogJ2luaXRpYWwnO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEluZGljYXRvci5uYXRpdmVFbGVtZW50LnN0eWxlLndpZHRoID0gYCR7ZWxlbWVudC5vZmZzZXRXaWR0aH1weGA7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kaWNhdG9yLm5hdGl2ZUVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gYHRyYW5zbGF0ZSgke2VsZW1lbnQub2Zmc2V0TGVmdH1weClgO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGhpZGVJbmRpY2F0b3IoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkSW5kaWNhdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkSW5kaWNhdG9yLm5hdGl2ZUVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICB9XG4gICAgfVxuXG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5ATmdNb2R1bGUoe1xuICAgIGRlY2xhcmF0aW9uczogW0lneFRhYnNDb21wb25lbnQsXG4gICAgICAgIElneFRhYnNHcm91cENvbXBvbmVudCxcbiAgICAgICAgSWd4VGFiSXRlbUNvbXBvbmVudCxcbiAgICAgICAgSWd4VGFiSXRlbVRlbXBsYXRlRGlyZWN0aXZlLFxuICAgICAgICBJZ3hSaWdodEJ1dHRvblN0eWxlRGlyZWN0aXZlLFxuICAgICAgICBJZ3hMZWZ0QnV0dG9uU3R5bGVEaXJlY3RpdmVdLFxuICAgIGV4cG9ydHM6IFtJZ3hUYWJzQ29tcG9uZW50LFxuICAgICAgICBJZ3hUYWJzR3JvdXBDb21wb25lbnQsXG4gICAgICAgIElneFRhYkl0ZW1Db21wb25lbnQsXG4gICAgICAgIElneFRhYkl0ZW1UZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICAgICAgSWd4UmlnaHRCdXR0b25TdHlsZURpcmVjdGl2ZSxcbiAgICAgICAgSWd4TGVmdEJ1dHRvblN0eWxlRGlyZWN0aXZlXSxcbiAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlLCBJZ3hCYWRnZU1vZHVsZSwgSWd4SWNvbk1vZHVsZSwgSWd4UmlwcGxlTW9kdWxlXVxufSlcblxuZXhwb3J0IGNsYXNzIElneFRhYnNNb2R1bGUge1xufVxuIl19