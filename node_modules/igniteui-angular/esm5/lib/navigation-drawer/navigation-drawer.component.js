/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Component, ContentChild, ElementRef, EventEmitter, HostBinding, Inject, Input, Optional, Output, Renderer, ViewChild } from '@angular/core';
import { fromEvent, interval } from 'rxjs';
import { debounce } from 'rxjs/operators';
import { IgxNavigationService } from '../core/navigation';
import { HammerGesturesManager } from '../core/touch';
import { IgxNavDrawerMiniTemplateDirective, IgxNavDrawerTemplateDirective } from './navigation-drawer.directives';
import { PlatformUtil } from '../core/utils';
/** @type {?} */
var NEXT_ID = 0;
/**
 * **Ignite UI for Angular Navigation Drawer** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/navdrawer.html)
 *
 * The Ignite UI Navigation Drawer is a collapsible side navigation container commonly used in combination with the Navbar.
 *
 * Example:
 * ```html
 * <igx-nav-drawer id="navigation" [isOpen]="true">
 *   <ng-template igxDrawer>
 *     <nav>
 *       <span igxDrawerItem [isHeader]="true">Email</span>
 *       <span igxDrawerItem igxRipple>Inbox</span>
 *       <span igxDrawerItem igxRipple>Deleted</span>
 *       <span igxDrawerItem igxRipple>Sent</span>
 *     </nav>
 *   </ng-template>
 * </igx-nav-drawer>
 * ```
 */
var IgxNavigationDrawerComponent = /** @class */ (function () {
    function IgxNavigationDrawerComponent(elementRef, _state, renderer, _touchManager, platformUtil) {
        var _this = this;
        this.elementRef = elementRef;
        this._state = _state;
        this.renderer = renderer;
        this._touchManager = _touchManager;
        this.platformUtil = platformUtil;
        this._isOpen = false;
        /**
         * @hidden \@internal
         */
        this.cssClass = true;
        /**
         * ID of the component
         *
         * ```typescript
         * // get
         * let myNavDrawerId = this.navdrawer.id;
         * ```
         *
         * ```html
         * <!--set-->
         *  <igx-nav-drawer id='navdrawer'></igx-nav-drawer>
         * ```
         */
        this.id = "igx-nav-drawer-" + NEXT_ID++;
        /**
         * Position of the Navigation Drawer. Can be "left"(default) or "right".
         *
         * ```typescript
         * // get
         * let myNavDrawerPosition = this.navdrawer.position;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [position]="'left'"></igx-nav-drawer>
         * ```
         */
        this.position = 'left';
        /**
         * Enables the use of touch gestures to manipulate the drawer:
         * - swipe/pan from edge to open, swipe-toggle and pan-drag.
         *
         * ```typescript
         * // get
         * let gesturesEnabled = this.navdrawer.enableGestures;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [enableGestures]='true'></igx-nav-drawer>
         * ```
         */
        this.enableGestures = true;
        /**
         * @hidden
         */
        this.isOpenChange = new EventEmitter();
        /**
         * When pinned the drawer is relatively positioned instead of sitting above content.
         * May require additional layout styling.
         *
         * ```typescript
         * // get
         * let navDrawerIsPinned = this.navdrawer.pin;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [pin]='false'></igx-nav-drawer>
         * ```
         */
        this.pin = false;
        /**
         * Minimum device width required for automatic pin to be toggled.
         * Default is 1024, can be set to a falsy value to disable this behavior.
         *
         * ```typescript
         * // get
         * let navDrawerPinTreshold = this.navdrawer.pinThreshold;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [pinTreshold]='1024'></igx-nav-drawer>
         * ```
         */
        this.pinThreshold = 1024;
        /**
         * Width of the drawer in its open state. Defaults to "280px".
         *
         * ```typescript
         * // get
         * let navDrawerWidth = this.navdrawer.width;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [width]="'228px'"></igx-nav-drawer>
         * ```
         */
        this.width = '280px';
        /**
         * Width of the drawer in its mini state. Defaults to 68px.
         *
         * ```typescript
         * // get
         * let navDrawerMiniWidth = this.navdrawer.miniWidth;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [miniWidth]="'34px'"></igx-nav-drawer>
         * ```
         */
        this.miniWidth = '68px';
        /**
         * Pinned state change output for two-way binding.
         *
         * ```html
         * <igx-nav-drawer [(pin)]='isPinned'></igx-nav-drawer>
         * ```
         */
        this.pinChange = new EventEmitter(true);
        /**
         * Event fired as the Navigation Drawer is about to open.
         *
         * ```html
         *  <igx-nav-drawer (opening)='onOpening()'></igx-nav-drawer>
         * ```
         */
        this.opening = new EventEmitter();
        /**
         * Event fired when the Navigation Drawer has opened.
         *
         * ```html
         * <igx-nav-drawer (opened)='onOpened()'></igx-nav-drawer>
         * ```
         */
        this.opened = new EventEmitter();
        /**
         * Event fired as the Navigation Drawer is about to close.
         *
         * ```html
         * <igx-nav-drawer (closing)='onClosing()'></igx-nav-drawer>
         * ```
         */
        this.closing = new EventEmitter();
        /**
         * Event fired when the Navigation Drawer has closed.
         *
         * ```html
         * <igx-nav-drawer (closed)='onClosed()'></igx-nav-drawer>
         * ```
         */
        this.closed = new EventEmitter();
        this._gesturesAttached = false;
        this._widthCache = { width: null, miniWidth: null, windowWidth: null };
        this.css = {
            drawer: 'igx-nav-drawer__aside',
            mini: 'igx-nav-drawer__aside--mini',
            overlay: 'igx-nav-drawer__overlay',
            styleDummy: 'igx-nav-drawer__style-dummy'
        };
        /**
         * Pan animation properties
         */
        this._panning = false;
        this._maxEdgeZone = 50;
        this.checkPinThreshold = function (evt) {
            if (!_this.platformUtil.isBrowser) {
                return;
            }
            /** @type {?} */
            var windowWidth;
            if (_this.pinThreshold) {
                windowWidth = _this.getWindowWidth();
                if (evt && _this._widthCache.windowWidth === windowWidth) {
                    return;
                }
                _this._widthCache.windowWidth = windowWidth;
                if (!_this.pin && windowWidth >= _this.pinThreshold) {
                    _this.pin = true;
                    _this.pinChange.emit(true);
                }
                else if (_this.pin && windowWidth < _this.pinThreshold) {
                    _this.pin = false;
                    _this.pinChange.emit(false);
                }
            }
        };
        this.swipe = function (evt) {
            // TODO: Could also force input type: http://stackoverflow.com/a/27108052
            if (!_this.enableGestures || evt.pointerType !== 'touch') {
                return;
            }
            // HammerJS swipe is horizontal-only by default, don't check deltaY
            /** @type {?} */
            var deltaX;
            /** @type {?} */
            var startPosition;
            if (_this.position === 'right') {
                // when on the right use inverse of deltaX
                deltaX = -evt.deltaX;
                startPosition = _this.getWindowWidth() - (evt.center.x + evt.distance);
            }
            else {
                deltaX = evt.deltaX;
                startPosition = evt.center.x - evt.distance;
            }
            // only accept closing swipe (ignoring minEdgeZone) when the drawer is expanded:
            if ((_this.isOpen && deltaX < 0) ||
                // positive deltaX from the edge:
                (deltaX > 0 && startPosition < _this.maxEdgeZone)) {
                _this.toggle();
            }
        };
        this.panstart = function (evt) {
            if (!_this.enableGestures || _this.pin || evt.pointerType !== 'touch') {
                return;
            }
            /** @type {?} */
            var startPosition = _this.position === 'right' ? _this.getWindowWidth() - (evt.center.x + evt.distance)
                : evt.center.x - evt.distance;
            // cache width during animation, flag to allow further handling
            if (_this.isOpen || (startPosition < _this.maxEdgeZone)) {
                _this._panning = true;
                _this._panStartWidth = _this.getExpectedWidth(!_this.isOpen);
                _this._panLimit = _this.getExpectedWidth(_this.isOpen);
                _this.renderer.setElementClass(_this.overlay, 'panning', true);
                _this.renderer.setElementClass(_this.drawer, 'panning', true);
            }
        };
        this.pan = function (evt) {
            // TODO: input.deltaX = prevDelta.x + (center.x - offset.x);
            // get actual delta (not total session one) from event?
            // pan WILL also fire after a full swipe, only resize on flag
            if (!_this._panning) {
                return;
            }
            /** @type {?} */
            var right = _this.position === 'right';
            // when on the right use inverse of deltaX
            /** @type {?} */
            var deltaX = right ? -evt.deltaX : evt.deltaX;
            /** @type {?} */
            var visibleWidth;
            /** @type {?} */
            var newX;
            /** @type {?} */
            var percent;
            visibleWidth = _this._panStartWidth + deltaX;
            if (_this.isOpen && deltaX < 0) {
                // when visibleWidth hits limit - stop animating
                if (visibleWidth <= _this._panLimit) {
                    return;
                }
                if (_this.hasAnimateWidth) {
                    percent = (visibleWidth - _this._panLimit) / (_this._panStartWidth - _this._panLimit);
                    newX = visibleWidth;
                }
                else {
                    percent = visibleWidth / _this._panStartWidth;
                    newX = evt.deltaX;
                }
                _this.setXSize(newX, percent.toPrecision(2));
            }
            else if (!_this.isOpen && deltaX > 0) {
                // when visibleWidth hits limit - stop animating
                if (visibleWidth >= _this._panLimit) {
                    return;
                }
                if (_this.hasAnimateWidth) {
                    percent = (visibleWidth - _this._panStartWidth) / (_this._panLimit - _this._panStartWidth);
                    newX = visibleWidth;
                }
                else {
                    percent = visibleWidth / _this._panLimit;
                    newX = (_this._panLimit - visibleWidth) * (right ? 1 : -1);
                }
                _this.setXSize(newX, percent.toPrecision(2));
            }
        };
        this.panEnd = function (evt) {
            if (_this._panning) {
                /** @type {?} */
                var deltaX = _this.position === 'right' ? -evt.deltaX : evt.deltaX;
                /** @type {?} */
                var visibleWidth = _this._panStartWidth + deltaX;
                _this.resetPan();
                // check if pan brought the drawer to 50%
                if (_this.isOpen && visibleWidth <= _this._panStartWidth / 2) {
                    _this.close();
                }
                else if (!_this.isOpen && visibleWidth >= _this._panLimit / 2) {
                    _this.open();
                }
                _this._panStartWidth = null;
            }
        };
        this.toggleOpenedEvent = function (evt) {
            _this.elementRef.nativeElement.removeEventListener('transitionend', _this.toggleOpenedEvent, false);
            _this.opened.emit();
        };
        this.toggleClosedEvent = function (evt) {
            _this.elementRef.nativeElement.removeEventListener('transitionend', _this.toggleClosedEvent, false);
            _this.closed.emit();
        };
    }
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "isOpen", {
        /**
         * State of the drawer.
         *
         * ```typescript
         * // get
         * let navDrawerIsOpen = this.navdrawer.isOpen;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [isOpen]='false'></igx-nav-drawer>
         * ```
         *
         * Two-way data binding.
         * ```html
         * <!--set-->
         * <igx-nav-drawer [(isOpen)]='model.isOpen'></igx-nav-drawer>
         * ```
         */
        get: /**
         * State of the drawer.
         *
         * ```typescript
         * // get
         * let navDrawerIsOpen = this.navdrawer.isOpen;
         * ```
         *
         * ```html
         * <!--set-->
         * <igx-nav-drawer [isOpen]='false'></igx-nav-drawer>
         * ```
         *
         * Two-way data binding.
         * ```html
         * <!--set-->
         * <igx-nav-drawer [(isOpen)]='model.isOpen'></igx-nav-drawer>
         * ```
         * @return {?}
         */
        function () {
            return this._isOpen;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._isOpen = value;
            this.isOpenChange.emit(this._isOpen);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "element", {
        /**
         * Returns nativeElement of the component.
         *
         * @hidden
         */
        get: /**
         * Returns nativeElement of the component.
         *
         * @hidden
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "template", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            if (this.miniTemplate && !this.isOpen) {
                return this.miniTemplate.template;
            }
            else if (this.contentTemplate) {
                return this.contentTemplate.template;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "miniTemplate", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this._miniTemplate;
        },
        /**
         * @hidden
         */
        set: /**
         * @hidden
         * @param {?} v
         * @return {?}
         */
        function (v) {
            if (!this.isOpen) {
                this.setDrawerWidth(v ? this.miniWidth : '');
            }
            this._miniTemplate = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "flexWidth", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            if (!this.pin) {
                return '0px';
            }
            if (this.isOpen) {
                return this.width;
            }
            if (this.miniTemplate && this.miniWidth) {
                return this.miniWidth;
            }
            return '0px';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "isPinnedRight", {
        /** @hidden */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.pin && this.position === 'right' ? '1' : '0';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "drawer", {
        /**
          * @hidden
          */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this._drawer.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "overlay", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this._overlay.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "styleDummy", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this._styleDummy.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "hasAnimateWidth", {
        /**
         * Property to decide whether to change width or translate the drawer from pan gesture.
         *
         * @hidden
         */
        get: /**
         * Property to decide whether to change width or translate the drawer from pan gesture.
         *
         * @hidden
         * @return {?}
         */
        function () {
            return this.pin || !!this.miniTemplate;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "maxEdgeZone", {
        /**
         * Used for touch gestures (swipe and pan).
         * Defaults to 50 (in px) and is extended to at least 110% of the mini template width if available.
         *
         * @hidden
         */
        get: /**
         * Used for touch gestures (swipe and pan).
         * Defaults to 50 (in px) and is extended to at least 110% of the mini template width if available.
         *
         * @hidden
         * @return {?}
         */
        function () {
            return this._maxEdgeZone;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "expectedWidth", {
        /**
         * Gets the Drawer width for specific state.
         * Will attempt to evaluate requested state and cache.
         *
         *
         * @hidden
         */
        get: /**
         * Gets the Drawer width for specific state.
         * Will attempt to evaluate requested state and cache.
         *
         *
         * @hidden
         * @return {?}
         */
        function () {
            return this.getExpectedWidth(false);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "expectedMiniWidth", {
        /**
         * Get the Drawer mini width for specific state.
         * Will attempt to evaluate requested state and cache.
         *
         * @hidden
         */
        get: /**
         * Get the Drawer mini width for specific state.
         * Will attempt to evaluate requested state and cache.
         *
         * @hidden
         * @return {?}
         */
        function () {
            return this.getExpectedWidth(true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "touchManager", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this._touchManager;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxNavigationDrawerComponent.prototype, "state", {
        /**
         * Exposes optional navigation service
         *
         * @hidden
         */
        get: /**
         * Exposes optional navigation service
         *
         * @hidden
         * @return {?}
         */
        function () {
            return this._state;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.ngOnInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        // DOM and @Input()-s initialized
        if (this._state) {
            this._state.add(this.id, this);
        }
        if (this.isOpen) {
            this.setDrawerWidth(this.width);
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.ngAfterContentInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        // wait for template and ng-content to be ready
        this.updateEdgeZone();
        this.checkPinThreshold();
        this.ensureEvents();
        // TODO: apply platform-safe Ruler from http://plnkr.co/edit/81nWDyreYMzkunihfRgX?p=preview
        // (https://github.com/angular/angular/issues/6515), blocked by https://github.com/angular/angular/issues/6904
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        this._touchManager.destroy();
        if (this._state) {
            this._state.remove(this.id);
        }
        if (this._resizeObserver) {
            this._resizeObserver.unsubscribe();
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} changes
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.ngOnChanges = /**
     * @hidden
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        // simple settings can come from attribute set (rather than binding), make sure boolean props are converted
        if (changes.enableGestures && changes.enableGestures.currentValue !== undefined) {
            this.enableGestures = !!(this.enableGestures && this.enableGestures.toString() === 'true');
            this.ensureEvents();
        }
        if (changes.pin && changes.pin.currentValue !== undefined) {
            this.pin = !!(this.pin && this.pin.toString() === 'true');
            if (this.pin) {
                this._touchManager.destroy();
                this._gesturesAttached = false;
            }
            else {
                this.ensureEvents();
            }
        }
        if (changes.pinThreshold) {
            if (this.pinThreshold) {
                this.ensureEvents();
                this.checkPinThreshold();
            }
        }
        if (changes.width && this.isOpen) {
            this.setDrawerWidth(changes.width.currentValue);
        }
        if (changes.miniWidth) {
            if (!this.isOpen) {
                this.setDrawerWidth(changes.miniWidth.currentValue);
            }
            this.updateEdgeZone();
        }
    };
    /**
     * Toggle the open state of the Navigation Drawer.
     *
     * ```typescript
     * this.navdrawer.toggle();
     * ```
     */
    /**
     * Toggle the open state of the Navigation Drawer.
     *
     * ```typescript
     * this.navdrawer.toggle();
     * ```
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.toggle = /**
     * Toggle the open state of the Navigation Drawer.
     *
     * ```typescript
     * this.navdrawer.toggle();
     * ```
     * @return {?}
     */
    function () {
        if (this.isOpen) {
            this.close();
        }
        else {
            this.open();
        }
    };
    /**
     * Open the Navigation Drawer. Has no effect if already opened.
     *
     * ```typescript
     * this.navdrawer.open();
     * ```
     */
    /**
     * Open the Navigation Drawer. Has no effect if already opened.
     *
     * ```typescript
     * this.navdrawer.open();
     * ```
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.open = /**
     * Open the Navigation Drawer. Has no effect if already opened.
     *
     * ```typescript
     * this.navdrawer.open();
     * ```
     * @return {?}
     */
    function () {
        if (this._panning) {
            this.resetPan();
        }
        if (this.isOpen) {
            return;
        }
        this.opening.emit();
        this.isOpen = true;
        // TODO: Switch to animate API when available
        // var animationCss = this.animate.css();
        //     animationCss
        //         .setStyles({'width':'50px'}, {'width':'400px'})
        //         .start(this.elementRef.nativeElement)
        //         .onComplete(() => animationCss.setToStyles({'width':'auto'}).start(this.elementRef.nativeElement));
        this.elementRef.nativeElement.addEventListener('transitionend', this.toggleOpenedEvent, false);
        this.setDrawerWidth(this.width);
    };
    /**
     * Close the Navigation Drawer. Has no effect if already closed.
     *
     * ```typescript
     * this.navdrawer.close();
     * ```
     */
    /**
     * Close the Navigation Drawer. Has no effect if already closed.
     *
     * ```typescript
     * this.navdrawer.close();
     * ```
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.close = /**
     * Close the Navigation Drawer. Has no effect if already closed.
     *
     * ```typescript
     * this.navdrawer.close();
     * ```
     * @return {?}
     */
    function () {
        if (this._panning) {
            this.resetPan();
        }
        if (!this.isOpen) {
            return;
        }
        this.closing.emit();
        this.isOpen = false;
        this.setDrawerWidth(this.miniTemplate ? this.miniWidth : '');
        this.elementRef.nativeElement.addEventListener('transitionend', this.toggleClosedEvent, false);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} value
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.set_maxEdgeZone = /**
     * @hidden
     * @protected
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this._maxEdgeZone = value;
    };
    /**
     * Get the Drawer width for specific state. Will attempt to evaluate requested state and cache.
     *
     * @hidden
     * @param [mini] - Request mini width instead
     */
    /**
     * Get the Drawer width for specific state. Will attempt to evaluate requested state and cache.
     *
     * @hidden
     * @protected
     * @param {?=} mini
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.getExpectedWidth = /**
     * Get the Drawer width for specific state. Will attempt to evaluate requested state and cache.
     *
     * @hidden
     * @protected
     * @param {?=} mini
     * @return {?}
     */
    function (mini) {
        if (mini) {
            if (!this.miniTemplate) {
                return 0;
            }
            if (this.miniWidth) {
                return parseFloat(this.miniWidth);
            }
            else {
                // if (!this.isOpen) { // This WON'T work due to transition timings...
                //     return this.elementRef.nativeElement.children[1].offsetWidth;
                // } else {
                if (this._widthCache.miniWidth === null) {
                    // force class for width calc. TODO?
                    this.renderer.setElementClass(this.styleDummy, this.css.drawer, true);
                    this.renderer.setElementClass(this.styleDummy, this.css.mini, true);
                    this._widthCache.miniWidth = this.styleDummy.offsetWidth;
                    this.renderer.setElementClass(this.styleDummy, this.css.drawer, false);
                    this.renderer.setElementClass(this.styleDummy, this.css.mini, false);
                }
                return this._widthCache.miniWidth;
            }
        }
        else {
            if (this.width) {
                return parseFloat(this.width);
            }
            else {
                if (this._widthCache.width === null) {
                    // force class for width calc. TODO?
                    this.renderer.setElementClass(this.styleDummy, this.css.drawer, true);
                    this._widthCache.width = this.styleDummy.offsetWidth;
                    this.renderer.setElementClass(this.styleDummy, this.css.drawer, false);
                }
                return this._widthCache.width;
            }
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.getWindowWidth = /**
     * @private
     * @return {?}
     */
    function () {
        return (window.innerWidth > 0) ? window.innerWidth : screen.width;
    };
    /**
     * Sets the drawer width.
     */
    /**
     * Sets the drawer width.
     * @private
     * @param {?} width
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.setDrawerWidth = /**
     * Sets the drawer width.
     * @private
     * @param {?} width
     * @return {?}
     */
    function (width) {
        var _this = this;
        if (this.platformUtil.isBrowser) {
            requestAnimationFrame(function () {
                if (_this.drawer) {
                    _this.renderer.setElementStyle(_this.drawer, 'width', width);
                }
            });
        }
        else {
            this.renderer.setElementStyle(this.drawer, 'width', width);
        }
    };
    /**
     * Get current Drawer width.
     */
    /**
     * Get current Drawer width.
     * @private
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.getDrawerWidth = /**
     * Get current Drawer width.
     * @private
     * @return {?}
     */
    function () {
        return this.drawer.offsetWidth;
    };
    /**
     * @private
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.ensureEvents = /**
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        // set listeners for swipe/pan only if needed, but just once
        if (this.enableGestures && !this.pin && !this._gesturesAttached) {
            // Built-in manager handler(L20887) causes endless loop and max stack exception.
            // https://github.com/angular/angular/issues/6993
            // Use ours for now (until beta.10):
            // this.renderer.listen(document, "swipe", this.swipe);
            this._touchManager.addGlobalEventListener('document', 'swipe', this.swipe);
            this._gesturesAttached = true;
            // this.renderer.listen(document, "panstart", this.panstart);
            // this.renderer.listen(document, "pan", this.pan);
            this._touchManager.addGlobalEventListener('document', 'panstart', this.panstart);
            this._touchManager.addGlobalEventListener('document', 'panmove', this.pan);
            this._touchManager.addGlobalEventListener('document', 'panend', this.panEnd);
        }
        if (!this._resizeObserver && this.platformUtil.isBrowser) {
            this._resizeObserver = fromEvent(window, 'resize').pipe(debounce(function () { return interval(150); }))
                .subscribe(function (value) {
                _this.checkPinThreshold(value);
            });
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.updateEdgeZone = /**
     * @private
     * @return {?}
     */
    function () {
        /** @type {?} */
        var maxValue;
        if (this.miniTemplate) {
            maxValue = Math.max(this._maxEdgeZone, this.getExpectedWidth(true) * 1.1);
            this.set_maxEdgeZone(maxValue);
        }
    };
    /**
     * @private
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.resetPan = /**
     * @private
     * @return {?}
     */
    function () {
        this._panning = false;
        /* styles fail to apply when set on parent due to extra attributes, prob ng bug */
        this.renderer.setElementClass(this.overlay, 'panning', false);
        this.renderer.setElementClass(this.drawer, 'panning', false);
        this.setXSize(0, '');
    };
    /**
     * Sets the absolute position or width in case the drawer doesn't change position.
     * @param x the number pixels to translate on the X axis or the width to set. 0 width will clear the style instead.
     * @param opacity optional value to apply to the overlay
     */
    /**
     * Sets the absolute position or width in case the drawer doesn't change position.
     * @private
     * @param {?} x the number pixels to translate on the X axis or the width to set. 0 width will clear the style instead.
     * @param {?=} opacity optional value to apply to the overlay
     * @return {?}
     */
    IgxNavigationDrawerComponent.prototype.setXSize = /**
     * Sets the absolute position or width in case the drawer doesn't change position.
     * @private
     * @param {?} x the number pixels to translate on the X axis or the width to set. 0 width will clear the style instead.
     * @param {?=} opacity optional value to apply to the overlay
     * @return {?}
     */
    function (x, opacity) {
        var _this = this;
        // Angular polyfills patches window.requestAnimationFrame, but switch to DomAdapter API (TODO)
        window.requestAnimationFrame(function () {
            if (_this.hasAnimateWidth) {
                _this.renderer.setElementStyle(_this.drawer, 'width', x ? Math.abs(x) + 'px' : '');
            }
            else {
                /** @type {?} */
                var transform = x ? 'translate3d(' + x + 'px,0,0)' : '';
                _this.renderer.setElementStyle(_this.drawer, 'transform', transform);
                _this.renderer.setElementStyle(_this.drawer, '-webkit-transform', transform);
            }
            if (opacity !== undefined) {
                _this.renderer.setElementStyle(_this.overlay, 'opacity', opacity);
            }
        });
    };
    IgxNavigationDrawerComponent.decorators = [
        { type: Component, args: [{
                    providers: [HammerGesturesManager],
                    selector: 'igx-nav-drawer',
                    template: "<ng-template #defaultItemsTemplate>\n    <div igxDrawerItem [isHeader]=\"true\">Navigation Drawer</div>\n    <div igxDrawerItem> Start by adding</div>\n    <div igxDrawerItem> <code>&lt;ng-template igxDrawer&gt;</code> </div>\n    <div igxDrawerItem> And some items inside </div>\n    <div igxDrawerItem> Style with igxDrawerItem </div>\n    <div igxDrawerItem> and igxRipple directives</div>\n</ng-template>\n\n<div [hidden]=\"pin\"\n    class=\"igx-nav-drawer__overlay\"\n    [class.igx-nav-drawer__overlay--hidden]=\"!isOpen\"\n    (click)=\"close()\" #overlay>\n</div>\n<aside role=\"navigation\"\n    class=\"igx-nav-drawer__aside\"\n    [class.igx-nav-drawer__aside--collapsed]=\"!miniTemplate && !isOpen\"\n    [class.igx-nav-drawer__aside--mini]=\"miniTemplate && !isOpen\"\n    [class.igx-nav-drawer__aside--normal]=\"!miniTemplate || isOpen\"\n    [class.igx-nav-drawer__aside--pinned]=\"pin\"\n    [class.igx-nav-drawer__aside--right]=\"position == 'right'\" #aside>\n\n    <ng-container *ngTemplateOutlet=\"template || defaultItemsTemplate\"></ng-container>\n</aside>\n<div class=\"igx-nav-drawer__style-dummy\" #dummy></div>\n",
                    styles: ["\n        :host {\n            display: block;\n            height: 100%;\n        }\n    "]
                }] }
    ];
    /** @nocollapse */
    IgxNavigationDrawerComponent.ctorParameters = function () { return [
        { type: ElementRef, decorators: [{ type: Inject, args: [ElementRef,] }] },
        { type: IgxNavigationService, decorators: [{ type: Optional }] },
        { type: Renderer },
        { type: HammerGesturesManager },
        { type: PlatformUtil }
    ]; };
    IgxNavigationDrawerComponent.propDecorators = {
        cssClass: [{ type: HostBinding, args: ['class.igx-nav-drawer',] }],
        id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
        position: [{ type: Input }],
        enableGestures: [{ type: Input }],
        isOpen: [{ type: Input }],
        isOpenChange: [{ type: Output }],
        pin: [{ type: Input }],
        pinThreshold: [{ type: Input }],
        width: [{ type: Input }],
        miniWidth: [{ type: Input }],
        pinChange: [{ type: Output }],
        opening: [{ type: Output }],
        opened: [{ type: Output }],
        closing: [{ type: Output }],
        closed: [{ type: Output }],
        miniTemplate: [{ type: ContentChild, args: [IgxNavDrawerMiniTemplateDirective, { read: IgxNavDrawerMiniTemplateDirective, static: false },] }],
        contentTemplate: [{ type: ContentChild, args: [IgxNavDrawerTemplateDirective, { read: IgxNavDrawerTemplateDirective, static: false },] }],
        flexWidth: [{ type: HostBinding, args: ['style.flexBasis',] }],
        isPinnedRight: [{ type: HostBinding, args: ['style.order',] }],
        _drawer: [{ type: ViewChild, args: ['aside', { static: true },] }],
        _overlay: [{ type: ViewChild, args: ['overlay', { static: true },] }],
        _styleDummy: [{ type: ViewChild, args: ['dummy', { static: true },] }]
    };
    return IgxNavigationDrawerComponent;
}());
export { IgxNavigationDrawerComponent };
if (false) {
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype._isOpen;
    /**
     * @hidden \@internal
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.cssClass;
    /**
     * ID of the component
     *
     * ```typescript
     * // get
     * let myNavDrawerId = this.navdrawer.id;
     * ```
     *
     * ```html
     * <!--set-->
     *  <igx-nav-drawer id='navdrawer'></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.id;
    /**
     * Position of the Navigation Drawer. Can be "left"(default) or "right".
     *
     * ```typescript
     * // get
     * let myNavDrawerPosition = this.navdrawer.position;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-nav-drawer [position]="'left'"></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.position;
    /**
     * Enables the use of touch gestures to manipulate the drawer:
     * - swipe/pan from edge to open, swipe-toggle and pan-drag.
     *
     * ```typescript
     * // get
     * let gesturesEnabled = this.navdrawer.enableGestures;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-nav-drawer [enableGestures]='true'></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.enableGestures;
    /**
     * @hidden
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.isOpenChange;
    /**
     * When pinned the drawer is relatively positioned instead of sitting above content.
     * May require additional layout styling.
     *
     * ```typescript
     * // get
     * let navDrawerIsPinned = this.navdrawer.pin;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-nav-drawer [pin]='false'></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.pin;
    /**
     * Minimum device width required for automatic pin to be toggled.
     * Default is 1024, can be set to a falsy value to disable this behavior.
     *
     * ```typescript
     * // get
     * let navDrawerPinTreshold = this.navdrawer.pinThreshold;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-nav-drawer [pinTreshold]='1024'></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.pinThreshold;
    /**
     * Width of the drawer in its open state. Defaults to "280px".
     *
     * ```typescript
     * // get
     * let navDrawerWidth = this.navdrawer.width;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-nav-drawer [width]="'228px'"></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.width;
    /**
     * Width of the drawer in its mini state. Defaults to 68px.
     *
     * ```typescript
     * // get
     * let navDrawerMiniWidth = this.navdrawer.miniWidth;
     * ```
     *
     * ```html
     * <!--set-->
     * <igx-nav-drawer [miniWidth]="'34px'"></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.miniWidth;
    /**
     * Pinned state change output for two-way binding.
     *
     * ```html
     * <igx-nav-drawer [(pin)]='isPinned'></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.pinChange;
    /**
     * Event fired as the Navigation Drawer is about to open.
     *
     * ```html
     *  <igx-nav-drawer (opening)='onOpening()'></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.opening;
    /**
     * Event fired when the Navigation Drawer has opened.
     *
     * ```html
     * <igx-nav-drawer (opened)='onOpened()'></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.opened;
    /**
     * Event fired as the Navigation Drawer is about to close.
     *
     * ```html
     * <igx-nav-drawer (closing)='onClosing()'></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.closing;
    /**
     * Event fired when the Navigation Drawer has closed.
     *
     * ```html
     * <igx-nav-drawer (closed)='onClosed()'></igx-nav-drawer>
     * ```
     * @type {?}
     */
    IgxNavigationDrawerComponent.prototype.closed;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype._miniTemplate;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxNavigationDrawerComponent.prototype.contentTemplate;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype._gesturesAttached;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype._widthCache;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype._resizeObserver;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype.css;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype._drawer;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype._overlay;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype._styleDummy;
    /**
     * Pan animation properties
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype._panning;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype._panStartWidth;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype._panLimit;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype._maxEdgeZone;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype.checkPinThreshold;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype.swipe;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype.panstart;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype.pan;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype.panEnd;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype.toggleOpenedEvent;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype.toggleClosedEvent;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype.elementRef;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype._state;
    /**
     * @type {?}
     * @protected
     */
    IgxNavigationDrawerComponent.prototype.renderer;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype._touchManager;
    /**
     * @type {?}
     * @private
     */
    IgxNavigationDrawerComponent.prototype.platformUtil;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmF2aWdhdGlvbi1kcmF3ZXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vaWduaXRldWktYW5ndWxhci8iLCJzb3VyY2VzIjpbImxpYi9uYXZpZ2F0aW9uLWRyYXdlci9uYXZpZ2F0aW9uLWRyYXdlci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFFSCxTQUFTLEVBQ1QsWUFBWSxFQUNaLFVBQVUsRUFDVixZQUFZLEVBQ1osV0FBVyxFQUNYLE1BQU0sRUFDTixLQUFLLEVBSUwsUUFBUSxFQUNSLE1BQU0sRUFDTixRQUFRLEVBRVIsU0FBUyxFQUNaLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFnQixNQUFNLE1BQU0sQ0FBQztBQUN6RCxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDMUMsT0FBTyxFQUFFLG9CQUFvQixFQUFlLE1BQU0sb0JBQW9CLENBQUM7QUFDdkUsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3RELE9BQU8sRUFBRSxpQ0FBaUMsRUFBRSw2QkFBNkIsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBQ2xILE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxlQUFlLENBQUM7O0lBRXpDLE9BQU8sR0FBRyxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFxQmY7SUFxWEksc0NBQ2dDLFVBQXNCLEVBQzlCLE1BQTRCLEVBRXRDLFFBQWtCLEVBQ3BCLGFBQW9DLEVBQ3BDLFlBQTBCO1FBTnRDLGlCQU9DO1FBTitCLGVBQVUsR0FBVixVQUFVLENBQVk7UUFDOUIsV0FBTSxHQUFOLE1BQU0sQ0FBc0I7UUFFdEMsYUFBUSxHQUFSLFFBQVEsQ0FBVTtRQUNwQixrQkFBYSxHQUFiLGFBQWEsQ0FBdUI7UUFDcEMsaUJBQVksR0FBWixZQUFZLENBQWM7UUF6VzlCLFlBQU8sR0FBRyxLQUFLLENBQUM7Ozs7UUFJ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O0NBQUEsQUE5eEJELElBOHhCQztTQW54QlksNEJBQTRCOzs7Ozs7SUFPckMsK0NBQXdCOzs7OztJQUd4QixnREFDdUI7Ozs7Ozs7Ozs7Ozs7OztJQWV2QiwwQ0FDbUQ7Ozs7Ozs7Ozs7Ozs7OztJQWVuRCxnREFBa0M7Ozs7Ozs7Ozs7Ozs7Ozs7SUFnQmxDLHNEQUFzQzs7Ozs7SUFpQ3RDLG9EQUE0RDs7Ozs7Ozs7Ozs7Ozs7OztJQWdCNUQsMkNBQTRCOzs7Ozs7Ozs7Ozs7Ozs7O0lBZ0I1QixvREFBb0M7Ozs7Ozs7Ozs7Ozs7OztJQXdCcEMsNkNBQWdDOzs7Ozs7Ozs7Ozs7Ozs7SUFlaEMsaURBQW1DOzs7Ozs7Ozs7SUFTbkMsaURBQTZEOzs7Ozs7Ozs7SUFRN0QsK0NBQThDOzs7Ozs7Ozs7SUFROUMsOENBQTZDOzs7Ozs7Ozs7SUFRN0MsK0NBQThDOzs7Ozs7Ozs7SUFROUMsOENBQTZDOzs7OztJQWE3QyxxREFBeUQ7Ozs7OztJQXNCekQsdURBQ3lEOzs7OztJQTBCekQseURBQWtDOzs7OztJQUNsQyxtREFBcUk7Ozs7O0lBQ3JJLHVEQUFzQzs7Ozs7SUFDdEMsMkNBS0U7Ozs7O0lBRUYsK0NBQWtFOzs7OztJQUNsRSxnREFBcUU7Ozs7O0lBQ3JFLG1EQUFzRTs7Ozs7O0lBd0J0RSxnREFBeUI7Ozs7O0lBQ3pCLHNEQUErQjs7Ozs7SUFDL0IsaURBQTBCOzs7OztJQVcxQixvREFBMEI7Ozs7O0lBbVQxQix5REFtQkM7Ozs7O0lBRUQsNkNBdUJDOzs7OztJQUVELGdEQWdCQzs7Ozs7SUFFRCwyQ0E4Q0M7Ozs7O0lBRUQsOENBY0M7Ozs7O0lBK0JELHlEQUdDOzs7OztJQUVELHlEQUdDOzs7OztJQXZhRyxrREFBa0Q7Ozs7O0lBQ2xELDhDQUFnRDs7Ozs7SUFFaEQsZ0RBQTRCOzs7OztJQUM1QixxREFBNEM7Ozs7O0lBQzVDLG9EQUFrQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgICBDb21wb25lbnQsXG4gICAgQ29udGVudENoaWxkLFxuICAgIEVsZW1lbnRSZWYsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIEhvc3RCaW5kaW5nLFxuICAgIEluamVjdCxcbiAgICBJbnB1dCxcbiAgICBPbkNoYW5nZXMsXG4gICAgT25EZXN0cm95LFxuICAgIE9uSW5pdCxcbiAgICBPcHRpb25hbCxcbiAgICBPdXRwdXQsXG4gICAgUmVuZGVyZXIsXG4gICAgU2ltcGxlQ2hhbmdlLFxuICAgIFZpZXdDaGlsZFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGZyb21FdmVudCwgaW50ZXJ2YWwsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZGVib3VuY2UgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBJZ3hOYXZpZ2F0aW9uU2VydmljZSwgSVRvZ2dsZVZpZXcgfSBmcm9tICcuLi9jb3JlL25hdmlnYXRpb24nO1xuaW1wb3J0IHsgSGFtbWVyR2VzdHVyZXNNYW5hZ2VyIH0gZnJvbSAnLi4vY29yZS90b3VjaCc7XG5pbXBvcnQgeyBJZ3hOYXZEcmF3ZXJNaW5pVGVtcGxhdGVEaXJlY3RpdmUsIElneE5hdkRyYXdlclRlbXBsYXRlRGlyZWN0aXZlIH0gZnJvbSAnLi9uYXZpZ2F0aW9uLWRyYXdlci5kaXJlY3RpdmVzJztcbmltcG9ydCB7IFBsYXRmb3JtVXRpbCB9IGZyb20gJy4uL2NvcmUvdXRpbHMnO1xuXG5sZXQgTkVYVF9JRCA9IDA7XG4vKipcbiAqICoqSWduaXRlIFVJIGZvciBBbmd1bGFyIE5hdmlnYXRpb24gRHJhd2VyKiogLVxuICogW0RvY3VtZW50YXRpb25dKGh0dHBzOi8vd3d3LmluZnJhZ2lzdGljcy5jb20vcHJvZHVjdHMvaWduaXRlLXVpLWFuZ3VsYXIvYW5ndWxhci9jb21wb25lbnRzL25hdmRyYXdlci5odG1sKVxuICpcbiAqIFRoZSBJZ25pdGUgVUkgTmF2aWdhdGlvbiBEcmF3ZXIgaXMgYSBjb2xsYXBzaWJsZSBzaWRlIG5hdmlnYXRpb24gY29udGFpbmVyIGNvbW1vbmx5IHVzZWQgaW4gY29tYmluYXRpb24gd2l0aCB0aGUgTmF2YmFyLlxuICpcbiAqIEV4YW1wbGU6XG4gKiBgYGBodG1sXG4gKiA8aWd4LW5hdi1kcmF3ZXIgaWQ9XCJuYXZpZ2F0aW9uXCIgW2lzT3Blbl09XCJ0cnVlXCI+XG4gKiAgIDxuZy10ZW1wbGF0ZSBpZ3hEcmF3ZXI+XG4gKiAgICAgPG5hdj5cbiAqICAgICAgIDxzcGFuIGlneERyYXdlckl0ZW0gW2lzSGVhZGVyXT1cInRydWVcIj5FbWFpbDwvc3Bhbj5cbiAqICAgICAgIDxzcGFuIGlneERyYXdlckl0ZW0gaWd4UmlwcGxlPkluYm94PC9zcGFuPlxuICogICAgICAgPHNwYW4gaWd4RHJhd2VySXRlbSBpZ3hSaXBwbGU+RGVsZXRlZDwvc3Bhbj5cbiAqICAgICAgIDxzcGFuIGlneERyYXdlckl0ZW0gaWd4UmlwcGxlPlNlbnQ8L3NwYW4+XG4gKiAgICAgPC9uYXY+XG4gKiAgIDwvbmctdGVtcGxhdGU+XG4gKiA8L2lneC1uYXYtZHJhd2VyPlxuICogYGBgXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHByb3ZpZGVyczogW0hhbW1lckdlc3R1cmVzTWFuYWdlcl0sXG4gICAgc2VsZWN0b3I6ICdpZ3gtbmF2LWRyYXdlcicsXG4gICAgdGVtcGxhdGVVcmw6ICduYXZpZ2F0aW9uLWRyYXdlci5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVzOiBbYFxuICAgICAgICA6aG9zdCB7XG4gICAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgfVxuICAgIGBdXG59KVxuZXhwb3J0IGNsYXNzIElneE5hdmlnYXRpb25EcmF3ZXJDb21wb25lbnQgaW1wbGVtZW50c1xuICAgIElUb2dnbGVWaWV3LFxuICAgIE9uSW5pdCxcbiAgICBBZnRlckNvbnRlbnRJbml0LFxuICAgIE9uRGVzdHJveSxcbiAgICBPbkNoYW5nZXMge1xuXG4gICAgcHJpdmF0ZSBfaXNPcGVuID0gZmFsc2U7XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1uYXYtZHJhd2VyJylcbiAgICBwdWJsaWMgY3NzQ2xhc3MgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogSUQgb2YgdGhlIGNvbXBvbmVudFxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIGdldFxuICAgICAqIGxldCBteU5hdkRyYXdlcklkID0gdGhpcy5uYXZkcmF3ZXIuaWQ7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPCEtLXNldC0tPlxuICAgICAqICA8aWd4LW5hdi1kcmF3ZXIgaWQ9J25hdmRyYXdlcic+PC9pZ3gtbmF2LWRyYXdlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuaWQnKVxuICAgIEBJbnB1dCgpIHB1YmxpYyBpZCA9IGBpZ3gtbmF2LWRyYXdlci0ke05FWFRfSUQrK31gO1xuXG4gICAgLyoqXG4gICAgICogUG9zaXRpb24gb2YgdGhlIE5hdmlnYXRpb24gRHJhd2VyLiBDYW4gYmUgXCJsZWZ0XCIoZGVmYXVsdCkgb3IgXCJyaWdodFwiLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIGdldFxuICAgICAqIGxldCBteU5hdkRyYXdlclBvc2l0aW9uID0gdGhpcy5uYXZkcmF3ZXIucG9zaXRpb247XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPCEtLXNldC0tPlxuICAgICAqIDxpZ3gtbmF2LWRyYXdlciBbcG9zaXRpb25dPVwiJ2xlZnQnXCI+PC9pZ3gtbmF2LWRyYXdlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgcG9zaXRpb24gPSAnbGVmdCc7XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIHRoZSB1c2Ugb2YgdG91Y2ggZ2VzdHVyZXMgdG8gbWFuaXB1bGF0ZSB0aGUgZHJhd2VyOlxuICAgICAqIC0gc3dpcGUvcGFuIGZyb20gZWRnZSB0byBvcGVuLCBzd2lwZS10b2dnbGUgYW5kIHBhbi1kcmFnLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIGdldFxuICAgICAqIGxldCBnZXN0dXJlc0VuYWJsZWQgPSB0aGlzLm5hdmRyYXdlci5lbmFibGVHZXN0dXJlcztcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8IS0tc2V0LS0+XG4gICAgICogPGlneC1uYXYtZHJhd2VyIFtlbmFibGVHZXN0dXJlc109J3RydWUnPjwvaWd4LW5hdi1kcmF3ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIGVuYWJsZUdlc3R1cmVzID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIFN0YXRlIG9mIHRoZSBkcmF3ZXIuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gZ2V0XG4gICAgICogbGV0IG5hdkRyYXdlcklzT3BlbiA9IHRoaXMubmF2ZHJhd2VyLmlzT3BlbjtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8IS0tc2V0LS0+XG4gICAgICogPGlneC1uYXYtZHJhd2VyIFtpc09wZW5dPSdmYWxzZSc+PC9pZ3gtbmF2LWRyYXdlcj5cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFR3by13YXkgZGF0YSBiaW5kaW5nLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8IS0tc2V0LS0+XG4gICAgICogPGlneC1uYXYtZHJhd2VyIFsoaXNPcGVuKV09J21vZGVsLmlzT3Blbic+PC9pZ3gtbmF2LWRyYXdlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgaXNPcGVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNPcGVuO1xuICAgIH1cbiAgICBwdWJsaWMgc2V0IGlzT3Blbih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9pc09wZW4gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5pc09wZW5DaGFuZ2UuZW1pdCh0aGlzLl9pc09wZW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqQGhpZGRlblxuICAgICAqL1xuICAgIEBPdXRwdXQoKSBwdWJsaWMgaXNPcGVuQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPigpO1xuXG4gICAgLyoqXG4gICAgICogV2hlbiBwaW5uZWQgdGhlIGRyYXdlciBpcyByZWxhdGl2ZWx5IHBvc2l0aW9uZWQgaW5zdGVhZCBvZiBzaXR0aW5nIGFib3ZlIGNvbnRlbnQuXG4gICAgICogTWF5IHJlcXVpcmUgYWRkaXRpb25hbCBsYXlvdXQgc3R5bGluZy5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAvLyBnZXRcbiAgICAgKiBsZXQgbmF2RHJhd2VySXNQaW5uZWQgPSB0aGlzLm5hdmRyYXdlci5waW47XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPCEtLXNldC0tPlxuICAgICAqIDxpZ3gtbmF2LWRyYXdlciBbcGluXT0nZmFsc2UnPjwvaWd4LW5hdi1kcmF3ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIHBpbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogTWluaW11bSBkZXZpY2Ugd2lkdGggcmVxdWlyZWQgZm9yIGF1dG9tYXRpYyBwaW4gdG8gYmUgdG9nZ2xlZC5cbiAgICAgKiBEZWZhdWx0IGlzIDEwMjQsIGNhbiBiZSBzZXQgdG8gYSBmYWxzeSB2YWx1ZSB0byBkaXNhYmxlIHRoaXMgYmVoYXZpb3IuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gZ2V0XG4gICAgICogbGV0IG5hdkRyYXdlclBpblRyZXNob2xkID0gdGhpcy5uYXZkcmF3ZXIucGluVGhyZXNob2xkO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDwhLS1zZXQtLT5cbiAgICAgKiA8aWd4LW5hdi1kcmF3ZXIgW3BpblRyZXNob2xkXT0nMTAyNCc+PC9pZ3gtbmF2LWRyYXdlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKSBwdWJsaWMgcGluVGhyZXNob2xkID0gMTAyNDtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgbmF0aXZlRWxlbWVudCBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBlbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogV2lkdGggb2YgdGhlIGRyYXdlciBpbiBpdHMgb3BlbiBzdGF0ZS4gRGVmYXVsdHMgdG8gXCIyODBweFwiLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIGdldFxuICAgICAqIGxldCBuYXZEcmF3ZXJXaWR0aCA9IHRoaXMubmF2ZHJhd2VyLndpZHRoO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDwhLS1zZXQtLT5cbiAgICAgKiA8aWd4LW5hdi1kcmF3ZXIgW3dpZHRoXT1cIicyMjhweCdcIj48L2lneC1uYXYtZHJhd2VyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpIHB1YmxpYyB3aWR0aCA9ICcyODBweCc7XG5cbiAgICAvKipcbiAgICAgKiBXaWR0aCBvZiB0aGUgZHJhd2VyIGluIGl0cyBtaW5pIHN0YXRlLiBEZWZhdWx0cyB0byA2OHB4LlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIGdldFxuICAgICAqIGxldCBuYXZEcmF3ZXJNaW5pV2lkdGggPSB0aGlzLm5hdmRyYXdlci5taW5pV2lkdGg7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPCEtLXNldC0tPlxuICAgICAqIDxpZ3gtbmF2LWRyYXdlciBbbWluaVdpZHRoXT1cIiczNHB4J1wiPjwvaWd4LW5hdi1kcmF3ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KCkgcHVibGljIG1pbmlXaWR0aCA9ICc2OHB4JztcblxuICAgIC8qKlxuICAgICAqIFBpbm5lZCBzdGF0ZSBjaGFuZ2Ugb3V0cHV0IGZvciB0d28td2F5IGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1uYXYtZHJhd2VyIFsocGluKV09J2lzUGlubmVkJz48L2lneC1uYXYtZHJhd2VyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKSBwdWJsaWMgcGluQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxib29sZWFuPih0cnVlKTtcbiAgICAvKipcbiAgICAgKiBFdmVudCBmaXJlZCBhcyB0aGUgTmF2aWdhdGlvbiBEcmF3ZXIgaXMgYWJvdXQgdG8gb3Blbi5cbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiAgPGlneC1uYXYtZHJhd2VyIChvcGVuaW5nKT0nb25PcGVuaW5nKCknPjwvaWd4LW5hdi1kcmF3ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpIHB1YmxpYyBvcGVuaW5nID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIC8qKlxuICAgICAqIEV2ZW50IGZpcmVkIHdoZW4gdGhlIE5hdmlnYXRpb24gRHJhd2VyIGhhcyBvcGVuZWQuXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1uYXYtZHJhd2VyIChvcGVuZWQpPSdvbk9wZW5lZCgpJz48L2lneC1uYXYtZHJhd2VyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKSBwdWJsaWMgb3BlbmVkID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIC8qKlxuICAgICAqIEV2ZW50IGZpcmVkIGFzIHRoZSBOYXZpZ2F0aW9uIERyYXdlciBpcyBhYm91dCB0byBjbG9zZS5cbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LW5hdi1kcmF3ZXIgKGNsb3NpbmcpPSdvbkNsb3NpbmcoKSc+PC9pZ3gtbmF2LWRyYXdlcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KCkgcHVibGljIGNsb3NpbmcgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgLyoqXG4gICAgICogRXZlbnQgZmlyZWQgd2hlbiB0aGUgTmF2aWdhdGlvbiBEcmF3ZXIgaGFzIGNsb3NlZC5cbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LW5hdi1kcmF3ZXIgKGNsb3NlZCk9J29uQ2xvc2VkKCknPjwvaWd4LW5hdi1kcmF3ZXI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQE91dHB1dCgpIHB1YmxpYyBjbG9zZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHRlbXBsYXRlKCkge1xuICAgICAgICBpZiAodGhpcy5taW5pVGVtcGxhdGUgJiYgIXRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5taW5pVGVtcGxhdGUudGVtcGxhdGU7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5jb250ZW50VGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRUZW1wbGF0ZS50ZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgX21pbmlUZW1wbGF0ZTogSWd4TmF2RHJhd2VyTWluaVRlbXBsYXRlRGlyZWN0aXZlO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IG1pbmlUZW1wbGF0ZSgpOiBJZ3hOYXZEcmF3ZXJNaW5pVGVtcGxhdGVEaXJlY3RpdmUge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWluaVRlbXBsYXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKElneE5hdkRyYXdlck1pbmlUZW1wbGF0ZURpcmVjdGl2ZSwgeyByZWFkOiBJZ3hOYXZEcmF3ZXJNaW5pVGVtcGxhdGVEaXJlY3RpdmUsIHN0YXRpYzogZmFsc2UgfSlcbiAgICBwdWJsaWMgc2V0IG1pbmlUZW1wbGF0ZSh2OiBJZ3hOYXZEcmF3ZXJNaW5pVGVtcGxhdGVEaXJlY3RpdmUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgdGhpcy5zZXREcmF3ZXJXaWR0aCh2ID8gdGhpcy5taW5pV2lkdGggOiAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWluaVRlbXBsYXRlID0gdjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQENvbnRlbnRDaGlsZChJZ3hOYXZEcmF3ZXJUZW1wbGF0ZURpcmVjdGl2ZSwgeyByZWFkOiBJZ3hOYXZEcmF3ZXJUZW1wbGF0ZURpcmVjdGl2ZSwgc3RhdGljOiBmYWxzZSB9KVxuICAgIHByb3RlY3RlZCBjb250ZW50VGVtcGxhdGU6IElneE5hdkRyYXdlclRlbXBsYXRlRGlyZWN0aXZlO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUuZmxleEJhc2lzJylcbiAgICBnZXQgZmxleFdpZHRoKCkge1xuICAgICAgICBpZiAoIXRoaXMucGluKSB7XG4gICAgICAgICAgICByZXR1cm4gJzBweCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5taW5pVGVtcGxhdGUgJiYgdGhpcy5taW5pV2lkdGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1pbmlXaWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAnMHB4JztcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiAqL1xuICAgIEBIb3N0QmluZGluZygnc3R5bGUub3JkZXInKVxuICAgIGdldCBpc1Bpbm5lZFJpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5waW4gJiYgdGhpcy5wb3NpdGlvbiA9PT0gJ3JpZ2h0JyA/ICcxJyA6ICcwJztcbiAgICB9XG5cbiAgICBwcml2YXRlIF9nZXN0dXJlc0F0dGFjaGVkID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBfd2lkdGhDYWNoZTogeyB3aWR0aDogbnVtYmVyLCBtaW5pV2lkdGg6IG51bWJlciwgd2luZG93V2lkdGg6IG51bWJlciB9ID0geyB3aWR0aDogbnVsbCwgbWluaVdpZHRoOiBudWxsLCB3aW5kb3dXaWR0aDogbnVsbCB9O1xuICAgIHByaXZhdGUgX3Jlc2l6ZU9ic2VydmVyOiBTdWJzY3JpcHRpb247XG4gICAgcHJpdmF0ZSBjc3M6IHsgW25hbWU6IHN0cmluZ106IHN0cmluZzsgfSA9IHtcbiAgICAgICAgZHJhd2VyOiAnaWd4LW5hdi1kcmF3ZXJfX2FzaWRlJyxcbiAgICAgICAgbWluaTogJ2lneC1uYXYtZHJhd2VyX19hc2lkZS0tbWluaScsXG4gICAgICAgIG92ZXJsYXk6ICdpZ3gtbmF2LWRyYXdlcl9fb3ZlcmxheScsXG4gICAgICAgIHN0eWxlRHVtbXk6ICdpZ3gtbmF2LWRyYXdlcl9fc3R5bGUtZHVtbXknXG4gICAgfTtcblxuICAgIEBWaWV3Q2hpbGQoJ2FzaWRlJywgeyBzdGF0aWM6IHRydWUgfSkgcHJpdmF0ZSBfZHJhd2VyOiBFbGVtZW50UmVmO1xuICAgIEBWaWV3Q2hpbGQoJ292ZXJsYXknLCB7IHN0YXRpYzogdHJ1ZSB9KSBwcml2YXRlIF9vdmVybGF5OiBFbGVtZW50UmVmO1xuICAgIEBWaWV3Q2hpbGQoJ2R1bW15JywgeyBzdGF0aWM6IHRydWUgfSkgcHJpdmF0ZSBfc3R5bGVEdW1teTogRWxlbWVudFJlZjtcblxuICAgIC8qKlxuICAgICAgKiBAaGlkZGVuXG4gICAgICAqL1xuICAgIGdldCBkcmF3ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kcmF3ZXIubmF0aXZlRWxlbWVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IG92ZXJsYXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vdmVybGF5Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGdldCBzdHlsZUR1bW15KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3R5bGVEdW1teS5uYXRpdmVFbGVtZW50O1xuICAgIH1cblxuICAgIC8qKiBQYW4gYW5pbWF0aW9uIHByb3BlcnRpZXMgKi9cbiAgICBwcml2YXRlIF9wYW5uaW5nID0gZmFsc2U7XG4gICAgcHJpdmF0ZSBfcGFuU3RhcnRXaWR0aDogbnVtYmVyO1xuICAgIHByaXZhdGUgX3BhbkxpbWl0OiBudW1iZXI7XG5cbiAgICAvKipcbiAgICAgKiBQcm9wZXJ0eSB0byBkZWNpZGUgd2hldGhlciB0byBjaGFuZ2Ugd2lkdGggb3IgdHJhbnNsYXRlIHRoZSBkcmF3ZXIgZnJvbSBwYW4gZ2VzdHVyZS5cbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGhhc0FuaW1hdGVXaWR0aCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGluIHx8ICEhdGhpcy5taW5pVGVtcGxhdGU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfbWF4RWRnZVpvbmUgPSA1MDtcbiAgICAvKipcbiAgICAgKiBVc2VkIGZvciB0b3VjaCBnZXN0dXJlcyAoc3dpcGUgYW5kIHBhbikuXG4gICAgICogRGVmYXVsdHMgdG8gNTAgKGluIHB4KSBhbmQgaXMgZXh0ZW5kZWQgdG8gYXQgbGVhc3QgMTEwJSBvZiB0aGUgbWluaSB0ZW1wbGF0ZSB3aWR0aCBpZiBhdmFpbGFibGUuXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCBtYXhFZGdlWm9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21heEVkZ2Vab25lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIERyYXdlciB3aWR0aCBmb3Igc3BlY2lmaWMgc3RhdGUuXG4gICAgICogV2lsbCBhdHRlbXB0IHRvIGV2YWx1YXRlIHJlcXVlc3RlZCBzdGF0ZSBhbmQgY2FjaGUuXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGV4cGVjdGVkV2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEV4cGVjdGVkV2lkdGgoZmFsc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgRHJhd2VyIG1pbmkgd2lkdGggZm9yIHNwZWNpZmljIHN0YXRlLlxuICAgICAqIFdpbGwgYXR0ZW1wdCB0byBldmFsdWF0ZSByZXF1ZXN0ZWQgc3RhdGUgYW5kIGNhY2hlLlxuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgZXhwZWN0ZWRNaW5pV2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEV4cGVjdGVkV2lkdGgodHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgdG91Y2hNYW5hZ2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdG91Y2hNYW5hZ2VyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4cG9zZXMgb3B0aW9uYWwgbmF2aWdhdGlvbiBzZXJ2aWNlXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGdldCBzdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBASW5qZWN0KEVsZW1lbnRSZWYpIHByaXZhdGUgZWxlbWVudFJlZjogRWxlbWVudFJlZixcbiAgICAgICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBfc3RhdGU6IElneE5hdmlnYXRpb25TZXJ2aWNlLFxuICAgICAgICAvLyBwcml2YXRlIGFuaW1hdGU6IEFuaW1hdGlvbkJ1aWxkZXIsIFRPRE9cbiAgICAgICAgcHJvdGVjdGVkIHJlbmRlcmVyOiBSZW5kZXJlcixcbiAgICAgICAgcHJpdmF0ZSBfdG91Y2hNYW5hZ2VyOiBIYW1tZXJHZXN0dXJlc01hbmFnZXIsXG4gICAgICAgIHByaXZhdGUgcGxhdGZvcm1VdGlsOiBQbGF0Zm9ybVV0aWwpIHtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nT25Jbml0KCkge1xuICAgICAgICAvLyBET00gYW5kIEBJbnB1dCgpLXMgaW5pdGlhbGl6ZWRcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGF0ZS5hZGQodGhpcy5pZCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICB0aGlzLnNldERyYXdlcldpZHRoKHRoaXMud2lkdGgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgICAgIC8vIHdhaXQgZm9yIHRlbXBsYXRlIGFuZCBuZy1jb250ZW50IHRvIGJlIHJlYWR5XG4gICAgICAgIHRoaXMudXBkYXRlRWRnZVpvbmUoKTtcbiAgICAgICAgdGhpcy5jaGVja1BpblRocmVzaG9sZCgpO1xuXG4gICAgICAgIHRoaXMuZW5zdXJlRXZlbnRzKCk7XG5cbiAgICAgICAgLy8gVE9ETzogYXBwbHkgcGxhdGZvcm0tc2FmZSBSdWxlciBmcm9tIGh0dHA6Ly9wbG5rci5jby9lZGl0LzgxbldEeXJlWU16a3VuaWhmUmdYP3A9cHJldmlld1xuICAgICAgICAvLyAoaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvNjUxNSksIGJsb2NrZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvNjkwNFxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuX3RvdWNoTWFuYWdlci5kZXN0cm95KCk7XG4gICAgICAgIGlmICh0aGlzLl9zdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fc3RhdGUucmVtb3ZlKHRoaXMuaWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9yZXNpemVPYnNlcnZlcikge1xuICAgICAgICAgICAgdGhpcy5fcmVzaXplT2JzZXJ2ZXIudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdPbkNoYW5nZXMoY2hhbmdlczogeyBbcHJvcE5hbWU6IHN0cmluZ106IFNpbXBsZUNoYW5nZSB9KSB7XG4gICAgICAgIC8vIHNpbXBsZSBzZXR0aW5ncyBjYW4gY29tZSBmcm9tIGF0dHJpYnV0ZSBzZXQgKHJhdGhlciB0aGFuIGJpbmRpbmcpLCBtYWtlIHN1cmUgYm9vbGVhbiBwcm9wcyBhcmUgY29udmVydGVkXG4gICAgICAgIGlmIChjaGFuZ2VzLmVuYWJsZUdlc3R1cmVzICYmIGNoYW5nZXMuZW5hYmxlR2VzdHVyZXMuY3VycmVudFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlR2VzdHVyZXMgPSAhISh0aGlzLmVuYWJsZUdlc3R1cmVzICYmIHRoaXMuZW5hYmxlR2VzdHVyZXMudG9TdHJpbmcoKSA9PT0gJ3RydWUnKTtcbiAgICAgICAgICAgIHRoaXMuZW5zdXJlRXZlbnRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZXMucGluICYmIGNoYW5nZXMucGluLmN1cnJlbnRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLnBpbiA9ICEhKHRoaXMucGluICYmIHRoaXMucGluLnRvU3RyaW5nKCkgPT09ICd0cnVlJyk7XG4gICAgICAgICAgICBpZiAodGhpcy5waW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90b3VjaE1hbmFnZXIuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2dlc3R1cmVzQXR0YWNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbnN1cmVFdmVudHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGFuZ2VzLnBpblRocmVzaG9sZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGluVGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbnN1cmVFdmVudHMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrUGluVGhyZXNob2xkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hhbmdlcy53aWR0aCAmJiB0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgdGhpcy5zZXREcmF3ZXJXaWR0aChjaGFuZ2VzLndpZHRoLmN1cnJlbnRWYWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hhbmdlcy5taW5pV2lkdGgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pc09wZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldERyYXdlcldpZHRoKGNoYW5nZXMubWluaVdpZHRoLmN1cnJlbnRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUVkZ2Vab25lKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGUgdGhlIG9wZW4gc3RhdGUgb2YgdGhlIE5hdmlnYXRpb24gRHJhd2VyLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMubmF2ZHJhd2VyLnRvZ2dsZSgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyB0b2dnbGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPcGVuIHRoZSBOYXZpZ2F0aW9uIERyYXdlci4gSGFzIG5vIGVmZmVjdCBpZiBhbHJlYWR5IG9wZW5lZC5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLm5hdmRyYXdlci5vcGVuKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIG9wZW4oKSB7XG4gICAgICAgIGlmICh0aGlzLl9wYW5uaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0UGFuKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNPcGVuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcGVuaW5nLmVtaXQoKTtcbiAgICAgICAgdGhpcy5pc09wZW4gPSB0cnVlO1xuXG4gICAgICAgIC8vIFRPRE86IFN3aXRjaCB0byBhbmltYXRlIEFQSSB3aGVuIGF2YWlsYWJsZVxuICAgICAgICAvLyB2YXIgYW5pbWF0aW9uQ3NzID0gdGhpcy5hbmltYXRlLmNzcygpO1xuICAgICAgICAvLyAgICAgYW5pbWF0aW9uQ3NzXG4gICAgICAgIC8vICAgICAgICAgLnNldFN0eWxlcyh7J3dpZHRoJzonNTBweCd9LCB7J3dpZHRoJzonNDAwcHgnfSlcbiAgICAgICAgLy8gICAgICAgICAuc3RhcnQodGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpXG4gICAgICAgIC8vICAgICAgICAgLm9uQ29tcGxldGUoKCkgPT4gYW5pbWF0aW9uQ3NzLnNldFRvU3R5bGVzKHsnd2lkdGgnOidhdXRvJ30pLnN0YXJ0KHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KSk7XG5cbiAgICAgICAgdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMudG9nZ2xlT3BlbmVkRXZlbnQsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5zZXREcmF3ZXJXaWR0aCh0aGlzLndpZHRoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9zZSB0aGUgTmF2aWdhdGlvbiBEcmF3ZXIuIEhhcyBubyBlZmZlY3QgaWYgYWxyZWFkeSBjbG9zZWQuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5uYXZkcmF3ZXIuY2xvc2UoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgY2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wYW5uaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2V0UGFuKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzT3Blbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xvc2luZy5lbWl0KCk7XG5cbiAgICAgICAgdGhpcy5pc09wZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5zZXREcmF3ZXJXaWR0aCh0aGlzLm1pbmlUZW1wbGF0ZSA/IHRoaXMubWluaVdpZHRoIDogJycpO1xuICAgICAgICB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgdGhpcy50b2dnbGVDbG9zZWRFdmVudCwgZmFsc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgc2V0X21heEVkZ2Vab25lKHZhbHVlOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fbWF4RWRnZVpvbmUgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIERyYXdlciB3aWR0aCBmb3Igc3BlY2lmaWMgc3RhdGUuIFdpbGwgYXR0ZW1wdCB0byBldmFsdWF0ZSByZXF1ZXN0ZWQgc3RhdGUgYW5kIGNhY2hlLlxuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBwYXJhbSBbbWluaV0gLSBSZXF1ZXN0IG1pbmkgd2lkdGggaW5zdGVhZFxuICAgICAqL1xuICAgIHByb3RlY3RlZCBnZXRFeHBlY3RlZFdpZHRoKG1pbmk/OiBib29sZWFuKTogbnVtYmVyIHtcbiAgICAgICAgaWYgKG1pbmkpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5taW5pVGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm1pbmlXaWR0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHRoaXMubWluaVdpZHRoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgKCF0aGlzLmlzT3BlbikgeyAvLyBUaGlzIFdPTidUIHdvcmsgZHVlIHRvIHRyYW5zaXRpb24gdGltaW5ncy4uLlxuICAgICAgICAgICAgICAgIC8vICAgICByZXR1cm4gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW5bMV0ub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgICAgLy8gfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fd2lkdGhDYWNoZS5taW5pV2lkdGggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yY2UgY2xhc3MgZm9yIHdpZHRoIGNhbGMuIFRPRE8/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKHRoaXMuc3R5bGVEdW1teSwgdGhpcy5jc3MuZHJhd2VyLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRFbGVtZW50Q2xhc3ModGhpcy5zdHlsZUR1bW15LCB0aGlzLmNzcy5taW5pLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fd2lkdGhDYWNoZS5taW5pV2lkdGggPSB0aGlzLnN0eWxlRHVtbXkub2Zmc2V0V2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKHRoaXMuc3R5bGVEdW1teSwgdGhpcy5jc3MuZHJhd2VyLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKHRoaXMuc3R5bGVEdW1teSwgdGhpcy5jc3MubWluaSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGhDYWNoZS5taW5pV2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy53aWR0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUZsb2F0KHRoaXMud2lkdGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fd2lkdGhDYWNoZS53aWR0aCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3JjZSBjbGFzcyBmb3Igd2lkdGggY2FsYy4gVE9ETz9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRFbGVtZW50Q2xhc3ModGhpcy5zdHlsZUR1bW15LCB0aGlzLmNzcy5kcmF3ZXIsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl93aWR0aENhY2hlLndpZHRoID0gdGhpcy5zdHlsZUR1bW15Lm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldEVsZW1lbnRDbGFzcyh0aGlzLnN0eWxlRHVtbXksIHRoaXMuY3NzLmRyYXdlciwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2lkdGhDYWNoZS53aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0V2luZG93V2lkdGgoKSB7XG4gICAgICAgIHJldHVybiAod2luZG93LmlubmVyV2lkdGggPiAwKSA/IHdpbmRvdy5pbm5lcldpZHRoIDogc2NyZWVuLndpZHRoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGRyYXdlciB3aWR0aC5cbiAgICAgKi9cbiAgICBwcml2YXRlIHNldERyYXdlcldpZHRoKHdpZHRoOiBzdHJpbmcpIHtcbiAgICAgICAgaWYgKHRoaXMucGxhdGZvcm1VdGlsLmlzQnJvd3Nlcikge1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kcmF3ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRFbGVtZW50U3R5bGUodGhpcy5kcmF3ZXIsICd3aWR0aCcsIHdpZHRoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0RWxlbWVudFN0eWxlKHRoaXMuZHJhd2VyLCAnd2lkdGgnLCB3aWR0aCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY3VycmVudCBEcmF3ZXIgd2lkdGguXG4gICAgICovXG4gICAgcHJpdmF0ZSBnZXREcmF3ZXJXaWR0aCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5kcmF3ZXIub2Zmc2V0V2lkdGg7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBlbnN1cmVFdmVudHMoKSB7XG4gICAgICAgIC8vIHNldCBsaXN0ZW5lcnMgZm9yIHN3aXBlL3BhbiBvbmx5IGlmIG5lZWRlZCwgYnV0IGp1c3Qgb25jZVxuICAgICAgICBpZiAodGhpcy5lbmFibGVHZXN0dXJlcyAmJiAhdGhpcy5waW4gJiYgIXRoaXMuX2dlc3R1cmVzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgIC8vIEJ1aWx0LWluIG1hbmFnZXIgaGFuZGxlcihMMjA4ODcpIGNhdXNlcyBlbmRsZXNzIGxvb3AgYW5kIG1heCBzdGFjayBleGNlcHRpb24uXG4gICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy82OTkzXG4gICAgICAgICAgICAvLyBVc2Ugb3VycyBmb3Igbm93ICh1bnRpbCBiZXRhLjEwKTpcbiAgICAgICAgICAgIC8vIHRoaXMucmVuZGVyZXIubGlzdGVuKGRvY3VtZW50LCBcInN3aXBlXCIsIHRoaXMuc3dpcGUpO1xuICAgICAgICAgICAgdGhpcy5fdG91Y2hNYW5hZ2VyLmFkZEdsb2JhbEV2ZW50TGlzdGVuZXIoJ2RvY3VtZW50JywgJ3N3aXBlJywgdGhpcy5zd2lwZSk7XG4gICAgICAgICAgICB0aGlzLl9nZXN0dXJlc0F0dGFjaGVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgLy8gdGhpcy5yZW5kZXJlci5saXN0ZW4oZG9jdW1lbnQsIFwicGFuc3RhcnRcIiwgdGhpcy5wYW5zdGFydCk7XG4gICAgICAgICAgICAvLyB0aGlzLnJlbmRlcmVyLmxpc3Rlbihkb2N1bWVudCwgXCJwYW5cIiwgdGhpcy5wYW4pO1xuICAgICAgICAgICAgdGhpcy5fdG91Y2hNYW5hZ2VyLmFkZEdsb2JhbEV2ZW50TGlzdGVuZXIoJ2RvY3VtZW50JywgJ3BhbnN0YXJ0JywgdGhpcy5wYW5zdGFydCk7XG4gICAgICAgICAgICB0aGlzLl90b3VjaE1hbmFnZXIuYWRkR2xvYmFsRXZlbnRMaXN0ZW5lcignZG9jdW1lbnQnLCAncGFubW92ZScsIHRoaXMucGFuKTtcbiAgICAgICAgICAgIHRoaXMuX3RvdWNoTWFuYWdlci5hZGRHbG9iYWxFdmVudExpc3RlbmVyKCdkb2N1bWVudCcsICdwYW5lbmQnLCB0aGlzLnBhbkVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9yZXNpemVPYnNlcnZlciAmJiB0aGlzLnBsYXRmb3JtVXRpbC5pc0Jyb3dzZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyID0gZnJvbUV2ZW50KHdpbmRvdywgJ3Jlc2l6ZScpLnBpcGUoZGVib3VuY2UoKCkgPT4gaW50ZXJ2YWwoMTUwKSkpXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZSgodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja1BpblRocmVzaG9sZCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZUVkZ2Vab25lKCkge1xuICAgICAgICBsZXQgbWF4VmFsdWU7XG5cbiAgICAgICAgaWYgKHRoaXMubWluaVRlbXBsYXRlKSB7XG4gICAgICAgICAgICBtYXhWYWx1ZSA9IE1hdGgubWF4KHRoaXMuX21heEVkZ2Vab25lLCB0aGlzLmdldEV4cGVjdGVkV2lkdGgodHJ1ZSkgKiAxLjEpO1xuICAgICAgICAgICAgdGhpcy5zZXRfbWF4RWRnZVpvbmUobWF4VmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjaGVja1BpblRocmVzaG9sZCA9IChldnQ/OiBFdmVudCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMucGxhdGZvcm1VdGlsLmlzQnJvd3Nlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCB3aW5kb3dXaWR0aDtcbiAgICAgICAgaWYgKHRoaXMucGluVGhyZXNob2xkKSB7XG4gICAgICAgICAgICB3aW5kb3dXaWR0aCA9IHRoaXMuZ2V0V2luZG93V2lkdGgoKTtcbiAgICAgICAgICAgIGlmIChldnQgJiYgdGhpcy5fd2lkdGhDYWNoZS53aW5kb3dXaWR0aCA9PT0gd2luZG93V2lkdGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl93aWR0aENhY2hlLndpbmRvd1dpZHRoID0gd2luZG93V2lkdGg7XG4gICAgICAgICAgICBpZiAoIXRoaXMucGluICYmIHdpbmRvd1dpZHRoID49IHRoaXMucGluVGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5waW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMucGluQ2hhbmdlLmVtaXQodHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucGluICYmIHdpbmRvd1dpZHRoIDwgdGhpcy5waW5UaHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBpbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoaXMucGluQ2hhbmdlLmVtaXQoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzd2lwZSA9IChldnQ6IEhhbW1lcklucHV0KSA9PiB7XG4gICAgICAgIC8vIFRPRE86IENvdWxkIGFsc28gZm9yY2UgaW5wdXQgdHlwZTogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjcxMDgwNTJcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZUdlc3R1cmVzIHx8IGV2dC5wb2ludGVyVHlwZSAhPT0gJ3RvdWNoJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSGFtbWVySlMgc3dpcGUgaXMgaG9yaXpvbnRhbC1vbmx5IGJ5IGRlZmF1bHQsIGRvbid0IGNoZWNrIGRlbHRhWVxuICAgICAgICBsZXQgZGVsdGFYO1xuICAgICAgICBsZXQgc3RhcnRQb3NpdGlvbjtcbiAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIC8vIHdoZW4gb24gdGhlIHJpZ2h0IHVzZSBpbnZlcnNlIG9mIGRlbHRhWFxuICAgICAgICAgICAgZGVsdGFYID0gLWV2dC5kZWx0YVg7XG4gICAgICAgICAgICBzdGFydFBvc2l0aW9uID0gdGhpcy5nZXRXaW5kb3dXaWR0aCgpIC0gKGV2dC5jZW50ZXIueCArIGV2dC5kaXN0YW5jZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkZWx0YVggPSBldnQuZGVsdGFYO1xuICAgICAgICAgICAgc3RhcnRQb3NpdGlvbiA9IGV2dC5jZW50ZXIueCAtIGV2dC5kaXN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBvbmx5IGFjY2VwdCBjbG9zaW5nIHN3aXBlIChpZ25vcmluZyBtaW5FZGdlWm9uZSkgd2hlbiB0aGUgZHJhd2VyIGlzIGV4cGFuZGVkOlxuICAgICAgICBpZiAoKHRoaXMuaXNPcGVuICYmIGRlbHRhWCA8IDApIHx8XG4gICAgICAgICAgICAvLyBwb3NpdGl2ZSBkZWx0YVggZnJvbSB0aGUgZWRnZTpcbiAgICAgICAgICAgIChkZWx0YVggPiAwICYmIHN0YXJ0UG9zaXRpb24gPCB0aGlzLm1heEVkZ2Vab25lKSkge1xuICAgICAgICAgICAgdGhpcy50b2dnbGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgcGFuc3RhcnQgPSAoZXZ0OiBIYW1tZXJJbnB1dCkgPT4geyAvLyBUT0RPOiB0ZXN0IGNvZGVcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZUdlc3R1cmVzIHx8IHRoaXMucGluIHx8IGV2dC5wb2ludGVyVHlwZSAhPT0gJ3RvdWNoJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXJ0UG9zaXRpb24gPSB0aGlzLnBvc2l0aW9uID09PSAncmlnaHQnID8gdGhpcy5nZXRXaW5kb3dXaWR0aCgpIC0gKGV2dC5jZW50ZXIueCArIGV2dC5kaXN0YW5jZSlcbiAgICAgICAgICAgIDogZXZ0LmNlbnRlci54IC0gZXZ0LmRpc3RhbmNlO1xuXG4gICAgICAgIC8vIGNhY2hlIHdpZHRoIGR1cmluZyBhbmltYXRpb24sIGZsYWcgdG8gYWxsb3cgZnVydGhlciBoYW5kbGluZ1xuICAgICAgICBpZiAodGhpcy5pc09wZW4gfHwgKHN0YXJ0UG9zaXRpb24gPCB0aGlzLm1heEVkZ2Vab25lKSkge1xuICAgICAgICAgICAgdGhpcy5fcGFubmluZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9wYW5TdGFydFdpZHRoID0gdGhpcy5nZXRFeHBlY3RlZFdpZHRoKCF0aGlzLmlzT3Blbik7XG4gICAgICAgICAgICB0aGlzLl9wYW5MaW1pdCA9IHRoaXMuZ2V0RXhwZWN0ZWRXaWR0aCh0aGlzLmlzT3Blbik7XG5cbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKHRoaXMub3ZlcmxheSwgJ3Bhbm5pbmcnLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0RWxlbWVudENsYXNzKHRoaXMuZHJhd2VyLCAncGFubmluZycsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwYW4gPSAoZXZ0OiBIYW1tZXJJbnB1dCkgPT4ge1xuICAgICAgICAvLyBUT0RPOiBpbnB1dC5kZWx0YVggPSBwcmV2RGVsdGEueCArIChjZW50ZXIueCAtIG9mZnNldC54KTtcbiAgICAgICAgLy8gZ2V0IGFjdHVhbCBkZWx0YSAobm90IHRvdGFsIHNlc3Npb24gb25lKSBmcm9tIGV2ZW50P1xuICAgICAgICAvLyBwYW4gV0lMTCBhbHNvIGZpcmUgYWZ0ZXIgYSBmdWxsIHN3aXBlLCBvbmx5IHJlc2l6ZSBvbiBmbGFnXG4gICAgICAgIGlmICghdGhpcy5fcGFubmluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJpZ2h0OiBib29sZWFuID0gdGhpcy5wb3NpdGlvbiA9PT0gJ3JpZ2h0JztcbiAgICAgICAgLy8gd2hlbiBvbiB0aGUgcmlnaHQgdXNlIGludmVyc2Ugb2YgZGVsdGFYXG4gICAgICAgIGNvbnN0IGRlbHRhWCA9IHJpZ2h0ID8gLWV2dC5kZWx0YVggOiBldnQuZGVsdGFYO1xuICAgICAgICBsZXQgdmlzaWJsZVdpZHRoO1xuICAgICAgICBsZXQgbmV3WDtcbiAgICAgICAgbGV0IHBlcmNlbnQ7XG5cbiAgICAgICAgdmlzaWJsZVdpZHRoID0gdGhpcy5fcGFuU3RhcnRXaWR0aCArIGRlbHRhWDtcblxuICAgICAgICBpZiAodGhpcy5pc09wZW4gJiYgZGVsdGFYIDwgMCkge1xuICAgICAgICAgICAgLy8gd2hlbiB2aXNpYmxlV2lkdGggaGl0cyBsaW1pdCAtIHN0b3AgYW5pbWF0aW5nXG4gICAgICAgICAgICBpZiAodmlzaWJsZVdpZHRoIDw9IHRoaXMuX3BhbkxpbWl0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5oYXNBbmltYXRlV2lkdGgpIHtcbiAgICAgICAgICAgICAgICBwZXJjZW50ID0gKHZpc2libGVXaWR0aCAtIHRoaXMuX3BhbkxpbWl0KSAvICh0aGlzLl9wYW5TdGFydFdpZHRoIC0gdGhpcy5fcGFuTGltaXQpO1xuICAgICAgICAgICAgICAgIG5ld1ggPSB2aXNpYmxlV2lkdGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBlcmNlbnQgPSB2aXNpYmxlV2lkdGggLyB0aGlzLl9wYW5TdGFydFdpZHRoO1xuICAgICAgICAgICAgICAgIG5ld1ggPSBldnQuZGVsdGFYO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRYU2l6ZShuZXdYLCBwZXJjZW50LnRvUHJlY2lzaW9uKDIpKTtcblxuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLmlzT3BlbiAmJiBkZWx0YVggPiAwKSB7XG4gICAgICAgICAgICAvLyB3aGVuIHZpc2libGVXaWR0aCBoaXRzIGxpbWl0IC0gc3RvcCBhbmltYXRpbmdcbiAgICAgICAgICAgIGlmICh2aXNpYmxlV2lkdGggPj0gdGhpcy5fcGFuTGltaXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmhhc0FuaW1hdGVXaWR0aCkge1xuICAgICAgICAgICAgICAgIHBlcmNlbnQgPSAodmlzaWJsZVdpZHRoIC0gdGhpcy5fcGFuU3RhcnRXaWR0aCkgLyAodGhpcy5fcGFuTGltaXQgLSB0aGlzLl9wYW5TdGFydFdpZHRoKTtcbiAgICAgICAgICAgICAgICBuZXdYID0gdmlzaWJsZVdpZHRoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZXJjZW50ID0gdmlzaWJsZVdpZHRoIC8gdGhpcy5fcGFuTGltaXQ7XG4gICAgICAgICAgICAgICAgbmV3WCA9ICh0aGlzLl9wYW5MaW1pdCAtIHZpc2libGVXaWR0aCkgKiAocmlnaHQgPyAxIDogLTEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRYU2l6ZShuZXdYLCBwZXJjZW50LnRvUHJlY2lzaW9uKDIpKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgcGFuRW5kID0gKGV2dDogSGFtbWVySW5wdXQpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX3Bhbm5pbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhWCA9IHRoaXMucG9zaXRpb24gPT09ICdyaWdodCcgPyAtZXZ0LmRlbHRhWCA6IGV2dC5kZWx0YVg7XG4gICAgICAgICAgICBjb25zdCB2aXNpYmxlV2lkdGg6IG51bWJlciA9IHRoaXMuX3BhblN0YXJ0V2lkdGggKyBkZWx0YVg7XG4gICAgICAgICAgICB0aGlzLnJlc2V0UGFuKCk7XG5cbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHBhbiBicm91Z2h0IHRoZSBkcmF3ZXIgdG8gNTAlXG4gICAgICAgICAgICBpZiAodGhpcy5pc09wZW4gJiYgdmlzaWJsZVdpZHRoIDw9IHRoaXMuX3BhblN0YXJ0V2lkdGggLyAyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5pc09wZW4gJiYgdmlzaWJsZVdpZHRoID49IHRoaXMuX3BhbkxpbWl0IC8gMikge1xuICAgICAgICAgICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcGFuU3RhcnRXaWR0aCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHJlc2V0UGFuKCkge1xuICAgICAgICB0aGlzLl9wYW5uaW5nID0gZmFsc2U7XG4gICAgICAgIC8qIHN0eWxlcyBmYWlsIHRvIGFwcGx5IHdoZW4gc2V0IG9uIHBhcmVudCBkdWUgdG8gZXh0cmEgYXR0cmlidXRlcywgcHJvYiBuZyBidWcgKi9cbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRFbGVtZW50Q2xhc3ModGhpcy5vdmVybGF5LCAncGFubmluZycsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRFbGVtZW50Q2xhc3ModGhpcy5kcmF3ZXIsICdwYW5uaW5nJywgZmFsc2UpO1xuICAgICAgICB0aGlzLnNldFhTaXplKDAsICcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvciB3aWR0aCBpbiBjYXNlIHRoZSBkcmF3ZXIgZG9lc24ndCBjaGFuZ2UgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHggdGhlIG51bWJlciBwaXhlbHMgdG8gdHJhbnNsYXRlIG9uIHRoZSBYIGF4aXMgb3IgdGhlIHdpZHRoIHRvIHNldC4gMCB3aWR0aCB3aWxsIGNsZWFyIHRoZSBzdHlsZSBpbnN0ZWFkLlxuICAgICAqIEBwYXJhbSBvcGFjaXR5IG9wdGlvbmFsIHZhbHVlIHRvIGFwcGx5IHRvIHRoZSBvdmVybGF5XG4gICAgICovXG4gICAgcHJpdmF0ZSBzZXRYU2l6ZSh4OiBudW1iZXIsIG9wYWNpdHk/OiBzdHJpbmcpIHtcbiAgICAgICAgLy8gQW5ndWxhciBwb2x5ZmlsbHMgcGF0Y2hlcyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBidXQgc3dpdGNoIHRvIERvbUFkYXB0ZXIgQVBJIChUT0RPKVxuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc0FuaW1hdGVXaWR0aCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0RWxlbWVudFN0eWxlKHRoaXMuZHJhd2VyLCAnd2lkdGgnLCB4ID8gTWF0aC5hYnMoeCkgKyAncHgnIDogJycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSB4ID8gJ3RyYW5zbGF0ZTNkKCcgKyB4ICsgJ3B4LDAsMCknIDogJyc7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRFbGVtZW50U3R5bGUodGhpcy5kcmF3ZXIsICd0cmFuc2Zvcm0nLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0RWxlbWVudFN0eWxlKHRoaXMuZHJhd2VyLCAnLXdlYmtpdC10cmFuc2Zvcm0nLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wYWNpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0RWxlbWVudFN0eWxlKHRoaXMub3ZlcmxheSwgJ29wYWNpdHknLCBvcGFjaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB0b2dnbGVPcGVuZWRFdmVudCA9IChldnQ/KSA9PiB7XG4gICAgICAgIHRoaXMuZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLnRvZ2dsZU9wZW5lZEV2ZW50LCBmYWxzZSk7XG4gICAgICAgIHRoaXMub3BlbmVkLmVtaXQoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHRvZ2dsZUNsb3NlZEV2ZW50ID0gKGV2dD8pID0+IHtcbiAgICAgICAgdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIHRoaXMudG9nZ2xlQ2xvc2VkRXZlbnQsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5jbG9zZWQuZW1pdCgpO1xuICAgIH1cbn1cbiJdfQ==