/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { ChangeDetectorRef, Directive, ElementRef, EventEmitter, HostBinding, HostListener, Input, NgModule, Optional, Output, Inject } from '@angular/core';
import { IgxNavigationService } from '../../core/navigation';
import { IgxOverlayService } from '../../services/overlay/overlay';
import { ConnectedPositioningStrategy, AbsoluteScrollStrategy } from '../../services';
import { filter, takeUntil } from 'rxjs/operators';
import { Subject } from 'rxjs';
var IgxToggleDirective = /** @class */ (function () {
    /**
     * @hidden
     */
    function IgxToggleDirective(elementRef, cdr, overlayService, navigationService) {
        var _this = this;
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.overlayService = overlayService;
        this.navigationService = navigationService;
        this.destroy$ = new Subject();
        this._overlaySubFilter = [
            filter(function (x) { return x.id === _this._overlayId; }),
            takeUntil(this.destroy$)
        ];
        /**
         * Emits an event after the toggle container is opened.
         *
         * ```typescript
         * onToggleOpened(event) {
         *    alert("Toggle opened!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (onOpened)='onToggleOpened($event)'>
         * </div>
         * ```
         */
        this.onOpened = new EventEmitter();
        /**
         * Emits an event before the toggle container is opened.
         *
         * ```typescript
         * onToggleOpening(event) {
         *  alert("Toggle opening!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (onOpening)='onToggleOpening($event)'>
         * </div>
         * ```
         */
        this.onOpening = new EventEmitter();
        /**
         * Emits an event after the toggle container is closed.
         *
         * ```typescript
         * onToggleClosed(event) {
         *  alert("Toggle closed!");
         * }
         * ```
         *
         * ```html
         * <div
         *   igxToggle
         *   (onClosed)='onToggleClosed($event)'>
         * </div>
         * ```
         */
        this.onClosed = new EventEmitter();
        /**
         * Emits an event before the toggle container is closed.
         *
         * ```typescript
         * onToggleClosing(event) {
         *  alert("Toggle closing!");
         * }
         * ```
         *
         * ```html
         * <div
         *  igxToggle
         *  (onClosing)='onToggleClosing($event)'>
         * </div>
         * ```
         */
        this.onClosing = new EventEmitter();
        this._collapsed = true;
        this.overlayClosed = function () {
            _this._collapsed = true;
            _this.cdr.detectChanges();
            delete _this._overlayId;
            _this.unsubscribe();
            _this.onClosed.emit();
        };
    }
    Object.defineProperty(IgxToggleDirective.prototype, "collapsed", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this._collapsed;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxToggleDirective.prototype, "element", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.elementRef.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxToggleDirective.prototype, "hiddenClass", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.collapsed;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxToggleDirective.prototype, "defaultClass", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return !this.collapsed;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Opens the toggle.
     *
     * ```typescript
     * this.myToggle.open();
     * ```
     */
    /**
     * Opens the toggle.
     *
     * ```typescript
     * this.myToggle.open();
     * ```
     * @param {?=} overlaySettings
     * @return {?}
     */
    IgxToggleDirective.prototype.open = /**
     * Opens the toggle.
     *
     * ```typescript
     * this.myToggle.open();
     * ```
     * @param {?=} overlaySettings
     * @return {?}
     */
    function (overlaySettings) {
        var _this = this;
        var _a, _b, _c;
        //  if there is open animation do nothing
        //  if toggle is not collapsed and there is no close animation do nothing
        /** @type {?} */
        var info = this.overlayService.getOverlayById(this._overlayId);
        /** @type {?} */
        var hasOpenAnimation = info ? info.openAnimationPlayer : false;
        /** @type {?} */
        var hasCloseAnimation = info ? info.closeAnimationPlayer : false;
        if (hasOpenAnimation || !(this._collapsed || hasCloseAnimation)) {
            return;
        }
        if (!info) {
            this._overlayId = this.overlayService.attach(this.elementRef, overlaySettings);
        }
        this._collapsed = false;
        this.cdr.detectChanges();
        /** @type {?} */
        var openEventArgs = { cancel: false };
        this.onOpening.emit(openEventArgs);
        if (openEventArgs.cancel) {
            this._collapsed = true;
            this.cdr.detectChanges();
            return;
        }
        this.overlayService.show(this._overlayId, overlaySettings);
        this.unsubscribe();
        this._overlayOpenedSub = (_a = this.overlayService.onOpened).pipe.apply(_a, tslib_1.__spread(this._overlaySubFilter)).subscribe(function () {
            _this.onOpened.emit();
        });
        this._overlayClosingSub = (_b = this.overlayService
            .onClosing).pipe.apply(_b, tslib_1.__spread(this._overlaySubFilter)).subscribe(function (e) {
            /** @type {?} */
            var eventArgs = { cancel: false, event: e.event };
            _this.onClosing.emit(eventArgs);
            e.cancel = eventArgs.cancel;
            //  in case event is not canceled this will close the toggle and we need to unsubscribe.
            //  Otherwise if for some reason, e.g. close on outside click, close() gets called before
            //  onClosed was fired we will end with calling onClosing more than once
            if (!e.cancel) {
                _this.clearSubscription(_this._overlayClosingSub);
            }
        });
        this._overlayClosedSub = (_c = this.overlayService.onClosed).pipe.apply(_c, tslib_1.__spread(this._overlaySubFilter)).subscribe(this.overlayClosed);
    };
    /**
     * Closes the toggle.
     *
     * ```typescript
     * this.myToggle.close();
     * ```
     */
    /**
     * Closes the toggle.
     *
     * ```typescript
     * this.myToggle.close();
     * ```
     * @return {?}
     */
    IgxToggleDirective.prototype.close = /**
     * Closes the toggle.
     *
     * ```typescript
     * this.myToggle.close();
     * ```
     * @return {?}
     */
    function () {
        //  if toggle is collapsed do nothing
        //  if there is close animation do nothing, toggle will close anyway
        /** @type {?} */
        var info = this.overlayService.getOverlayById(this._overlayId);
        /** @type {?} */
        var hasCloseAnimation = info ? info.closeAnimationPlayer : false;
        if (this._collapsed || hasCloseAnimation) {
            return;
        }
        this.overlayService.hide(this._overlayId);
    };
    /**
     * Opens or closes the toggle, depending on its current state.
     *
     * ```typescript
     * this.myToggle.toggle();
     * ```
     */
    /**
     * Opens or closes the toggle, depending on its current state.
     *
     * ```typescript
     * this.myToggle.toggle();
     * ```
     * @param {?=} overlaySettings
     * @return {?}
     */
    IgxToggleDirective.prototype.toggle = /**
     * Opens or closes the toggle, depending on its current state.
     *
     * ```typescript
     * this.myToggle.toggle();
     * ```
     * @param {?=} overlaySettings
     * @return {?}
     */
    function (overlaySettings) {
        //  if toggle is collapsed call open
        //  if there is close animation call open
        if (this.collapsed || this.isClosing) {
            this.open(overlaySettings);
        }
        else {
            this.close();
        }
    };
    Object.defineProperty(IgxToggleDirective.prototype, "isClosing", {
        /** @hidden @internal */
        get: /**
         * @hidden \@internal
         * @return {?}
         */
        function () {
            /** @type {?} */
            var info = this.overlayService.getOverlayById(this._overlayId);
            return info ? info.closeAnimationPlayer : false;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Repositions the toggle.
     * ```typescript
     * this.myToggle.reposition();
     * ```
     */
    /**
     * Repositions the toggle.
     * ```typescript
     * this.myToggle.reposition();
     * ```
     * @return {?}
     */
    IgxToggleDirective.prototype.reposition = /**
     * Repositions the toggle.
     * ```typescript
     * this.myToggle.reposition();
     * ```
     * @return {?}
     */
    function () {
        this.overlayService.reposition(this._overlayId);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxToggleDirective.prototype.ngOnInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        if (this.navigationService && this.id) {
            this.navigationService.add(this.id, this);
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxToggleDirective.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        if (this.navigationService && this.id) {
            this.navigationService.remove(this.id);
        }
        if (!this.collapsed && this._overlayId) {
            this.overlayService.hide(this._overlayId);
        }
        this.unsubscribe();
        this.destroy$.next(true);
        this.destroy$.complete();
    };
    /**
     * @private
     * @return {?}
     */
    IgxToggleDirective.prototype.unsubscribe = /**
     * @private
     * @return {?}
     */
    function () {
        this.clearSubscription(this._overlayOpenedSub);
        this.clearSubscription(this._overlayClosingSub);
        this.clearSubscription(this._overlayClosedSub);
    };
    /**
     * @private
     * @param {?} subscription
     * @return {?}
     */
    IgxToggleDirective.prototype.clearSubscription = /**
     * @private
     * @param {?} subscription
     * @return {?}
     */
    function (subscription) {
        if (subscription && !subscription.closed) {
            subscription.unsubscribe();
        }
    };
    IgxToggleDirective.decorators = [
        { type: Directive, args: [{
                    exportAs: 'toggle',
                    selector: '[igxToggle]'
                },] }
    ];
    /** @nocollapse */
    IgxToggleDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ChangeDetectorRef },
        { type: IgxOverlayService, decorators: [{ type: Inject, args: [IgxOverlayService,] }] },
        { type: IgxNavigationService, decorators: [{ type: Optional }] }
    ]; };
    IgxToggleDirective.propDecorators = {
        onOpened: [{ type: Output }],
        onOpening: [{ type: Output }],
        onClosed: [{ type: Output }],
        onClosing: [{ type: Output }],
        id: [{ type: Input }],
        hiddenClass: [{ type: HostBinding, args: ['class.igx-toggle--hidden',] }, { type: HostBinding, args: ['attr.aria-hidden',] }],
        defaultClass: [{ type: HostBinding, args: ['class.igx-toggle',] }]
    };
    return IgxToggleDirective;
}());
export { IgxToggleDirective };
if (false) {
    /**
     * @type {?}
     * @protected
     */
    IgxToggleDirective.prototype._overlayId;
    /**
     * @type {?}
     * @private
     */
    IgxToggleDirective.prototype.destroy$;
    /**
     * @type {?}
     * @private
     */
    IgxToggleDirective.prototype._overlaySubFilter;
    /**
     * @type {?}
     * @private
     */
    IgxToggleDirective.prototype._overlayOpenedSub;
    /**
     * @type {?}
     * @private
     */
    IgxToggleDirective.prototype._overlayClosingSub;
    /**
     * @type {?}
     * @private
     */
    IgxToggleDirective.prototype._overlayClosedSub;
    /**
     * Emits an event after the toggle container is opened.
     *
     * ```typescript
     * onToggleOpened(event) {
     *    alert("Toggle opened!");
     * }
     * ```
     *
     * ```html
     * <div
     *   igxToggle
     *   (onOpened)='onToggleOpened($event)'>
     * </div>
     * ```
     * @type {?}
     */
    IgxToggleDirective.prototype.onOpened;
    /**
     * Emits an event before the toggle container is opened.
     *
     * ```typescript
     * onToggleOpening(event) {
     *  alert("Toggle opening!");
     * }
     * ```
     *
     * ```html
     * <div
     *   igxToggle
     *   (onOpening)='onToggleOpening($event)'>
     * </div>
     * ```
     * @type {?}
     */
    IgxToggleDirective.prototype.onOpening;
    /**
     * Emits an event after the toggle container is closed.
     *
     * ```typescript
     * onToggleClosed(event) {
     *  alert("Toggle closed!");
     * }
     * ```
     *
     * ```html
     * <div
     *   igxToggle
     *   (onClosed)='onToggleClosed($event)'>
     * </div>
     * ```
     * @type {?}
     */
    IgxToggleDirective.prototype.onClosed;
    /**
     * Emits an event before the toggle container is closed.
     *
     * ```typescript
     * onToggleClosing(event) {
     *  alert("Toggle closing!");
     * }
     * ```
     *
     * ```html
     * <div
     *  igxToggle
     *  (onClosing)='onToggleClosing($event)'>
     * </div>
     * ```
     * @type {?}
     */
    IgxToggleDirective.prototype.onClosing;
    /**
     * @type {?}
     * @private
     */
    IgxToggleDirective.prototype._collapsed;
    /**
     * Identifier which is registered into `IgxNavigationService`
     *
     * ```typescript
     * let myToggleId = this.toggle.id;
     * ```
     * @type {?}
     */
    IgxToggleDirective.prototype.id;
    /**
     * @type {?}
     * @private
     */
    IgxToggleDirective.prototype.overlayClosed;
    /**
     * @type {?}
     * @private
     */
    IgxToggleDirective.prototype.elementRef;
    /**
     * @type {?}
     * @private
     */
    IgxToggleDirective.prototype.cdr;
    /**
     * @type {?}
     * @protected
     */
    IgxToggleDirective.prototype.overlayService;
    /**
     * @type {?}
     * @private
     */
    IgxToggleDirective.prototype.navigationService;
}
var IgxToggleActionDirective = /** @class */ (function () {
    function IgxToggleActionDirective(element, navigationService) {
        this.element = element;
        this.navigationService = navigationService;
    }
    Object.defineProperty(IgxToggleActionDirective.prototype, "target", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            if (typeof this._target === 'string') {
                return this.navigationService.get(this._target);
            }
            return this._target;
        },
        /**
         * @hidden
         */
        set: /**
         * @hidden
         * @param {?} target
         * @return {?}
         */
        function (target) {
            if (target !== null && target !== '') {
                this._target = target;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxToggleActionDirective.prototype.ngOnInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        this._overlayDefaults = {
            positionStrategy: new ConnectedPositioningStrategy({ target: this.element.nativeElement }),
            scrollStrategy: new AbsoluteScrollStrategy(),
            closeOnOutsideClick: true,
            modal: false,
            excludePositionTarget: true
        };
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxToggleActionDirective.prototype.onClick = /**
     * @hidden
     * @return {?}
     */
    function () {
        if (this.outlet) {
            this._overlayDefaults.outlet = this.outlet;
        }
        /** @type {?} */
        var clonedSettings = Object.assign({}, this._overlayDefaults, this.overlaySettings);
        this.updateOverlaySettings(clonedSettings);
        this.target.toggle(clonedSettings);
    };
    /**
     * Updates provided overlay settings
     * @param settings settings to update
     * @returns returns updated copy of provided overlay settings
     */
    /**
     * Updates provided overlay settings
     * @protected
     * @param {?} settings settings to update
     * @return {?} returns updated copy of provided overlay settings
     */
    IgxToggleActionDirective.prototype.updateOverlaySettings = /**
     * Updates provided overlay settings
     * @protected
     * @param {?} settings settings to update
     * @return {?} returns updated copy of provided overlay settings
     */
    function (settings) {
        if (settings && settings.positionStrategy) {
            /** @type {?} */
            var positionStrategyClone = settings.positionStrategy.clone();
            positionStrategyClone.settings.target = this.element.nativeElement;
            settings.positionStrategy = positionStrategyClone;
        }
        return settings;
    };
    IgxToggleActionDirective.decorators = [
        { type: Directive, args: [{
                    exportAs: 'toggle-action',
                    selector: '[igxToggleAction]'
                },] }
    ];
    /** @nocollapse */
    IgxToggleActionDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: IgxNavigationService, decorators: [{ type: Optional }] }
    ]; };
    IgxToggleActionDirective.propDecorators = {
        overlaySettings: [{ type: Input }],
        outlet: [{ type: Input, args: ['igxToggleOutlet',] }],
        target: [{ type: Input, args: ['igxToggleAction',] }],
        onClick: [{ type: HostListener, args: ['click',] }]
    };
    return IgxToggleActionDirective;
}());
export { IgxToggleActionDirective };
if (false) {
    /**
     * @type {?}
     * @protected
     */
    IgxToggleActionDirective.prototype._overlayDefaults;
    /**
     * Provide settings that control the toggle overlay positioning, interaction and scroll behavior.
     * ```typescript
     * const settings: OverlaySettings = {
     *      closeOnOutsideClick: false,
     *      modal: false
     *  }
     * ```
     * ---
     * ```html
     * <!--set-->
     * <div igxToggleAction [overlaySettings]="settings"></div>
     * ```
     * @type {?}
     */
    IgxToggleActionDirective.prototype.overlaySettings;
    /**
     * Determines where the toggle element overlay should be attached.
     *
     * ```html
     * <!--set-->
     * <div igxToggleAction [igxToggleOutlet]="outlet"></div>
     * ```
     * Where `outlet` in an instance of `IgxOverlayOutletDirective` or an `ElementRef`
     * @type {?}
     */
    IgxToggleActionDirective.prototype.outlet;
    /**
     * @type {?}
     * @protected
     */
    IgxToggleActionDirective.prototype._target;
    /**
     * @type {?}
     * @private
     */
    IgxToggleActionDirective.prototype.element;
    /**
     * @type {?}
     * @private
     */
    IgxToggleActionDirective.prototype.navigationService;
}
/**
 * Mark an element as an igxOverlay outlet container.
 * Directive instance is exported as `overlay-outlet` to be assigned to templates variables:
 * ```html
 * <div igxOverlayOutlet #outlet="overlay-outlet"></div>
 * ```
 */
var IgxOverlayOutletDirective = /** @class */ (function () {
    function IgxOverlayOutletDirective(element) {
        this.element = element;
    }
    Object.defineProperty(IgxOverlayOutletDirective.prototype, "nativeElement", {
        /** @hidden */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return this.element.nativeElement;
        },
        enumerable: true,
        configurable: true
    });
    IgxOverlayOutletDirective.decorators = [
        { type: Directive, args: [{
                    exportAs: 'overlay-outlet',
                    selector: '[igxOverlayOutlet]'
                },] }
    ];
    /** @nocollapse */
    IgxOverlayOutletDirective.ctorParameters = function () { return [
        { type: ElementRef }
    ]; };
    return IgxOverlayOutletDirective;
}());
export { IgxOverlayOutletDirective };
if (false) {
    /** @type {?} */
    IgxOverlayOutletDirective.prototype.element;
}
/**
 * @hidden
 */
var IgxToggleModule = /** @class */ (function () {
    function IgxToggleModule() {
    }
    IgxToggleModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxToggleDirective, IgxToggleActionDirective, IgxOverlayOutletDirective],
                    exports: [IgxToggleDirective, IgxToggleActionDirective, IgxOverlayOutletDirective],
                    providers: [IgxNavigationService]
                },] }
    ];
    return IgxToggleModule;
}());
export { IgxToggleModule };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9nZ2xlLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvZGlyZWN0aXZlcy90b2dnbGUvdG9nZ2xlLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFDSCxpQkFBaUIsRUFDakIsU0FBUyxFQUNULFVBQVUsRUFDVixZQUFZLEVBQ1osV0FBVyxFQUNYLFlBQVksRUFDWixLQUFLLEVBQ0wsUUFBUSxFQUdSLFFBQVEsRUFDUixNQUFNLEVBQ04sTUFBTSxFQUNULE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxvQkFBb0IsRUFBZSxNQUFNLHVCQUF1QixDQUFDO0FBQzFFLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBQ25FLE9BQU8sRUFBcUMsNEJBQTRCLEVBQUUsc0JBQXNCLEVBQXFCLE1BQU0sZ0JBQWdCLENBQUM7QUFDNUksT0FBTyxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNuRCxPQUFPLEVBQWdCLE9BQU8sRUFBNEIsTUFBTSxNQUFNLENBQUM7QUFJdkU7SUFxSUk7O09BRUc7SUFDSCw0QkFDWSxVQUFzQixFQUN0QixHQUFzQixFQUNPLGNBQWlDLEVBQ2xELGlCQUF1QztRQUovRCxpQkFLQztRQUpXLGVBQVUsR0FBVixVQUFVLENBQVk7UUFDdEIsUUFBRyxHQUFILEdBQUcsQ0FBbUI7UUFDTyxtQkFBYyxHQUFkLGNBQWMsQ0FBbUI7UUFDbEQsc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFzQjtRQXRJdkQsYUFBUSxHQUFHLElBQUksT0FBTyxFQUFXLENBQUM7UUFDbEMsc0JBQWlCLEdBQTZGO1lBQ2xILE1BQU0sQ0FBQyxVQUFBLENBQUMsSUFBSSxPQUFBLENBQUMsQ0FBQyxFQUFFLEtBQUssS0FBSSxDQUFDLFVBQVUsRUFBeEIsQ0FBd0IsQ0FBQztZQUNyQyxTQUFT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LENBQUM7aUJBQ3BDOztJQUM4QixzQkFBQztDQUFBLEFBTGhDLElBS2dDO1NBQW5CLGVBQWUiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgIERpcmVjdGl2ZSxcbiAgICBFbGVtZW50UmVmLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBIb3N0QmluZGluZyxcbiAgICBIb3N0TGlzdGVuZXIsXG4gICAgSW5wdXQsXG4gICAgTmdNb2R1bGUsXG4gICAgT25EZXN0cm95LFxuICAgIE9uSW5pdCxcbiAgICBPcHRpb25hbCxcbiAgICBPdXRwdXQsXG4gICAgSW5qZWN0XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSWd4TmF2aWdhdGlvblNlcnZpY2UsIElUb2dnbGVWaWV3IH0gZnJvbSAnLi4vLi4vY29yZS9uYXZpZ2F0aW9uJztcbmltcG9ydCB7IElneE92ZXJsYXlTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvb3ZlcmxheS9vdmVybGF5JztcbmltcG9ydCB7IE92ZXJsYXlTZXR0aW5ncywgT3ZlcmxheUV2ZW50QXJncywgQ29ubmVjdGVkUG9zaXRpb25pbmdTdHJhdGVneSwgQWJzb2x1dGVTY3JvbGxTdHJhdGVneSwgSVBvc2l0aW9uU3RyYXRlZ3kgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcyc7XG5pbXBvcnQgeyBmaWx0ZXIsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiwgU3ViamVjdCwgTW9ub1R5cGVPcGVyYXRvckZ1bmN0aW9uIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBPdmVybGF5Q2xvc2luZ0V2ZW50QXJncyB9IGZyb20gJy4uLy4uL3NlcnZpY2VzL292ZXJsYXkvdXRpbGl0aWVzJztcbmltcG9ydCB7IENhbmNlbGFibGVFdmVudEFyZ3MsIENhbmNlbGFibGVCcm93c2VyRXZlbnRBcmdzLCBJQmFzZUV2ZW50QXJncyB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbHMnO1xuXG5ARGlyZWN0aXZlKHtcbiAgICBleHBvcnRBczogJ3RvZ2dsZScsXG4gICAgc2VsZWN0b3I6ICdbaWd4VG9nZ2xlXSdcbn0pXG5leHBvcnQgY2xhc3MgSWd4VG9nZ2xlRGlyZWN0aXZlIGltcGxlbWVudHMgSVRvZ2dsZVZpZXcsIE9uSW5pdCwgT25EZXN0cm95IHtcbiAgICBwcm90ZWN0ZWQgX292ZXJsYXlJZDogc3RyaW5nO1xuICAgIHByaXZhdGUgZGVzdHJveSQgPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuICAgIHByaXZhdGUgX292ZXJsYXlTdWJGaWx0ZXI6IFtNb25vVHlwZU9wZXJhdG9yRnVuY3Rpb248T3ZlcmxheUV2ZW50QXJncz4sIE1vbm9UeXBlT3BlcmF0b3JGdW5jdGlvbjxPdmVybGF5RXZlbnRBcmdzPl0gPSBbXG4gICAgICAgIGZpbHRlcih4ID0+IHguaWQgPT09IHRoaXMuX292ZXJsYXlJZCksXG4gICAgICAgIHRha2VVbnRpbCh0aGlzLmRlc3Ryb3kkKVxuICAgIF07XG4gICAgcHJpdmF0ZSBfb3ZlcmxheU9wZW5lZFN1YjogU3Vic2NyaXB0aW9uO1xuICAgIHByaXZhdGUgX292ZXJsYXlDbG9zaW5nU3ViOiBTdWJzY3JpcHRpb247XG4gICAgcHJpdmF0ZSBfb3ZlcmxheUNsb3NlZFN1YjogU3Vic2NyaXB0aW9uO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQgYWZ0ZXIgdGhlIHRvZ2dsZSBjb250YWluZXIgaXMgb3BlbmVkLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIG9uVG9nZ2xlT3BlbmVkKGV2ZW50KSB7XG4gICAgICogICAgYWxlcnQoXCJUb2dnbGUgb3BlbmVkIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdlxuICAgICAqICAgaWd4VG9nZ2xlXG4gICAgICogICAob25PcGVuZWQpPSdvblRvZ2dsZU9wZW5lZCgkZXZlbnQpJz5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgb25PcGVuZWQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudCBiZWZvcmUgdGhlIHRvZ2dsZSBjb250YWluZXIgaXMgb3BlbmVkLlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIG9uVG9nZ2xlT3BlbmluZyhldmVudCkge1xuICAgICAqICBhbGVydChcIlRvZ2dsZSBvcGVuaW5nIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdlxuICAgICAqICAgaWd4VG9nZ2xlXG4gICAgICogICAob25PcGVuaW5nKT0nb25Ub2dnbGVPcGVuaW5nKCRldmVudCknPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBvbk9wZW5pbmcgPSBuZXcgRXZlbnRFbWl0dGVyPENhbmNlbGFibGVFdmVudEFyZ3MgJiBJQmFzZUV2ZW50QXJncz4oKTtcblxuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGV2ZW50IGFmdGVyIHRoZSB0b2dnbGUgY29udGFpbmVyIGlzIGNsb3NlZC5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBvblRvZ2dsZUNsb3NlZChldmVudCkge1xuICAgICAqICBhbGVydChcIlRvZ2dsZSBjbG9zZWQhXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2XG4gICAgICogICBpZ3hUb2dnbGVcbiAgICAgKiAgIChvbkNsb3NlZCk9J29uVG9nZ2xlQ2xvc2VkKCRldmVudCknPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBvbkNsb3NlZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGV2ZW50IGJlZm9yZSB0aGUgdG9nZ2xlIGNvbnRhaW5lciBpcyBjbG9zZWQuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogb25Ub2dnbGVDbG9zaW5nKGV2ZW50KSB7XG4gICAgICogIGFsZXJ0KFwiVG9nZ2xlIGNsb3NpbmchXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2XG4gICAgICogIGlneFRvZ2dsZVxuICAgICAqICAob25DbG9zaW5nKT0nb25Ub2dnbGVDbG9zaW5nKCRldmVudCknPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBvbkNsb3NpbmcgPSBuZXcgRXZlbnRFbWl0dGVyPENhbmNlbGFibGVCcm93c2VyRXZlbnRBcmdzICYgSUJhc2VFdmVudEFyZ3M+KCk7XG5cbiAgICBwcml2YXRlIF9jb2xsYXBzZWQgPSB0cnVlO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGNvbGxhcHNlZCgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbGxhcHNlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJZGVudGlmaWVyIHdoaWNoIGlzIHJlZ2lzdGVyZWQgaW50byBgSWd4TmF2aWdhdGlvblNlcnZpY2VgXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IG15VG9nZ2xlSWQgPSB0aGlzLnRvZ2dsZS5pZDtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBpZDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgZWxlbWVudCgpOiBIVE1MRWxlbWVudCB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5pZ3gtdG9nZ2xlLS1oaWRkZW4nKVxuICAgIEBIb3N0QmluZGluZygnYXR0ci5hcmlhLWhpZGRlbicpXG4gICAgcHVibGljIGdldCBoaWRkZW5DbGFzcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sbGFwc2VkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC10b2dnbGUnKVxuICAgIHB1YmxpYyBnZXQgZGVmYXVsdENsYXNzKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuY29sbGFwc2VkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBlbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgICAgICBwcml2YXRlIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgIEBJbmplY3QoSWd4T3ZlcmxheVNlcnZpY2UpIHByb3RlY3RlZCBvdmVybGF5U2VydmljZTogSWd4T3ZlcmxheVNlcnZpY2UsXG4gICAgICAgIEBPcHRpb25hbCgpIHByaXZhdGUgbmF2aWdhdGlvblNlcnZpY2U6IElneE5hdmlnYXRpb25TZXJ2aWNlKSB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3BlbnMgdGhlIHRvZ2dsZS5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLm15VG9nZ2xlLm9wZW4oKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgb3BlbihvdmVybGF5U2V0dGluZ3M/OiBPdmVybGF5U2V0dGluZ3MpIHtcbiAgICAgICAgLy8gIGlmIHRoZXJlIGlzIG9wZW4gYW5pbWF0aW9uIGRvIG5vdGhpbmdcbiAgICAgICAgLy8gIGlmIHRvZ2dsZSBpcyBub3QgY29sbGFwc2VkIGFuZCB0aGVyZSBpcyBubyBjbG9zZSBhbmltYXRpb24gZG8gbm90aGluZ1xuICAgICAgICBjb25zdCBpbmZvID0gdGhpcy5vdmVybGF5U2VydmljZS5nZXRPdmVybGF5QnlJZCh0aGlzLl9vdmVybGF5SWQpO1xuICAgICAgICBjb25zdCBoYXNPcGVuQW5pbWF0aW9uID0gaW5mbyA/IGluZm8ub3BlbkFuaW1hdGlvblBsYXllciA6IGZhbHNlO1xuICAgICAgICBjb25zdCBoYXNDbG9zZUFuaW1hdGlvbiA9IGluZm8gPyBpbmZvLmNsb3NlQW5pbWF0aW9uUGxheWVyIDogZmFsc2U7XG4gICAgICAgIGlmIChoYXNPcGVuQW5pbWF0aW9uIHx8ICEodGhpcy5fY29sbGFwc2VkIHx8IGhhc0Nsb3NlQW5pbWF0aW9uKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpbmZvKSB7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5SWQgPSB0aGlzLm92ZXJsYXlTZXJ2aWNlLmF0dGFjaCh0aGlzLmVsZW1lbnRSZWYsIG92ZXJsYXlTZXR0aW5ncyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jb2xsYXBzZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuXG4gICAgICAgIGNvbnN0IG9wZW5FdmVudEFyZ3M6IENhbmNlbGFibGVFdmVudEFyZ3MgPSB7IGNhbmNlbDogZmFsc2UgfTtcbiAgICAgICAgdGhpcy5vbk9wZW5pbmcuZW1pdChvcGVuRXZlbnRBcmdzKTtcbiAgICAgICAgaWYgKG9wZW5FdmVudEFyZ3MuY2FuY2VsKSB7XG4gICAgICAgICAgICB0aGlzLl9jb2xsYXBzZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vdmVybGF5U2VydmljZS5zaG93KHRoaXMuX292ZXJsYXlJZCwgb3ZlcmxheVNldHRpbmdzKTtcblxuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIHRoaXMuX292ZXJsYXlPcGVuZWRTdWIgPSB0aGlzLm92ZXJsYXlTZXJ2aWNlLm9uT3BlbmVkLnBpcGUoLi4udGhpcy5fb3ZlcmxheVN1YkZpbHRlcikuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMub25PcGVuZWQuZW1pdCgpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9vdmVybGF5Q2xvc2luZ1N1YiA9IHRoaXMub3ZlcmxheVNlcnZpY2VcbiAgICAgICAgICAgIC5vbkNsb3NpbmdcbiAgICAgICAgICAgIC5waXBlKC4uLnRoaXMuX292ZXJsYXlTdWJGaWx0ZXIpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKChlOiBPdmVybGF5Q2xvc2luZ0V2ZW50QXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50QXJnczogQ2FuY2VsYWJsZUJyb3dzZXJFdmVudEFyZ3MgPSB7IGNhbmNlbDogZmFsc2UsIGV2ZW50OiBlLmV2ZW50IH07XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNsb3NpbmcuZW1pdChldmVudEFyZ3MpO1xuICAgICAgICAgICAgICAgIGUuY2FuY2VsID0gZXZlbnRBcmdzLmNhbmNlbDtcblxuICAgICAgICAgICAgICAgIC8vICBpbiBjYXNlIGV2ZW50IGlzIG5vdCBjYW5jZWxlZCB0aGlzIHdpbGwgY2xvc2UgdGhlIHRvZ2dsZSBhbmQgd2UgbmVlZCB0byB1bnN1YnNjcmliZS5cbiAgICAgICAgICAgICAgICAvLyAgT3RoZXJ3aXNlIGlmIGZvciBzb21lIHJlYXNvbiwgZS5nLiBjbG9zZSBvbiBvdXRzaWRlIGNsaWNrLCBjbG9zZSgpIGdldHMgY2FsbGVkIGJlZm9yZVxuICAgICAgICAgICAgICAgIC8vICBvbkNsb3NlZCB3YXMgZmlyZWQgd2Ugd2lsbCBlbmQgd2l0aCBjYWxsaW5nIG9uQ2xvc2luZyBtb3JlIHRoYW4gb25jZVxuICAgICAgICAgICAgICAgIGlmICghZS5jYW5jZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhclN1YnNjcmlwdGlvbih0aGlzLl9vdmVybGF5Q2xvc2luZ1N1Yik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fb3ZlcmxheUNsb3NlZFN1YiA9IHRoaXMub3ZlcmxheVNlcnZpY2Uub25DbG9zZWRcbiAgICAgICAgICAgIC5waXBlKC4uLnRoaXMuX292ZXJsYXlTdWJGaWx0ZXIpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKHRoaXMub3ZlcmxheUNsb3NlZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSB0b2dnbGUuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5teVRvZ2dsZS5jbG9zZSgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBjbG9zZSgpIHtcbiAgICAgICAgLy8gIGlmIHRvZ2dsZSBpcyBjb2xsYXBzZWQgZG8gbm90aGluZ1xuICAgICAgICAvLyAgaWYgdGhlcmUgaXMgY2xvc2UgYW5pbWF0aW9uIGRvIG5vdGhpbmcsIHRvZ2dsZSB3aWxsIGNsb3NlIGFueXdheVxuICAgICAgICBjb25zdCBpbmZvID0gdGhpcy5vdmVybGF5U2VydmljZS5nZXRPdmVybGF5QnlJZCh0aGlzLl9vdmVybGF5SWQpO1xuICAgICAgICBjb25zdCBoYXNDbG9zZUFuaW1hdGlvbiA9IGluZm8gPyBpbmZvLmNsb3NlQW5pbWF0aW9uUGxheWVyIDogZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9jb2xsYXBzZWQgfHwgaGFzQ2xvc2VBbmltYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMub3ZlcmxheVNlcnZpY2UuaGlkZSh0aGlzLl9vdmVybGF5SWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE9wZW5zIG9yIGNsb3NlcyB0aGUgdG9nZ2xlLCBkZXBlbmRpbmcgb24gaXRzIGN1cnJlbnQgc3RhdGUuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5teVRvZ2dsZS50b2dnbGUoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgdG9nZ2xlKG92ZXJsYXlTZXR0aW5ncz86IE92ZXJsYXlTZXR0aW5ncykge1xuICAgICAgICAvLyAgaWYgdG9nZ2xlIGlzIGNvbGxhcHNlZCBjYWxsIG9wZW5cbiAgICAgICAgLy8gIGlmIHRoZXJlIGlzIGNsb3NlIGFuaW1hdGlvbiBjYWxsIG9wZW5cbiAgICAgICAgaWYgKHRoaXMuY29sbGFwc2VkIHx8IHRoaXMuaXNDbG9zaW5nKSB7XG4gICAgICAgICAgICB0aGlzLm9wZW4ob3ZlcmxheVNldHRpbmdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHB1YmxpYyBnZXQgaXNDbG9zaW5nKCkge1xuICAgICAgICBjb25zdCBpbmZvID0gdGhpcy5vdmVybGF5U2VydmljZS5nZXRPdmVybGF5QnlJZCh0aGlzLl9vdmVybGF5SWQpO1xuICAgICAgICByZXR1cm4gaW5mbyA/IGluZm8uY2xvc2VBbmltYXRpb25QbGF5ZXIgOiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXBvc2l0aW9ucyB0aGUgdG9nZ2xlLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLm15VG9nZ2xlLnJlcG9zaXRpb24oKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgcmVwb3NpdGlvbigpIHtcbiAgICAgICAgdGhpcy5vdmVybGF5U2VydmljZS5yZXBvc2l0aW9uKHRoaXMuX292ZXJsYXlJZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uSW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMubmF2aWdhdGlvblNlcnZpY2UgJiYgdGhpcy5pZCkge1xuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uU2VydmljZS5hZGQodGhpcy5pZCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nT25EZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5uYXZpZ2F0aW9uU2VydmljZSAmJiB0aGlzLmlkKSB7XG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLnJlbW92ZSh0aGlzLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuY29sbGFwc2VkICYmIHRoaXMuX292ZXJsYXlJZCkge1xuICAgICAgICAgICAgdGhpcy5vdmVybGF5U2VydmljZS5oaWRlKHRoaXMuX292ZXJsYXlJZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLm5leHQodHJ1ZSk7XG4gICAgICAgIHRoaXMuZGVzdHJveSQuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIG92ZXJsYXlDbG9zZWQgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2NvbGxhcHNlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuX292ZXJsYXlJZDtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZSgpO1xuICAgICAgICB0aGlzLm9uQ2xvc2VkLmVtaXQoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICB0aGlzLmNsZWFyU3Vic2NyaXB0aW9uKHRoaXMuX292ZXJsYXlPcGVuZWRTdWIpO1xuICAgICAgICB0aGlzLmNsZWFyU3Vic2NyaXB0aW9uKHRoaXMuX292ZXJsYXlDbG9zaW5nU3ViKTtcbiAgICAgICAgdGhpcy5jbGVhclN1YnNjcmlwdGlvbih0aGlzLl9vdmVybGF5Q2xvc2VkU3ViKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGNsZWFyU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIGlmIChzdWJzY3JpcHRpb24gJiYgIXN1YnNjcmlwdGlvbi5jbG9zZWQpIHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5ARGlyZWN0aXZlKHtcbiAgICBleHBvcnRBczogJ3RvZ2dsZS1hY3Rpb24nLFxuICAgIHNlbGVjdG9yOiAnW2lneFRvZ2dsZUFjdGlvbl0nXG59KVxuZXhwb3J0IGNsYXNzIElneFRvZ2dsZUFjdGlvbkRpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCB7XG4gICAgcHJvdGVjdGVkIF9vdmVybGF5RGVmYXVsdHM6IE92ZXJsYXlTZXR0aW5ncztcblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGUgc2V0dGluZ3MgdGhhdCBjb250cm9sIHRoZSB0b2dnbGUgb3ZlcmxheSBwb3NpdGlvbmluZywgaW50ZXJhY3Rpb24gYW5kIHNjcm9sbCBiZWhhdmlvci5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogY29uc3Qgc2V0dGluZ3M6IE92ZXJsYXlTZXR0aW5ncyA9IHtcbiAgICAgKiAgICAgIGNsb3NlT25PdXRzaWRlQ2xpY2s6IGZhbHNlLFxuICAgICAqICAgICAgbW9kYWw6IGZhbHNlXG4gICAgICogIH1cbiAgICAgKiBgYGBcbiAgICAgKiAtLS1cbiAgICAgKiBgYGBodG1sXG4gICAgICogPCEtLXNldC0tPlxuICAgICAqIDxkaXYgaWd4VG9nZ2xlQWN0aW9uIFtvdmVybGF5U2V0dGluZ3NdPVwic2V0dGluZ3NcIj48L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBvdmVybGF5U2V0dGluZ3M6IE92ZXJsYXlTZXR0aW5ncztcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hlcmUgdGhlIHRvZ2dsZSBlbGVtZW50IG92ZXJsYXkgc2hvdWxkIGJlIGF0dGFjaGVkLlxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqIDwhLS1zZXQtLT5cbiAgICAgKiA8ZGl2IGlneFRvZ2dsZUFjdGlvbiBbaWd4VG9nZ2xlT3V0bGV0XT1cIm91dGxldFwiPjwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIFdoZXJlIGBvdXRsZXRgIGluIGFuIGluc3RhbmNlIG9mIGBJZ3hPdmVybGF5T3V0bGV0RGlyZWN0aXZlYCBvciBhbiBgRWxlbWVudFJlZmBcbiAgICAgKi9cbiAgICBASW5wdXQoJ2lneFRvZ2dsZU91dGxldCcpXG4gICAgcHVibGljIG91dGxldDogSWd4T3ZlcmxheU91dGxldERpcmVjdGl2ZSB8IEVsZW1lbnRSZWY7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQElucHV0KCdpZ3hUb2dnbGVBY3Rpb24nKVxuICAgIHNldCB0YXJnZXQodGFyZ2V0OiBhbnkpIHtcbiAgICAgICAgaWYgKHRhcmdldCAhPT0gbnVsbCAmJiB0YXJnZXQgIT09ICcnKSB7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgZ2V0IHRhcmdldCgpOiBhbnkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuX3RhcmdldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hdmlnYXRpb25TZXJ2aWNlLmdldCh0aGlzLl90YXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl90YXJnZXQ7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIF90YXJnZXQ6IElUb2dnbGVWaWV3IHwgc3RyaW5nO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBlbGVtZW50OiBFbGVtZW50UmVmLCBAT3B0aW9uYWwoKSBwcml2YXRlIG5hdmlnYXRpb25TZXJ2aWNlOiBJZ3hOYXZpZ2F0aW9uU2VydmljZSkgeyB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLl9vdmVybGF5RGVmYXVsdHMgPSB7XG4gICAgICAgICAgICBwb3NpdGlvblN0cmF0ZWd5OiBuZXcgQ29ubmVjdGVkUG9zaXRpb25pbmdTdHJhdGVneSh7IHRhcmdldDogdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQgfSksXG4gICAgICAgICAgICBzY3JvbGxTdHJhdGVneTogbmV3IEFic29sdXRlU2Nyb2xsU3RyYXRlZ3koKSxcbiAgICAgICAgICAgIGNsb3NlT25PdXRzaWRlQ2xpY2s6IHRydWUsXG4gICAgICAgICAgICBtb2RhbDogZmFsc2UsXG4gICAgICAgICAgICBleGNsdWRlUG9zaXRpb25UYXJnZXQ6IHRydWVcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RMaXN0ZW5lcignY2xpY2snKVxuICAgIHB1YmxpYyBvbkNsaWNrKCkge1xuICAgICAgICBpZiAodGhpcy5vdXRsZXQpIHtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlEZWZhdWx0cy5vdXRsZXQgPSB0aGlzLm91dGxldDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNsb25lZFNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fb3ZlcmxheURlZmF1bHRzLCB0aGlzLm92ZXJsYXlTZXR0aW5ncyk7XG4gICAgICAgIHRoaXMudXBkYXRlT3ZlcmxheVNldHRpbmdzKGNsb25lZFNldHRpbmdzKTtcbiAgICAgICAgdGhpcy50YXJnZXQudG9nZ2xlKGNsb25lZFNldHRpbmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHByb3ZpZGVkIG92ZXJsYXkgc2V0dGluZ3NcbiAgICAgKiBAcGFyYW0gc2V0dGluZ3Mgc2V0dGluZ3MgdG8gdXBkYXRlXG4gICAgICogQHJldHVybnMgcmV0dXJucyB1cGRhdGVkIGNvcHkgb2YgcHJvdmlkZWQgb3ZlcmxheSBzZXR0aW5nc1xuICAgICAqL1xuICAgIHByb3RlY3RlZCB1cGRhdGVPdmVybGF5U2V0dGluZ3Moc2V0dGluZ3M6IE92ZXJsYXlTZXR0aW5ncyk6IE92ZXJsYXlTZXR0aW5ncyB7XG4gICAgICAgIGlmIChzZXR0aW5ncyAmJiBzZXR0aW5ncy5wb3NpdGlvblN0cmF0ZWd5KSB7XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvblN0cmF0ZWd5Q2xvbmU6IElQb3NpdGlvblN0cmF0ZWd5ID0gc2V0dGluZ3MucG9zaXRpb25TdHJhdGVneS5jbG9uZSgpO1xuICAgICAgICAgICAgcG9zaXRpb25TdHJhdGVneUNsb25lLnNldHRpbmdzLnRhcmdldCA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICAgICAgc2V0dGluZ3MucG9zaXRpb25TdHJhdGVneSA9IHBvc2l0aW9uU3RyYXRlZ3lDbG9uZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZXR0aW5ncztcbiAgICB9XG59XG5cbi8qKlxuICogTWFyayBhbiBlbGVtZW50IGFzIGFuIGlneE92ZXJsYXkgb3V0bGV0IGNvbnRhaW5lci5cbiAqIERpcmVjdGl2ZSBpbnN0YW5jZSBpcyBleHBvcnRlZCBhcyBgb3ZlcmxheS1vdXRsZXRgIHRvIGJlIGFzc2lnbmVkIHRvIHRlbXBsYXRlcyB2YXJpYWJsZXM6XG4gKiBgYGBodG1sXG4gKiA8ZGl2IGlneE92ZXJsYXlPdXRsZXQgI291dGxldD1cIm92ZXJsYXktb3V0bGV0XCI+PC9kaXY+XG4gKiBgYGBcbiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgZXhwb3J0QXM6ICdvdmVybGF5LW91dGxldCcsXG4gICAgc2VsZWN0b3I6ICdbaWd4T3ZlcmxheU91dGxldF0nXG59KVxuZXhwb3J0IGNsYXNzIElneE92ZXJsYXlPdXRsZXREaXJlY3RpdmUge1xuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbGVtZW50OiBFbGVtZW50UmVmKSB7IH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgcHVibGljIGdldCBuYXRpdmVFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtJZ3hUb2dnbGVEaXJlY3RpdmUsIElneFRvZ2dsZUFjdGlvbkRpcmVjdGl2ZSwgSWd4T3ZlcmxheU91dGxldERpcmVjdGl2ZV0sXG4gICAgZXhwb3J0czogW0lneFRvZ2dsZURpcmVjdGl2ZSwgSWd4VG9nZ2xlQWN0aW9uRGlyZWN0aXZlLCBJZ3hPdmVybGF5T3V0bGV0RGlyZWN0aXZlXSxcbiAgICBwcm92aWRlcnM6IFtJZ3hOYXZpZ2F0aW9uU2VydmljZV1cbn0pXG5leHBvcnQgY2xhc3MgSWd4VG9nZ2xlTW9kdWxlIHsgfVxuIl19