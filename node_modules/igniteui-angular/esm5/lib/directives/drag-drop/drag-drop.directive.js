/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Directive, ElementRef, EventEmitter, HostBinding, HostListener, Input, NgModule, NgZone, Output, Renderer2, ChangeDetectorRef, ViewContainerRef, TemplateRef, ContentChildren, QueryList } from '@angular/core';
import { animationFrameScheduler, fromEvent, interval, Subject } from 'rxjs';
import { takeUntil, throttle } from 'rxjs/operators';
import { IgxDragHandleDirective } from './drag-handle.directive';
import { DeprecateProperty } from '../../core/deprecateDecorators';
import { IgxDefaultDropStrategy } from './drag-drop.strategy';
/** @enum {number} */
var RestrictDrag = {
    VERTICALLY: 0,
    HORIZONTALLY: 1,
    NONE: 2,
};
export { RestrictDrag };
RestrictDrag[RestrictDrag.VERTICALLY] = 'VERTICALLY';
RestrictDrag[RestrictDrag.HORIZONTALLY] = 'HORIZONTALLY';
RestrictDrag[RestrictDrag.NONE] = 'NONE';
/**
 * @record
 */
export function IgxDragCustomEventDetails() { }
if (false) {
    /** @type {?} */
    IgxDragCustomEventDetails.prototype.startX;
    /** @type {?} */
    IgxDragCustomEventDetails.prototype.startY;
    /** @type {?} */
    IgxDragCustomEventDetails.prototype.pageX;
    /** @type {?} */
    IgxDragCustomEventDetails.prototype.pageY;
    /** @type {?} */
    IgxDragCustomEventDetails.prototype.owner;
    /** @type {?} */
    IgxDragCustomEventDetails.prototype.originalEvent;
}
/**
 * @record
 */
export function IDropBaseEventArgs() { }
if (false) {
    /**
     * Reference to the original event that caused the draggable element to enter the igxDrop element.
     * Can be PointerEvent, TouchEvent or MouseEvent.
     * @type {?}
     */
    IDropBaseEventArgs.prototype.originalEvent;
    /**
     * The owner igxDrop directive that triggered this event.
     * @type {?}
     */
    IDropBaseEventArgs.prototype.owner;
    /**
     * The igxDrag directive instanced on an element that entered the area of the igxDrop element
     * @type {?}
     */
    IDropBaseEventArgs.prototype.drag;
    /**
     * The data contained for the draggable element in igxDrag directive.
     * @type {?}
     */
    IDropBaseEventArgs.prototype.dragData;
    /**
     * The initial position of the pointer on X axis when the dragged element began moving
     * @type {?}
     */
    IDropBaseEventArgs.prototype.startX;
    /**
     * The initial position of the pointer on Y axis when the dragged element began moving
     * @type {?}
     */
    IDropBaseEventArgs.prototype.startY;
    /**
     * The current position of the pointer on X axis when the event was triggered.
     * Note: The browser might trigger the event with some delay and pointer would be already inside the igxDrop.
     * @type {?}
     */
    IDropBaseEventArgs.prototype.pageX;
    /**
     * The current position of the pointer on Y axis when the event was triggered.
     * Note: The browser might trigger the event with some delay and pointer would be already inside the igxDrop.
     * @type {?}
     */
    IDropBaseEventArgs.prototype.pageY;
    /**
     * The current position of the pointer on X axis relative to the container that initializes the igxDrop.
     * Note: The browser might trigger the event with some delay and pointer would be already inside the igxDrop.
     * @type {?}
     */
    IDropBaseEventArgs.prototype.offsetX;
    /**
     * The current position of the pointer on Y axis relative to the container that initializes the igxDrop.
     * Note: The browser might trigger the event with some delay and pointer would be already inside the igxDrop.
     * @type {?}
     */
    IDropBaseEventArgs.prototype.offsetY;
}
/**
 * @record
 */
export function IDropDroppedEventArgs() { }
if (false) {
    /**
     * Specifies if the default drop logic related to the event should be canceled.
     * @type {?}
     */
    IDropDroppedEventArgs.prototype.cancel;
}
/**
 * @record
 */
export function IDragBaseEventArgs() { }
if (false) {
    /**
     * Reference to the original event that caused the interaction with the element.
     * Can be PointerEvent, TouchEvent or MouseEvent.
     * @type {?}
     */
    IDragBaseEventArgs.prototype.originalEvent;
    /**
     * The owner igxDrag directive that triggered this event.
     * @type {?}
     */
    IDragBaseEventArgs.prototype.owner;
    /**
     * The initial position of the pointer on X axis when the dragged element began moving
     * @type {?}
     */
    IDragBaseEventArgs.prototype.startX;
    /**
     * The initial position of the pointer on Y axis when the dragged element began moving
     * @type {?}
     */
    IDragBaseEventArgs.prototype.startY;
    /**
     * The current position of the pointer on X axis when the event was triggered.
     * Note: The browser might trigger the event with some delay and pointer would be already inside the igxDrop.
     * @type {?}
     */
    IDragBaseEventArgs.prototype.pageX;
    /**
     * The current position of the pointer on Y axis when the event was triggered.
     * Note: The browser might trigger the event with some delay and pointer would be already inside the igxDrop.
     * @type {?}
     */
    IDragBaseEventArgs.prototype.pageY;
}
/**
 * @record
 */
export function IDragStartEventArgs() { }
if (false) {
    /**
     * Set if the the dragging should be canceled.
     * @type {?}
     */
    IDragStartEventArgs.prototype.cancel;
}
/**
 * @record
 */
export function IDragMoveEventArgs() { }
if (false) {
    /**
     * The new pageX position of the pointer that the igxDrag will use. It can be overridden to limit dragged element X movement.
     * @type {?}
     */
    IDragMoveEventArgs.prototype.nextPageX;
    /**
     * The new pageX position of the pointer that the igxDrag will use. It can be overridden to limit dragged element Y movement.
     * @type {?}
     */
    IDragMoveEventArgs.prototype.nextPageY;
}
/**
 * @record
 */
export function IDragGhostBaseEventArgs() { }
if (false) {
    /**
     * The owner igxDrag directive that triggered this event.
     * @type {?}
     */
    IDragGhostBaseEventArgs.prototype.owner;
    /**
     * Instance to the ghost element that is created when dragging starts.
     * @type {?}
     */
    IDragGhostBaseEventArgs.prototype.ghostElement;
    /**
     * Set if the ghost creation/destruction should be canceled.
     * @type {?}
     */
    IDragGhostBaseEventArgs.prototype.cancel;
}
/**
 * @record
 */
export function IDragCustomTransitionArgs() { }
if (false) {
    /** @type {?|undefined} */
    IDragCustomTransitionArgs.prototype.duration;
    /** @type {?|undefined} */
    IDragCustomTransitionArgs.prototype.timingFunction;
    /** @type {?|undefined} */
    IDragCustomTransitionArgs.prototype.delay;
}
var IgxDragLocation = /** @class */ (function () {
    function IgxDragLocation(_pageX, _pageY) {
        this._pageX = _pageX;
        this._pageY = _pageY;
        this.pageX = parseFloat(_pageX);
        this.pageY = parseFloat(_pageY);
    }
    return IgxDragLocation;
}());
export { IgxDragLocation };
if (false) {
    /** @type {?} */
    IgxDragLocation.prototype.pageX;
    /** @type {?} */
    IgxDragLocation.prototype.pageY;
    /**
     * @type {?}
     * @private
     */
    IgxDragLocation.prototype._pageX;
    /**
     * @type {?}
     * @private
     */
    IgxDragLocation.prototype._pageY;
}
var IgxDragDirective = /** @class */ (function () {
    function IgxDragDirective(cdr, element, viewContainer, zone, renderer) {
        this.cdr = cdr;
        this.element = element;
        this.viewContainer = viewContainer;
        this.zone = zone;
        this.renderer = renderer;
        this.ghostContext = null;
        /**
         * An \@Input property that indicates when the drag should start.
         * By default the drag starts after the draggable element is moved by 5px.
         * ```html
         * <div igxDrag [dragTolerance]="100">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * \@memberof IgxDragDirective
         */
        this.dragTolerance = 5;
        /**
         * An \@Input property that specifies if the base element should not be moved and a ghost element should be rendered that represents it.
         * By default it is set to `true`.
         * If it is set to `false` when dragging the base element is moved instead and no ghost elements are rendered.
         * ```html
         * <div igxDrag [ghost]="false">
         *      <span>Drag Me!</span>
         * </div>
         * ```
         * \@memberof IgxDragDirective
         */
        this.ghost = true;
        /**
         * Sets a custom class that will be added to the `ghostElement` element.
         * ```html
         * <div igxDrag [ghostClass]="'ghostElement'">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * \@memberof IgxDragDirective
         */
        this.ghostClass = '';
        /**
         * @deprecated Please use custom base styling instead.
         * An \@Input property that hides the draggable element.
         * By default it's set to false.
         * ```html
         * <div igxDrag [dragTolerance]="100" [hideBaseOnDrag]="'true'">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * \@memberof IgxDragDirective
         */
        this.hideBaseOnDrag = false;
        /**
         * @deprecated Please use provided transition functions in future.
         * An \@Input property that enables/disables the draggable element animation
         * when the element is released.
         * By default it's set to false.
         * ```html
         * <div igxDrag [animateOnRelease]="'true'">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * \@memberof IgxDragDirective
         */
        this.animateOnRelease = false;
        /**
         * Event triggered when the draggable element drag starts.
         * ```html
         * <div igxDrag (dragStart)="onDragStart()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragStart(){
         *      alert("The drag has stared!");
         * }
         * ```
         * \@memberof IgxDragDirective
         */
        this.dragStart = new EventEmitter();
        /**
         * Event triggered when the draggable element has been moved.
         * ```html
         * <div igxDrag  (dragMove)="onDragMove()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragMove(){
         *      alert("The element has moved!");
         * }
         * ```
         * \@memberof IgxDragDirective
         */
        this.dragMove = new EventEmitter();
        /**
         * Event triggered when the draggable element is released.
         * ```html
         * <div igxDrag (dragEnd)="onDragEnd()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragEnd(){
         *      alert("The drag has ended!");
         * }
         * ```
         * \@memberof IgxDragDirective
         */
        this.dragEnd = new EventEmitter();
        /**
         * Event triggered when the draggable element is clicked.
         * ```html
         * <div igxDrag (dragClick)="onDragClick()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onDragClick(){
         *      alert("The element has been clicked!");
         * }
         * ```
         * \@memberof IgxDragDirective
         */
        this.dragClick = new EventEmitter();
        /**
         * Event triggered when the drag ghost element is created.
         * ```html
         * <div igxDrag (ghostCreate)="ghostCreated()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public ghostCreated(){
         *      alert("The ghost has been created!");
         * }
         * ```
         * \@memberof IgxDragDirective
         */
        this.ghostCreate = new EventEmitter();
        /**
         * Event triggered when the drag ghost element is created.
         * ```html
         * <div igxDrag (ghostDestroy)="ghostDestroyed()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public ghostDestroyed(){
         *      alert("The ghost has been destroyed!");
         * }
         * ```
         * \@memberof IgxDragDirective
         */
        this.ghostDestroy = new EventEmitter();
        /**
         * Event triggered after the draggable element is released and after its animation has finished.
         * ```html
         * <div igxDrag (transitioned)="onMoveEnd()">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * ```typescript
         * public onMoveEnd(){
         *      alert("The move has ended!");
         * }
         * ```
         * \@memberof IgxDragDirective
         */
        this.transitioned = new EventEmitter();
        /**
         * @hidden
         */
        this._visibility = 'visible';
        /**
         * @hidden
         */
        this.baseClass = true;
        /**
         * @hidden
         */
        this.selectDisabled = false;
        /**
         * @hidden
         */
        this.defaultReturnDuration = '0.5s';
        /**
         * @hidden
         */
        this.animInProgress = false;
        this._baseMarginLeft = 0;
        this._baseMarginTop = 0;
        this._startX = 0;
        this._startY = 0;
        this._lastX = 0;
        this._lastY = 0;
        this._dragStarted = false;
        this._ghostHostX = 0;
        this._ghostHostY = 0;
        this._pointerDownId = null;
        this._clicked = false;
        this._lastDropArea = null;
        this._destroy = new Subject();
        this._removeOnDestroy = true;
    }
    Object.defineProperty(IgxDragDirective.prototype, "ghostOffsetX", {
        get: /**
         * @return {?}
         */
        function () {
            return this._offsetX !== undefined ? this._offsetX : this._defaultOffsetX;
        },
        /**
         * An @Input property that specifies the offset of the dragged element relative to the mouse in pixels.
         * By default it's taking the relative position to the mouse when the drag started and keeps it the same.
         * ```html
         * <div #hostDiv></div>
         * <div igxDrag [ghostOffsetX]="0">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * @memberof IgxDragDirective
         */
        set: /**
         * An \@Input property that specifies the offset of the dragged element relative to the mouse in pixels.
         * By default it's taking the relative position to the mouse when the drag started and keeps it the same.
         * ```html
         * <div #hostDiv></div>
         * <div igxDrag [ghostOffsetX]="0">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * \@memberof IgxDragDirective
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._offsetX = parseInt(value, 10);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDragDirective.prototype, "ghostOffsetY", {
        get: /**
         * @return {?}
         */
        function () {
            return this._offsetY !== undefined ? this._offsetY : this._defaultOffsetY;
        },
        /**
         * An @Input property that specifies the offset of the dragged element relative to the mouse in pixels.
         * By default it's taking the relative position to the mouse when the drag started and keeps it the same.
         * ```html
         * <div #hostDiv></div>
         * <div igxDrag [ghostOffsetY]="0">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * @memberof IgxDragDirective
         */
        set: /**
         * An \@Input property that specifies the offset of the dragged element relative to the mouse in pixels.
         * By default it's taking the relative position to the mouse when the drag started and keeps it the same.
         * ```html
         * <div #hostDiv></div>
         * <div igxDrag [ghostOffsetY]="0">
         *         <span>Drag Me!</span>
         * </div>
         * ```
         * \@memberof IgxDragDirective
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._offsetY = parseInt(value, 10);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDragDirective.prototype, "visible", {
        /**
         * Returns the visibility state of the draggable element.
         * ```typescript
         * @ViewChild("myDrag" ,{read: IgxDragDirective})
         * public myDrag: IgxDragDirective;
         * ngAfterViewInit(){
         *     let dragVisibility = this.myDrag.visible;
         * }
         * ```
         */
        get: /**
         * Returns the visibility state of the draggable element.
         * ```typescript
         * \@ViewChild("myDrag" ,{read: IgxDragDirective})
         * public myDrag: IgxDragDirective;
         * ngAfterViewInit(){
         *     let dragVisibility = this.myDrag.visible;
         * }
         * ```
         * @return {?}
         */
        function () {
            return this._visibility === 'visible';
        },
        /**
         * @deprecated Please use native angular ways of hiding it using custom to the base element styling for future versions.
         * Sets the visibility of the draggable element.
         * ```typescript
         * @ViewChild("myDrag" ,{read: IgxDragDirective})
         * public myDrag: IgxDragDirective;
         * ngAfterViewInit(){
         *     this.myDrag.visible = false;
         * }
         * ```
         */
        set: /**
         * @deprecated Please use native angular ways of hiding it using custom to the base element styling for future versions.
         * Sets the visibility of the draggable element.
         * ```typescript
         * \@ViewChild("myDrag" ,{read: IgxDragDirective})
         * public myDrag: IgxDragDirective;
         * ngAfterViewInit(){
         *     this.myDrag.visible = false;
         * }
         * ```
         * @param {?} bVisible
         * @return {?}
         */
        function (bVisible) {
            this._visibility = bVisible ? 'visible' : 'hidden';
            this.cdr.detectChanges();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDragDirective.prototype, "location", {
        /**
         * Gets the current location of the element relative to the page.
         */
        get: /**
         * Gets the current location of the element relative to the page.
         * @return {?}
         */
        function () {
            return new IgxDragLocation(this.pageX, this.pageY);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDragDirective.prototype, "originLocation", {
        /**
         * Gets the original location of the element before dragging started.
         */
        get: /**
         * Gets the original location of the element before dragging started.
         * @return {?}
         */
        function () {
            return new IgxDragLocation(this.baseOriginLeft, this.baseOriginTop);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDragDirective.prototype, "pointerEventsEnabled", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return typeof PointerEvent !== 'undefined';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDragDirective.prototype, "touchEventsEnabled", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            return 'ontouchstart' in window;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDragDirective.prototype, "pageX", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            if (this.ghost && this.ghostElement) {
                return this.ghostLeft;
            }
            return this.baseLeft;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDragDirective.prototype, "pageY", {
        /**
         * @hidden
         */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            if (this.ghost && this.ghostElement) {
                return this.ghostTop;
            }
            return this.baseTop;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDragDirective.prototype, "baseLeft", {
        get: /**
         * @protected
         * @return {?}
         */
        function () {
            return this.element.nativeElement.getBoundingClientRect().left;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDragDirective.prototype, "baseTop", {
        get: /**
         * @protected
         * @return {?}
         */
        function () {
            return this.element.nativeElement.getBoundingClientRect().top;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDragDirective.prototype, "baseOriginLeft", {
        get: /**
         * @protected
         * @return {?}
         */
        function () {
            return this.baseLeft - this.getTransformX(this.element.nativeElement);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDragDirective.prototype, "baseOriginTop", {
        get: /**
         * @protected
         * @return {?}
         */
        function () {
            return this.baseTop - this.getTransformY(this.element.nativeElement);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDragDirective.prototype, "ghostLeft", {
        get: /**
         * @protected
         * @return {?}
         */
        function () {
            return parseInt(this.ghostElement.style.left, 10) + this._ghostHostX;
        },
        set: /**
         * @protected
         * @param {?} pageX
         * @return {?}
         */
        function (pageX) {
            var _this = this;
            // To Do: Remove requestAnimationFrame when deprecated animations inputs are removed as well.
            // We use requestAnimationFrame for the old drop animations in combination with updateDragRelativePos.
            requestAnimationFrame(function () {
                if (_this.ghostElement) {
                    // We need to take into account marginLeft, since top style does not include margin, but pageX includes the margin.
                    /** @type {?} */
                    var ghostMarginLeft = parseInt(document.defaultView.getComputedStyle(_this.ghostElement)['margin-left'], 10);
                    // If ghost host is defined it needs to be taken into account.
                    _this.ghostElement.style.left = (pageX - ghostMarginLeft - _this._ghostHostX) + 'px';
                }
            });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IgxDragDirective.prototype, "ghostTop", {
        get: /**
         * @protected
         * @return {?}
         */
        function () {
            return parseInt(this.ghostElement.style.top, 10) + this._ghostHostY;
        },
        set: /**
         * @protected
         * @param {?} pageY
         * @return {?}
         */
        function (pageY) {
            var _this = this;
            // To Do: Remove requestAnimationFrame when deprecated animations inputs are removed as well.
            // We use requestAnimationFrame for the old drop animations in combination with updateDragRelativePos.
            requestAnimationFrame(function () {
                if (_this.ghostElement) {
                    // We need to take into account marginTop, since top style does not include margin, but pageY includes the margin.
                    /** @type {?} */
                    var ghostMarginTop = parseInt(document.defaultView.getComputedStyle(_this.ghostElement)['margin-top'], 10);
                    // If ghost host is defined it needs to be taken into account.
                    _this.ghostElement.style.top = (pageY - ghostMarginTop - _this._ghostHostY) + 'px';
                }
            });
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxDragDirective.prototype.ngAfterContentInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this.dragHandles || !this.dragHandles.length) {
            // Set user select none to the whole draggable element if no drag handles are defined.
            this.selectDisabled = true;
        }
        // Bind events
        this.zone.runOutsideAngular(function () {
            /** @type {?} */
            var targetElements = _this.dragHandles && _this.dragHandles.length ?
                _this.dragHandles.map(function (item) { return item.element.nativeElement; }) : [_this.element.nativeElement];
            targetElements.forEach(function (element) {
                if (_this.pointerEventsEnabled) {
                    fromEvent(element, 'pointerdown').pipe(takeUntil(_this._destroy))
                        .subscribe(function (res) { return _this.onPointerDown(res); });
                    fromEvent(element, 'pointermove').pipe(throttle(function () { return interval(0, animationFrameScheduler); }), takeUntil(_this._destroy)).subscribe(function (res) { return _this.onPointerMove(res); });
                    fromEvent(element, 'pointerup').pipe(takeUntil(_this._destroy))
                        .subscribe(function (res) { return _this.onPointerUp(res); });
                    if (!_this.ghost) {
                        // Do not bind `lostpointercapture` to the target, because we will bind it on the ghost later.
                        fromEvent(element, 'lostpointercapture').pipe(takeUntil(_this._destroy))
                            .subscribe(function (res) { return _this.onPointerLost(res); });
                    }
                }
                else if (_this.touchEventsEnabled) {
                    fromEvent(element, 'touchstart').pipe(takeUntil(_this._destroy))
                        .subscribe(function (res) { return _this.onPointerDown(res); });
                }
                else {
                    // We don't have pointer events and touch events. Use then mouse events.
                    fromEvent(element, 'mousedown').pipe(takeUntil(_this._destroy))
                        .subscribe(function (res) { return _this.onPointerDown(res); });
                }
            });
            // We should bind to document events only once when there are no pointer events.
            if (!_this.pointerEventsEnabled && _this.touchEventsEnabled) {
                fromEvent(document.defaultView, 'touchmove').pipe(throttle(function () { return interval(0, animationFrameScheduler); }), takeUntil(_this._destroy)).subscribe(function (res) { return _this.onPointerMove(res); });
                fromEvent(document.defaultView, 'touchend').pipe(takeUntil(_this._destroy))
                    .subscribe(function (res) { return _this.onPointerUp(res); });
            }
            else if (!_this.pointerEventsEnabled) {
                fromEvent(document.defaultView, 'mousemove').pipe(throttle(function () { return interval(0, animationFrameScheduler); }), takeUntil(_this._destroy)).subscribe(function (res) { return _this.onPointerMove(res); });
                fromEvent(document.defaultView, 'mouseup').pipe(takeUntil(_this._destroy))
                    .subscribe(function (res) { return _this.onPointerUp(res); });
            }
            _this.element.nativeElement.addEventListener('transitionend', function (args) {
                _this.onTransitionEnd(args);
            });
        });
        this._baseMarginLeft = parseInt(document.defaultView.getComputedStyle(this.element.nativeElement)['margin-left'], 10);
        this._baseMarginTop = parseInt(document.defaultView.getComputedStyle(this.element.nativeElement)['margin-top'], 10);
        this._baseOriginX = this.baseLeft;
        this._baseOriginY = this.baseTop;
        this._ghostStartX = this.baseLeft;
        this._ghostStartY = this.baseTop;
        // Set transition duration to 0s. This also helps with setting `visibility: hidden` to the base to not lag.
        this.element.nativeElement.style.transitionDuration = '0.0s';
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxDragDirective.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        this._destroy.next(true);
        this._destroy.complete();
        if (this.ghost && this.ghostElement && this._removeOnDestroy) {
            this.ghostElement.parentNode.removeChild(this.ghostElement);
            this.ghostElement = null;
        }
    };
    /**
     * Sets desired location of the base element or ghost element if rended relative to the document.
     * @param newLocation New location that should be applied. It is advised to get new location using getBoundingClientRects() + scroll.
     */
    /**
     * Sets desired location of the base element or ghost element if rended relative to the document.
     * @param {?} newLocation New location that should be applied. It is advised to get new location using getBoundingClientRects() + scroll.
     * @return {?}
     */
    IgxDragDirective.prototype.setLocation = /**
     * Sets desired location of the base element or ghost element if rended relative to the document.
     * @param {?} newLocation New location that should be applied. It is advised to get new location using getBoundingClientRects() + scroll.
     * @return {?}
     */
    function (newLocation) {
        // We do not subtract marginLeft and marginTop here because here we calculate deltas.
        if (this.ghost && this.ghostElement) {
            /** @type {?} */
            var offsetHostX = this.ghostHost ? this.ghostHostOffsetLeft(this.ghostHost) : 0;
            /** @type {?} */
            var offsetHostY = this.ghostHost ? this.ghostHostOffsetTop(this.ghostHost) : 0;
            this.ghostLeft = newLocation.pageX - offsetHostX + this.getWindowScrollLeft();
            this.ghostTop = newLocation.pageY - offsetHostY + this.getWindowScrollTop();
        }
        else if (!this.ghost) {
            /** @type {?} */
            var deltaX = newLocation.pageX - this.pageX;
            /** @type {?} */
            var deltaY = newLocation.pageY - this.pageY;
            /** @type {?} */
            var transformX = this.getTransformX(this.element.nativeElement);
            /** @type {?} */
            var transformY = this.getTransformY(this.element.nativeElement);
            this.setTransformXY(transformX + deltaX, transformY + deltaY);
        }
        this._startX = this.baseLeft;
        this._startY = this.baseTop;
    };
    /**
     * Animates the base or ghost element depending on the `ghost` input to its initial location.
     * If `ghost` is true but there is not ghost rendered, it will be created and animated.
     * If the base element has changed its DOM position its initial location will be changed accordingly.
     * @param customAnimArgs Custom transition properties that will be applied when performing the transition.
     * @param startLocation Start location from where the transition should start.
     */
    /**
     * Animates the base or ghost element depending on the `ghost` input to its initial location.
     * If `ghost` is true but there is not ghost rendered, it will be created and animated.
     * If the base element has changed its DOM position its initial location will be changed accordingly.
     * @param {?=} customAnimArgs Custom transition properties that will be applied when performing the transition.
     * @param {?=} startLocation Start location from where the transition should start.
     * @return {?}
     */
    IgxDragDirective.prototype.transitionToOrigin = /**
     * Animates the base or ghost element depending on the `ghost` input to its initial location.
     * If `ghost` is true but there is not ghost rendered, it will be created and animated.
     * If the base element has changed its DOM position its initial location will be changed accordingly.
     * @param {?=} customAnimArgs Custom transition properties that will be applied when performing the transition.
     * @param {?=} startLocation Start location from where the transition should start.
     * @return {?}
     */
    function (customAnimArgs, startLocation) {
        var _this = this;
        if ((!!startLocation && startLocation.pageX === this.baseOriginLeft && startLocation.pageY === this.baseOriginLeft) ||
            (!startLocation && this.ghost && !this.ghostElement)) {
            return;
        }
        if (!!startLocation && startLocation.pageX !== this.pageX && startLocation.pageY !== this.pageY) {
            if (this.ghost && !this.ghostElement) {
                this._startX = startLocation.pageX;
                this._startY = startLocation.pageY;
                this._ghostStartX = this._startX;
                this._ghostStartY = this._startY;
                this.createGhost(this._startX, this._startY);
            }
            this.setLocation(startLocation);
        }
        this.animInProgress = true;
        // Use setTimeout because we need to be sure that the element is positioned first correctly if there is start location.
        setTimeout(function () {
            if (_this.ghost) {
                _this.ghostElement.style.transitionProperty = 'top, left';
                _this.ghostElement.style.transitionDuration =
                    customAnimArgs && customAnimArgs.duration ? customAnimArgs.duration + 's' : _this.defaultReturnDuration;
                _this.ghostElement.style.transitionTimingFunction =
                    customAnimArgs && customAnimArgs.timingFunction ? customAnimArgs.timingFunction : '';
                _this.ghostElement.style.transitionDelay = customAnimArgs && customAnimArgs.delay ? customAnimArgs.delay + 's' : '';
                _this.setLocation(new IgxDragLocation(_this.baseLeft, _this.baseTop));
            }
            else if (!_this.ghost) {
                _this.element.nativeElement.style.transitionProperty = 'transform';
                _this.element.nativeElement.style.transitionDuration =
                    customAnimArgs && customAnimArgs.duration ? customAnimArgs.duration + 's' : _this.defaultReturnDuration;
                _this.element.nativeElement.style.transitionTimingFunction =
                    customAnimArgs && customAnimArgs.timingFunction ? customAnimArgs.timingFunction : '';
                _this.element.nativeElement.style.transitionDelay = customAnimArgs && customAnimArgs.delay ? customAnimArgs.delay + 's' : '';
                _this._startX = _this.baseLeft;
                _this._startY = _this.baseTop;
                _this.setTransformXY(0, 0);
            }
        }, 0);
    };
    /**
     * Animates the base or ghost element to a specific target location or other element using transition.
     * If `ghost` is true but there is not ghost rendered, it will be created and animated.
     * It is recommended to use 'getBoundingClientRects() + pageScroll' when determining desired location.
     * @param target Target that the base or ghost will transition to. It can be either location in the page or another HTML element.
     * @param customAnimArgs Custom transition properties that will be applied when performing the transition.
     * @param startLocation Start location from where the transition should start.
     */
    /**
     * Animates the base or ghost element to a specific target location or other element using transition.
     * If `ghost` is true but there is not ghost rendered, it will be created and animated.
     * It is recommended to use 'getBoundingClientRects() + pageScroll' when determining desired location.
     * @param {?} target Target that the base or ghost will transition to. It can be either location in the page or another HTML element.
     * @param {?=} customAnimArgs Custom transition properties that will be applied when performing the transition.
     * @param {?=} startLocation Start location from where the transition should start.
     * @return {?}
     */
    IgxDragDirective.prototype.transitionTo = /**
     * Animates the base or ghost element to a specific target location or other element using transition.
     * If `ghost` is true but there is not ghost rendered, it will be created and animated.
     * It is recommended to use 'getBoundingClientRects() + pageScroll' when determining desired location.
     * @param {?} target Target that the base or ghost will transition to. It can be either location in the page or another HTML element.
     * @param {?=} customAnimArgs Custom transition properties that will be applied when performing the transition.
     * @param {?=} startLocation Start location from where the transition should start.
     * @return {?}
     */
    function (target, customAnimArgs, startLocation) {
        var _this = this;
        if (!!startLocation && this.ghost && !this.ghostElement) {
            this._startX = startLocation.pageX;
            this._startY = startLocation.pageY;
            this._ghostStartX = this._startX;
            this._ghostStartY = this._startY;
        }
        else if (!!startLocation && (!this.ghost || this.ghostElement)) {
            this.setLocation(startLocation);
        }
        else if (this.ghost && !this.ghostElement) {
            this._startX = this.baseLeft;
            this._startY = this.baseTop;
            this._ghostStartX = this._startX + this.getWindowScrollLeft();
            this._ghostStartY = this._startY + this.getWindowScrollTop();
        }
        if (this.ghost && !this.ghostElement) {
            this.createGhost(this._startX, this._startY);
        }
        this.animInProgress = true;
        // Use setTimeout because we need to be sure that the element is positioned first correctly if there is start location.
        setTimeout(function () {
            /** @type {?} */
            var movedElem = _this.ghost ? _this.ghostElement : _this.element.nativeElement;
            movedElem.style.transitionProperty = _this.ghost && _this.ghostElement ? 'left, top' : 'transform';
            movedElem.style.transitionDuration =
                customAnimArgs && customAnimArgs.duration ? customAnimArgs.duration + 's' : _this.defaultReturnDuration;
            movedElem.style.transitionTimingFunction =
                customAnimArgs && customAnimArgs.timingFunction ? customAnimArgs.timingFunction : '';
            movedElem.style.transitionDelay = customAnimArgs && customAnimArgs.delay ? customAnimArgs.delay + 's' : '';
            if (target instanceof IgxDragLocation) {
                _this.setLocation(new IgxDragLocation(target.pageX, target.pageY));
            }
            else {
                /** @type {?} */
                var targetRects = target.nativeElement.getBoundingClientRect();
                _this.setLocation(new IgxDragLocation(targetRects.left - _this.getWindowScrollLeft(), targetRects.top - _this.getWindowScrollTop()));
            }
        }, 0);
    };
    /**
     * @hidden
     * Method bound to the PointerDown event of the base element igxDrag is initialized.
     * @param event PointerDown event captured
     */
    /**
     * @hidden
     * Method bound to the PointerDown event of the base element igxDrag is initialized.
     * @param {?} event PointerDown event captured
     * @return {?}
     */
    IgxDragDirective.prototype.onPointerDown = /**
     * @hidden
     * Method bound to the PointerDown event of the base element igxDrag is initialized.
     * @param {?} event PointerDown event captured
     * @return {?}
     */
    function (event) {
        this._clicked = true;
        this._pointerDownId = event.pointerId;
        // Set pointer capture so we detect pointermove even if mouse is out of bounds until ghostElement is created.
        /** @type {?} */
        var handleFound = this.dragHandles.find(function (handle) { return handle.element.nativeElement === event.currentTarget; });
        /** @type {?} */
        var targetElement = handleFound ? handleFound.element.nativeElement : this.element.nativeElement;
        if (this.pointerEventsEnabled) {
            targetElement.setPointerCapture(this._pointerDownId);
        }
        else {
            targetElement.focus();
            event.preventDefault();
        }
        if (!this._baseOriginX && !this._baseOriginY) {
            this._baseOriginX = this.baseLeft;
            this._baseOriginY = this.baseTop;
        }
        if (this.pointerEventsEnabled || !this.touchEventsEnabled) {
            // Check first for pointer events or non touch, because we can have pointer events and touch events at once.
            this._startX = event.pageX;
            this._startY = event.pageY;
        }
        else if (this.touchEventsEnabled) {
            this._startX = event.touches[0].pageX;
            this._startY = event.touches[0].pageY;
        }
        this._defaultOffsetX = this.baseLeft - this._startX + this.getWindowScrollLeft();
        this._defaultOffsetY = this.baseTop - this._startY + this.getWindowScrollTop();
        this._ghostStartX = this._startX + this.ghostOffsetX;
        this._ghostStartY = this._startY + this.ghostOffsetY;
        this._lastX = this._startX;
        this._lastY = this._startY;
    };
    /**
     * @hidden
     * Perform drag move logic when dragging and dispatching events if there is igxDrop under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the ghostElement is rendered the pointerId is reassigned it. Then this method is bound to it.
     * @param event PointerMove event captured
     */
    /**
     * @hidden
     * Perform drag move logic when dragging and dispatching events if there is igxDrop under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the ghostElement is rendered the pointerId is reassigned it. Then this method is bound to it.
     * @param {?} event PointerMove event captured
     * @return {?}
     */
    IgxDragDirective.prototype.onPointerMove = /**
     * @hidden
     * Perform drag move logic when dragging and dispatching events if there is igxDrop under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the ghostElement is rendered the pointerId is reassigned it. Then this method is bound to it.
     * @param {?} event PointerMove event captured
     * @return {?}
     */
    function (event) {
        var _this = this;
        if (this._clicked) {
            /** @type {?} */
            var pageX = void 0;
            /** @type {?} */
            var pageY = void 0;
            if (this.pointerEventsEnabled || !this.touchEventsEnabled) {
                // Check first for pointer events or non touch, because we can have pointer events and touch events at once.
                pageX = event.pageX;
                pageY = event.pageY;
            }
            else if (this.touchEventsEnabled) {
                pageX = event.touches[0].pageX;
                pageY = event.touches[0].pageY;
                // Prevent scrolling on touch while dragging
                event.preventDefault();
            }
            /** @type {?} */
            var totalMovedX = pageX - this._startX;
            /** @type {?} */
            var totalMovedY = pageY - this._startY;
            if (!this._dragStarted &&
                (Math.abs(totalMovedX) > this.dragTolerance || Math.abs(totalMovedY) > this.dragTolerance)) {
                /** @type {?} */
                var dragStartArgs_1 = {
                    originalEvent: event,
                    owner: this,
                    startX: pageX - totalMovedX,
                    startY: pageY - totalMovedY,
                    pageX: pageX,
                    pageY: pageY,
                    cancel: false
                };
                this.zone.run(function () {
                    _this.dragStart.emit(dragStartArgs_1);
                });
                if (!dragStartArgs_1.cancel) {
                    this._dragStarted = true;
                    if (this.ghost) {
                        // We moved enough so ghostElement can be rendered and actual dragging to start.
                        // When creating it will take into account any offset set by the user by default.
                        this.createGhost(pageX, pageY);
                    }
                    else if (this._offsetX !== undefined || this._offsetY !== undefined) {
                        // There is no need for ghost, but we will need to position initially the base element to reflect any offset.
                        /** @type {?} */
                        var transformX = (this._offsetX !== undefined ? this._offsetX - this._defaultOffsetX : 0) +
                            this.getTransformX(this.element.nativeElement);
                        /** @type {?} */
                        var transformY = (this._offsetY !== undefined ? this._offsetY - this._defaultOffsetY : 0) +
                            this.getTransformY(this.element.nativeElement);
                        this.setTransformXY(transformX, transformY);
                    }
                }
                else {
                    return;
                }
            }
            else if (!this._dragStarted) {
                return;
            }
            /** @type {?} */
            var moveArgs = {
                originalEvent: event,
                owner: this,
                startX: this._startX,
                startY: this._startY,
                pageX: this._lastX,
                pageY: this._lastY,
                nextPageX: pageX,
                nextPageY: pageY,
                cancel: false
            };
            this.dragMove.emit(moveArgs);
            /** @type {?} */
            var setPageX = moveArgs.nextPageX;
            /** @type {?} */
            var setPageY = moveArgs.nextPageY;
            /** @type {?} */
            var updatedMovedX = setPageX - this._startX;
            /** @type {?} */
            var updatedMovedY = setPageY - this._startY;
            if (!moveArgs.cancel) {
                if (this.ghost) {
                    this.ghostLeft = this._ghostStartX + updatedMovedX;
                    this.ghostTop = this._ghostStartY + updatedMovedY;
                }
                else {
                    /** @type {?} */
                    var lastMovedX = setPageX - this._lastX;
                    /** @type {?} */
                    var lastMovedY = setPageY - this._lastY;
                    /** @type {?} */
                    var translateX = this.getTransformX(this.element.nativeElement) + lastMovedX;
                    /** @type {?} */
                    var translateY = this.getTransformY(this.element.nativeElement) + lastMovedY;
                    this.setTransformXY(translateX, translateY);
                }
                this.dispatchDragEvents(pageX, pageY, event);
            }
            this._lastX = setPageX;
            this._lastY = setPageY;
        }
    };
    /**
     * @hidden
     * Perform drag end logic when releasing the ghostElement and dispatching drop event if igxDrop is under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the ghostElement is rendered the pointerId is reassigned to it. Then this method is bound to it.
     * @param event PointerUp event captured
     */
    /**
     * @hidden
     * Perform drag end logic when releasing the ghostElement and dispatching drop event if igxDrop is under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the ghostElement is rendered the pointerId is reassigned to it. Then this method is bound to it.
     * @param {?} event PointerUp event captured
     * @return {?}
     */
    IgxDragDirective.prototype.onPointerUp = /**
     * @hidden
     * Perform drag end logic when releasing the ghostElement and dispatching drop event if igxDrop is under the pointer.
     * This method is bound at first at the base element.
     * If dragging starts and after the ghostElement is rendered the pointerId is reassigned to it. Then this method is bound to it.
     * @param {?} event PointerUp event captured
     * @return {?}
     */
    function (event) {
        var _this = this;
        if (!this._clicked) {
            return;
        }
        /** @type {?} */
        var pageX;
        /** @type {?} */
        var pageY;
        if (this.pointerEventsEnabled || !this.touchEventsEnabled) {
            // Check first for pointer events or non touch, because we can have pointer events and touch events at once.
            pageX = event.pageX;
            pageY = event.pageY;
        }
        else if (this.touchEventsEnabled) {
            pageX = event.touches[0].pageX;
            pageY = event.touches[0].pageY;
            // Prevent scrolling on touch while dragging
            event.preventDefault();
        }
        /** @type {?} */
        var eventArgs = {
            originalEvent: event,
            owner: this,
            startX: this._startX,
            startY: this._startY,
            pageX: pageX,
            pageY: pageY
        };
        this._pointerDownId = null;
        this._clicked = false;
        if (this._dragStarted) {
            if (this._lastDropArea && this._lastDropArea !== this.element.nativeElement) {
                this.dispatchDropEvent(event.pageX, event.pageY, event);
            }
            else if (this.animateOnRelease) {
                this.transitionToOrigin();
            }
            this.zone.run(function () {
                _this.dragEnd.emit(eventArgs);
            });
            if (!this.animInProgress) {
                this.onTransitionEnd(null);
            }
        }
        else {
            // Trigger our own click event because when there is no ghost, native click cannot be prevented when dragging.
            this.zone.run(function () {
                _this.dragClick.emit(eventArgs);
            });
        }
    };
    /**
     * @hidden
     * Execute this method whe the pointer capture has been lost.
     * This means that during dragging the user has performed other action like right clicking and then clicking somewhere else.
     * This method will ensure that the drag state is being reset in this case as if the user released the dragged element.
     * @param event Event captured
     */
    /**
     * @hidden
     * Execute this method whe the pointer capture has been lost.
     * This means that during dragging the user has performed other action like right clicking and then clicking somewhere else.
     * This method will ensure that the drag state is being reset in this case as if the user released the dragged element.
     * @param {?} event Event captured
     * @return {?}
     */
    IgxDragDirective.prototype.onPointerLost = /**
     * @hidden
     * Execute this method whe the pointer capture has been lost.
     * This means that during dragging the user has performed other action like right clicking and then clicking somewhere else.
     * This method will ensure that the drag state is being reset in this case as if the user released the dragged element.
     * @param {?} event Event captured
     * @return {?}
     */
    function (event) {
        var _this = this;
        if (!this._clicked) {
            return;
        }
        /** @type {?} */
        var eventArgs = {
            originalEvent: event,
            owner: this,
            startX: this._startX,
            startY: this._startY,
            pageX: event.pageX,
            pageY: event.pageY
        };
        this._pointerDownId = null;
        this._clicked = false;
        if (this._dragStarted) {
            this.zone.run(function () {
                _this.dragEnd.emit(eventArgs);
            });
            if (this.animateOnRelease) {
                this.transitionToOrigin();
            }
            else if (!this.animInProgress) {
                this.onTransitionEnd(null);
            }
        }
    };
    /**
     * @hidden
     * Create ghost element - if a Node object is provided it creates a clone of that node,
     * otherwise it clones the host element.
     * Bind all needed events.
     * @param pageX Latest pointer position on the X axis relative to the page.
     * @param pageY Latest pointer position on the Y axis relative to the page.
     * @param node The Node object to be cloned.
     */
    /**
     * @hidden
     * Create ghost element - if a Node object is provided it creates a clone of that node,
     * otherwise it clones the host element.
     * Bind all needed events.
     * @protected
     * @param {?} pageX Latest pointer position on the X axis relative to the page.
     * @param {?} pageY Latest pointer position on the Y axis relative to the page.
     * @param {?=} node The Node object to be cloned.
     * @return {?}
     */
    IgxDragDirective.prototype.createGhost = /**
     * @hidden
     * Create ghost element - if a Node object is provided it creates a clone of that node,
     * otherwise it clones the host element.
     * Bind all needed events.
     * @protected
     * @param {?} pageX Latest pointer position on the X axis relative to the page.
     * @param {?} pageY Latest pointer position on the Y axis relative to the page.
     * @param {?=} node The Node object to be cloned.
     * @return {?}
     */
    function (pageX, pageY, node) {
        var _this = this;
        if (node === void 0) { node = null; }
        if (!this.ghost) {
            return;
        }
        /** @type {?} */
        var dynamicGhostRef;
        if (this.ghostTemplate) {
            dynamicGhostRef = this.viewContainer.createEmbeddedView(this.ghostTemplate, this.ghostContext);
            this.ghostElement = dynamicGhostRef.rootNodes[0];
        }
        else {
            this.ghostElement = node ? node.cloneNode(true) : this.element.nativeElement.cloneNode(true);
        }
        /** @type {?} */
        var totalMovedX = pageX - this._startX;
        /** @type {?} */
        var totalMovedY = pageY - this._startY;
        this._ghostHostX = this.ghostHost ? this.ghostHostOffsetLeft(this.ghostHost) : 0;
        this._ghostHostY = this.ghostHost ? this.ghostHostOffsetTop(this.ghostHost) : 0;
        this.ghostElement.style.transitionDuration = '0.0s';
        this.ghostElement.style.position = 'absolute';
        if (this.ghostClass) {
            this.renderer.addClass(this.ghostElement, this.ghostClass);
        }
        /** @type {?} */
        var createEventArgs = {
            owner: this,
            ghostElement: this.ghostElement,
            cancel: false
        };
        this.ghostCreate.emit(createEventArgs);
        if (createEventArgs.cancel) {
            this.ghostElement = null;
            if (this.ghostTemplate && dynamicGhostRef) {
                dynamicGhostRef.destroy();
            }
            return;
        }
        if (this.ghostHost) {
            this.ghostHost.appendChild(this.ghostElement);
        }
        else {
            document.body.appendChild(this.ghostElement);
        }
        /** @type {?} */
        var ghostMarginLeft = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-left'], 10);
        /** @type {?} */
        var ghostMarginTop = parseInt(document.defaultView.getComputedStyle(this.ghostElement)['margin-top'], 10);
        this.ghostElement.style.left = (this._ghostStartX - ghostMarginLeft + totalMovedX - this._ghostHostX) + 'px';
        this.ghostElement.style.top = (this._ghostStartY - ghostMarginTop + totalMovedY - this._ghostHostX) + 'px';
        if (this.pointerEventsEnabled) {
            // The ghostElement takes control for moving and dragging after it has been rendered.
            if (this._pointerDownId !== null) {
                this.ghostElement.setPointerCapture(this._pointerDownId);
            }
            this.ghostElement.addEventListener('pointermove', function (args) {
                _this.onPointerMove(args);
            });
            this.ghostElement.addEventListener('pointerup', function (args) {
                _this.onPointerUp(args);
            });
            this.ghostElement.addEventListener('lostpointercapture', function (args) {
                _this.onPointerLost(args);
            });
        }
        // Transition animation when the ghostElement is released and it returns to it's original position.
        this.ghostElement.addEventListener('transitionend', function (args) {
            _this.onTransitionEnd(args);
        });
        // Hide the base after the ghostElement is created, because otherwise the ghostElement will be not visible.
        if (this.hideBaseOnDrag) {
            this.visible = false;
        }
        this.cdr.detectChanges();
    };
    /**
     * @hidden
     * Dispatch custom igxDragEnter/igxDragLeave events based on current pointer position and if drop area is under.
     */
    /**
     * @hidden
     * Dispatch custom igxDragEnter/igxDragLeave events based on current pointer position and if drop area is under.
     * @protected
     * @param {?} pageX
     * @param {?} pageY
     * @param {?} originalEvent
     * @return {?}
     */
    IgxDragDirective.prototype.dispatchDragEvents = /**
     * @hidden
     * Dispatch custom igxDragEnter/igxDragLeave events based on current pointer position and if drop area is under.
     * @protected
     * @param {?} pageX
     * @param {?} pageY
     * @param {?} originalEvent
     * @return {?}
     */
    function (pageX, pageY, originalEvent) {
        /** @type {?} */
        var topDropArea;
        /** @type {?} */
        var customEventArgs = {
            startX: this._startX,
            startY: this._startY,
            pageX: pageX,
            pageY: pageY,
            owner: this,
            originalEvent: originalEvent
        };
        /** @type {?} */
        var elementsFromPoint = this.getElementsAtPoint(pageX, pageY);
        for (var i = 0; i < elementsFromPoint.length; i++) {
            if (elementsFromPoint[i].getAttribute('droppable') === 'true' &&
                elementsFromPoint[i] !== this.ghostElement && elementsFromPoint[i] !== this.element.nativeElement) {
                topDropArea = elementsFromPoint[i];
                break;
            }
        }
        if (topDropArea &&
            (!this._lastDropArea || (this._lastDropArea && this._lastDropArea !== topDropArea))) {
            if (this._lastDropArea) {
                this.dispatchEvent(this._lastDropArea, 'igxDragLeave', customEventArgs);
            }
            this._lastDropArea = topDropArea;
            this.dispatchEvent(this._lastDropArea, 'igxDragEnter', customEventArgs);
        }
        else if (!topDropArea && this._lastDropArea) {
            this.dispatchEvent(this._lastDropArea, 'igxDragLeave', customEventArgs);
            this._lastDropArea = null;
            return;
        }
        if (topDropArea) {
            this.dispatchEvent(topDropArea, 'igxDragOver', customEventArgs);
        }
    };
    /**
     * @hidden
     * Dispatch custom igxDrop event based on current pointer position if there is last recorder drop area under the pointer.
     * Last recorder drop area is updated in @dispatchDragEvents method.
     */
    /**
     * @hidden
     * Dispatch custom igxDrop event based on current pointer position if there is last recorder drop area under the pointer.
     * Last recorder drop area is updated in \@dispatchDragEvents method.
     * @protected
     * @param {?} pageX
     * @param {?} pageY
     * @param {?} originalEvent
     * @return {?}
     */
    IgxDragDirective.prototype.dispatchDropEvent = /**
     * @hidden
     * Dispatch custom igxDrop event based on current pointer position if there is last recorder drop area under the pointer.
     * Last recorder drop area is updated in \@dispatchDragEvents method.
     * @protected
     * @param {?} pageX
     * @param {?} pageY
     * @param {?} originalEvent
     * @return {?}
     */
    function (pageX, pageY, originalEvent) {
        /** @type {?} */
        var eventArgs = {
            startX: this._startX,
            startY: this._startY,
            pageX: pageX,
            pageY: pageY,
            owner: this,
            originalEvent: originalEvent
        };
        this.dispatchEvent(this._lastDropArea, 'igxDrop', eventArgs);
        this.dispatchEvent(this._lastDropArea, 'igxDragLeave', eventArgs);
        this._lastDropArea = null;
    };
    /**
     * @hidden
     * Update relative positions
     */
    /**
     * @hidden
     * Update relative positions
     * @return {?}
     */
    IgxDragDirective.prototype.updateDragRelativePos = /**
     * @hidden
     * Update relative positions
     * @return {?}
     */
    function () {
        /** @type {?} */
        var newPosX;
        /** @type {?} */
        var newPosY;
        if (this.ghost && this.ghostElement) {
            // Calculate the new ghostElement position to remain where the mouse is, so it doesn't jump
            /** @type {?} */
            var totalDraggedX = this.ghostLeft - this._ghostStartX;
            /** @type {?} */
            var totalDraggedY = this.ghostTop - this._ghostStartY;
            newPosX = this.baseLeft;
            newPosY = this.baseTop;
            /** @type {?} */
            var diffStartX = this._ghostStartX - newPosX;
            /** @type {?} */
            var diffStartY = this._ghostStartY - newPosY;
            this.ghostTop = newPosX + totalDraggedX - diffStartX;
            this.ghostLeft = newPosY + totalDraggedY - diffStartY;
        }
        else if (!this.ghost) {
            /** @type {?} */
            var totalDraggedX = this.getTransformX(this.element.nativeElement);
            /** @type {?} */
            var totalDraggedY = this.getTransformY(this.element.nativeElement);
            newPosX = this.baseLeft - totalDraggedX;
            newPosY = this.baseTop - totalDraggedY;
            /** @type {?} */
            var deltaX = this._baseOriginX - newPosX;
            /** @type {?} */
            var deltaY = this._baseOriginY - newPosY;
            this.setTransformXY(totalDraggedX + deltaX, totalDraggedY + deltaY);
        }
        this._baseOriginX = newPosX !== undefined ? newPosX : this._baseOriginX;
        this._baseOriginY = newPosY !== undefined ? newPosY : this._baseOriginY;
    };
    /**
     * @deprecated This method will be removed in future major version. Please use `transitionToOrigin` or `transitionTo`.
     * Informs the `igxDrag` directive that it has been dropped/released.
     * This should usually be called when `animateOnRelease` is set to `true`.
     * When canceling or defining custom drop logic this tells the igxDrag to update it's positions and
     * animate correctly to the new position.
     * ```typescript
     * public onDropElem(event) {
     *     // Function bound to the igxDrop directive event `onDrop`
     *     // This cancels the default drop logic of the `igxDrop`
     *     event.cancel = true;
     *     event.drag.dropFinished();
     * }
     * ```
    */
    /**
     * @deprecated This method will be removed in future major version. Please use `transitionToOrigin` or `transitionTo`.
     * Informs the `igxDrag` directive that it has been dropped/released.
     * This should usually be called when `animateOnRelease` is set to `true`.
     * When canceling or defining custom drop logic this tells the igxDrag to update it's positions and
     * animate correctly to the new position.
     * ```typescript
     * public onDropElem(event) {
     *     // Function bound to the igxDrop directive event `onDrop`
     *     // This cancels the default drop logic of the `igxDrop`
     *     event.cancel = true;
     *     event.drag.dropFinished();
     * }
     * ```
     * @return {?}
     */
    IgxDragDirective.prototype.dropFinished = /**
     * @deprecated This method will be removed in future major version. Please use `transitionToOrigin` or `transitionTo`.
     * Informs the `igxDrag` directive that it has been dropped/released.
     * This should usually be called when `animateOnRelease` is set to `true`.
     * When canceling or defining custom drop logic this tells the igxDrag to update it's positions and
     * animate correctly to the new position.
     * ```typescript
     * public onDropElem(event) {
     *     // Function bound to the igxDrop directive event `onDrop`
     *     // This cancels the default drop logic of the `igxDrop`
     *     event.cancel = true;
     *     event.drag.dropFinished();
     * }
     * ```
     * @return {?}
     */
    function () {
        this.updateDragRelativePos();
        if (this.animateOnRelease && this.ghostElement) {
            this.transitionToOrigin();
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxDragDirective.prototype.onTransitionEnd = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        if ((!this._dragStarted && !this.animInProgress) || this._clicked) {
            // Return if no dragging started and there is no animation in progress.
            return;
        }
        if (this.ghost && this.ghostElement) {
            this._ghostStartX = this.baseLeft + this.getWindowScrollLeft();
            this._ghostStartY = this.baseTop + this.getWindowScrollTop();
            /** @type {?} */
            var ghostDestroyArgs = {
                owner: this,
                ghostElement: this.ghostElement,
                cancel: false
            };
            this.ghostDestroy.emit(ghostDestroyArgs);
            if (ghostDestroyArgs.cancel) {
                return;
            }
            if (this.hideBaseOnDrag) {
                this.visible = true;
            }
            this.ghostElement.parentNode.removeChild(this.ghostElement);
            this.ghostElement = null;
        }
        else if (!this.ghost) {
            this.element.nativeElement.style.transitionProperty = '';
            this.element.nativeElement.style.transitionDuration = '0.0s';
            this.element.nativeElement.style.transitionTimingFunction = '';
            this.element.nativeElement.style.transitionDelay = '';
        }
        this.animInProgress = false;
        this._dragStarted = false;
        // Execute transitioned after everything is reset so if the user sets new location on the base now it would work as expected.
        this.zone.run(function () {
            _this.transitioned.emit({
                originalEvent: event,
                owner: _this,
                startX: _this._startX,
                startY: _this._startY,
                pageX: _this._startX,
                pageY: _this._startY
            });
        });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} pageX
     * @param {?} pageY
     * @return {?}
     */
    IgxDragDirective.prototype.getElementsAtPoint = /**
     * @hidden
     * @protected
     * @param {?} pageX
     * @param {?} pageY
     * @return {?}
     */
    function (pageX, pageY) {
        // correct the coordinates with the current scroll position, because
        // document.elementsFromPoint consider position within the current viewport
        // window.pageXOffset == window.scrollX; // always true
        // using window.pageXOffset for IE9 compatibility
        /** @type {?} */
        var viewPortX = pageX - window.pageXOffset;
        /** @type {?} */
        var viewPortY = pageY - window.pageYOffset;
        if (document['msElementsFromPoint']) {
            // Edge and IE special snowflakes
            /** @type {?} */
            var elements = document['msElementsFromPoint'](viewPortX, viewPortY);
            return elements === null ? [] : elements;
        }
        else {
            // Other browsers like Chrome, Firefox, Opera
            return document.elementsFromPoint(viewPortX, viewPortY);
        }
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @protected
     * @param {?} target
     * @param {?} eventName
     * @param {?} eventArgs
     * @return {?}
     */
    IgxDragDirective.prototype.dispatchEvent = /**
     * @hidden
     * @protected
     * @param {?} target
     * @param {?} eventName
     * @param {?} eventArgs
     * @return {?}
     */
    function (target, eventName, eventArgs) {
        // This way is IE11 compatible.
        /** @type {?} */
        var dragLeaveEvent = document.createEvent('CustomEvent');
        dragLeaveEvent.initCustomEvent(eventName, false, false, eventArgs);
        target.dispatchEvent(dragLeaveEvent);
        // Otherwise can be used `target.dispatchEvent(new CustomEvent(eventName, eventArgs));`
    };
    /**
     * @protected
     * @param {?} elem
     * @return {?}
     */
    IgxDragDirective.prototype.getTransformX = /**
     * @protected
     * @param {?} elem
     * @return {?}
     */
    function (elem) {
        /** @type {?} */
        var posX = 0;
        if (elem.style.transform) {
            /** @type {?} */
            var matrix = elem.style.transform;
            /** @type {?} */
            var values = matrix ? matrix.match(/-?[\d\.]+/g) : undefined;
            posX = values ? Number(values[1]) : 0;
        }
        return posX;
    };
    /**
     * @protected
     * @param {?} elem
     * @return {?}
     */
    IgxDragDirective.prototype.getTransformY = /**
     * @protected
     * @param {?} elem
     * @return {?}
     */
    function (elem) {
        /** @type {?} */
        var posY = 0;
        if (elem.style.transform) {
            /** @type {?} */
            var matrix = elem.style.transform;
            /** @type {?} */
            var values = matrix ? matrix.match(/-?[\d\.]+/g) : undefined;
            posY = values ? Number(values[2]) : 0;
        }
        return posY;
    };
    /** Method setting transformation to the base draggable element. */
    /**
     * Method setting transformation to the base draggable element.
     * @protected
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    IgxDragDirective.prototype.setTransformXY = /**
     * Method setting transformation to the base draggable element.
     * @protected
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    function (x, y) {
        this.element.nativeElement.style.transform = 'translate3d(' + x + 'px, ' + y + 'px, 0px)';
    };
    /**
     * @protected
     * @return {?}
     */
    IgxDragDirective.prototype.getWindowScrollTop = /**
     * @protected
     * @return {?}
     */
    function () {
        return window.scrollY ? window.scrollY : (window.pageYOffset ? window.pageYOffset : 0);
    };
    /**
     * @protected
     * @return {?}
     */
    IgxDragDirective.prototype.getWindowScrollLeft = /**
     * @protected
     * @return {?}
     */
    function () {
        return window.scrollX ? window.scrollX : (window.pageXOffset ? window.pageXOffset : 0);
    };
    /**
     * @protected
     * @param {?} ghostHost
     * @return {?}
     */
    IgxDragDirective.prototype.ghostHostOffsetLeft = /**
     * @protected
     * @param {?} ghostHost
     * @return {?}
     */
    function (ghostHost) {
        /** @type {?} */
        var ghostPosition = document.defaultView.getComputedStyle(ghostHost).getPropertyValue('position');
        if (ghostPosition === 'static' && ghostHost.offsetParent && ghostHost.offsetParent === document.body) {
            return 0;
        }
        else if (ghostPosition === 'static' && ghostHost.offsetParent) {
            return ghostHost.offsetParent.getBoundingClientRect().left - this.getWindowScrollLeft();
        }
        return ghostHost.getBoundingClientRect().left - this.getWindowScrollLeft();
    };
    /**
     * @protected
     * @param {?} ghostHost
     * @return {?}
     */
    IgxDragDirective.prototype.ghostHostOffsetTop = /**
     * @protected
     * @param {?} ghostHost
     * @return {?}
     */
    function (ghostHost) {
        /** @type {?} */
        var ghostPosition = document.defaultView.getComputedStyle(ghostHost).getPropertyValue('position');
        if (ghostPosition === 'static' && ghostHost.offsetParent && ghostHost.offsetParent === document.body) {
            return 0;
        }
        else if (ghostPosition === 'static' && ghostHost.offsetParent) {
            return ghostHost.offsetParent.getBoundingClientRect().top - this.getWindowScrollTop();
        }
        return ghostHost.getBoundingClientRect().top - this.getWindowScrollTop();
    };
    IgxDragDirective.decorators = [
        { type: Directive, args: [{
                    exportAs: 'drag',
                    selector: '[igxDrag]'
                },] }
    ];
    /** @nocollapse */
    IgxDragDirective.ctorParameters = function () { return [
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: ViewContainerRef },
        { type: NgZone },
        { type: Renderer2 }
    ]; };
    IgxDragDirective.propDecorators = {
        data: [{ type: Input, args: ['igxDrag',] }],
        dragTolerance: [{ type: Input }],
        dragChannel: [{ type: Input }],
        ghost: [{ type: Input }],
        ghostClass: [{ type: Input }],
        hideBaseOnDrag: [{ type: Input }],
        animateOnRelease: [{ type: Input }],
        ghostTemplate: [{ type: Input }],
        ghostHost: [{ type: Input }],
        ghostOffsetX: [{ type: Input }],
        ghostOffsetY: [{ type: Input }],
        dragStart: [{ type: Output }],
        dragMove: [{ type: Output }],
        dragEnd: [{ type: Output }],
        dragClick: [{ type: Output }],
        ghostCreate: [{ type: Output }],
        ghostDestroy: [{ type: Output }],
        transitioned: [{ type: Output }],
        dragHandles: [{ type: ContentChildren, args: [IgxDragHandleDirective,] }],
        _visibility: [{ type: HostBinding, args: ['style.visibility',] }],
        baseClass: [{ type: HostBinding, args: ['class.igx-drag',] }],
        selectDisabled: [{ type: HostBinding, args: ['class.igx-drag--select-disabled',] }]
    };
    tslib_1.__decorate([
        DeprecateProperty("'hideBaseOnDrag' @Input property is deprecated and will be removed in future major versions.\n        Alternatives to it are using the new no ghost dragging and custom base styling."),
        tslib_1.__metadata("design:type", Object)
    ], IgxDragDirective.prototype, "hideBaseOnDrag", void 0);
    tslib_1.__decorate([
        DeprecateProperty("'animateOnRelease' @Input property is deprecated and will be removed in future major versions.\n        Please use 'transitionToOrigin' or 'transitionTo' methods instead."),
        tslib_1.__metadata("design:type", Object)
    ], IgxDragDirective.prototype, "animateOnRelease", void 0);
    tslib_1.__decorate([
        DeprecateProperty("'visible' @Input property is deprecated and will be removed in future major versions.\n        Please use native angular ways of hiding the base element using styling."),
        tslib_1.__metadata("design:type", Object),
        tslib_1.__metadata("design:paramtypes", [Object])
    ], IgxDragDirective.prototype, "visible", null);
    return IgxDragDirective;
}());
export { IgxDragDirective };
if (false) {
    /**
     * @type {?}
     * @protected
     */
    IgxDragDirective.prototype.ghostContext;
    /**
     * - Save data inside the `igxDrag` directive. This can be set when instancing `igxDrag` on an element.
     * ```html
     * <div [igxDrag]="{ source: myElement }"></div>
     * ```
     * \@memberof IgxDragDirective
     * @type {?}
     */
    IgxDragDirective.prototype.data;
    /**
     * An \@Input property that indicates when the drag should start.
     * By default the drag starts after the draggable element is moved by 5px.
     * ```html
     * <div igxDrag [dragTolerance]="100">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * \@memberof IgxDragDirective
     * @type {?}
     */
    IgxDragDirective.prototype.dragTolerance;
    /**
     * An \@Input property that provide a way for igxDrag and igxDrop to be linked through channels.
     * It accepts single value or an array of values and evaluates then using strict equality.
     * ```html
     * <div igxDrag [dragChannel]="'odd'">
     *         <span>95</span>
     * </div>
     * <div igxDrop [dropChannel]="['odd', 'irrational']">
     *         <span>Numbers drop area!</span>
     * </div>
     * ```
     * \@memberof IgxDragDirective
     * @type {?}
     */
    IgxDragDirective.prototype.dragChannel;
    /**
     * An \@Input property that specifies if the base element should not be moved and a ghost element should be rendered that represents it.
     * By default it is set to `true`.
     * If it is set to `false` when dragging the base element is moved instead and no ghost elements are rendered.
     * ```html
     * <div igxDrag [ghost]="false">
     *      <span>Drag Me!</span>
     * </div>
     * ```
     * \@memberof IgxDragDirective
     * @type {?}
     */
    IgxDragDirective.prototype.ghost;
    /**
     * Sets a custom class that will be added to the `ghostElement` element.
     * ```html
     * <div igxDrag [ghostClass]="'ghostElement'">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * \@memberof IgxDragDirective
     * @type {?}
     */
    IgxDragDirective.prototype.ghostClass;
    /**
     * @deprecated Please use custom base styling instead.
     * An \@Input property that hides the draggable element.
     * By default it's set to false.
     * ```html
     * <div igxDrag [dragTolerance]="100" [hideBaseOnDrag]="'true'">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * \@memberof IgxDragDirective
     * @type {?}
     */
    IgxDragDirective.prototype.hideBaseOnDrag;
    /**
     * @deprecated Please use provided transition functions in future.
     * An \@Input property that enables/disables the draggable element animation
     * when the element is released.
     * By default it's set to false.
     * ```html
     * <div igxDrag [animateOnRelease]="'true'">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * \@memberof IgxDragDirective
     * @type {?}
     */
    IgxDragDirective.prototype.animateOnRelease;
    /**
     * An \@Input property that specifies a template for the ghost element created when dragging starts and `ghost` is true.
     * By default a clone of the base element the igxDrag is instanced is created.
     * ```html
     * <div igxDrag [ghostTemplate]="customGhost">
     *         <span>Drag Me!</span>
     * </div>
     * <ng-template #customGhost>
     *      <div class="customGhostStyle">
     *          <span>I am being dragged!</span>
     *      </div>
     * </ng-template>
     * ```
     * \@memberof IgxDragDirective
     * @type {?}
     */
    IgxDragDirective.prototype.ghostTemplate;
    /**
     * An \@Input property that sets the element to which the dragged element will be appended.
     * By default it's set to null and the dragged element is appended to the body.
     * ```html
     * <div #hostDiv></div>
     * <div igxDrag [ghostHost]="hostDiv">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * \@memberof IgxDragDirective
     * @type {?}
     */
    IgxDragDirective.prototype.ghostHost;
    /**
     * Event triggered when the draggable element drag starts.
     * ```html
     * <div igxDrag (dragStart)="onDragStart()">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * ```typescript
     * public onDragStart(){
     *      alert("The drag has stared!");
     * }
     * ```
     * \@memberof IgxDragDirective
     * @type {?}
     */
    IgxDragDirective.prototype.dragStart;
    /**
     * Event triggered when the draggable element has been moved.
     * ```html
     * <div igxDrag  (dragMove)="onDragMove()">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * ```typescript
     * public onDragMove(){
     *      alert("The element has moved!");
     * }
     * ```
     * \@memberof IgxDragDirective
     * @type {?}
     */
    IgxDragDirective.prototype.dragMove;
    /**
     * Event triggered when the draggable element is released.
     * ```html
     * <div igxDrag (dragEnd)="onDragEnd()">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * ```typescript
     * public onDragEnd(){
     *      alert("The drag has ended!");
     * }
     * ```
     * \@memberof IgxDragDirective
     * @type {?}
     */
    IgxDragDirective.prototype.dragEnd;
    /**
     * Event triggered when the draggable element is clicked.
     * ```html
     * <div igxDrag (dragClick)="onDragClick()">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * ```typescript
     * public onDragClick(){
     *      alert("The element has been clicked!");
     * }
     * ```
     * \@memberof IgxDragDirective
     * @type {?}
     */
    IgxDragDirective.prototype.dragClick;
    /**
     * Event triggered when the drag ghost element is created.
     * ```html
     * <div igxDrag (ghostCreate)="ghostCreated()">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * ```typescript
     * public ghostCreated(){
     *      alert("The ghost has been created!");
     * }
     * ```
     * \@memberof IgxDragDirective
     * @type {?}
     */
    IgxDragDirective.prototype.ghostCreate;
    /**
     * Event triggered when the drag ghost element is created.
     * ```html
     * <div igxDrag (ghostDestroy)="ghostDestroyed()">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * ```typescript
     * public ghostDestroyed(){
     *      alert("The ghost has been destroyed!");
     * }
     * ```
     * \@memberof IgxDragDirective
     * @type {?}
     */
    IgxDragDirective.prototype.ghostDestroy;
    /**
     * Event triggered after the draggable element is released and after its animation has finished.
     * ```html
     * <div igxDrag (transitioned)="onMoveEnd()">
     *         <span>Drag Me!</span>
     * </div>
     * ```
     * ```typescript
     * public onMoveEnd(){
     *      alert("The move has ended!");
     * }
     * ```
     * \@memberof IgxDragDirective
     * @type {?}
     */
    IgxDragDirective.prototype.transitioned;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype.dragHandles;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype._visibility;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype.baseClass;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype.selectDisabled;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype.defaultReturnDuration;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype.ghostElement;
    /**
     * @hidden
     * @type {?}
     */
    IgxDragDirective.prototype.animInProgress;
    /**
     * @type {?}
     * @protected
     */
    IgxDragDirective.prototype._baseMarginLeft;
    /**
     * @type {?}
     * @protected
     */
    IgxDragDirective.prototype._baseMarginTop;
    /**
     * @type {?}
     * @protected
     */
    IgxDragDirective.prototype._baseOriginX;
    /**
     * @type {?}
     * @protected
     */
    IgxDragDirective.prototype._baseOriginY;
    /**
     * @type {?}
     * @protected
     */
    IgxDragDirective.prototype._startX;
    /**
     * @type {?}
     * @protected
     */
    IgxDragDirective.prototype._startY;
    /**
     * @type {?}
     * @protected
     */
    IgxDragDirective.prototype._lastX;
    /**
     * @type {?}
     * @protected
     */
    IgxDragDirective.prototype._lastY;
    /**
     * @type {?}
     * @protected
     */
    IgxDragDirective.prototype._dragStarted;
    /**
     * Drag ghost related properties
     * @type {?}
     * @protected
     */
    IgxDragDirective.prototype._defaultOffsetX;
    /**
     * @type {?}
     * @protected
     */
    IgxDragDirective.prototype._defaultOffsetY;
    /**
     * @type {?}
     * @protected
     */
    IgxDragDirective.prototype._offsetX;
    /**
     * @type {?}
     * @protected
     */
    IgxDragDirective.prototype._offsetY;
    /**
     * @type {?}
     * @protected
     */
    IgxDragDirective.prototype._ghostStartX;
    /**
     * @type {?}
     * @protected
     */
    IgxDragDirective.prototype._ghostStartY;
    /**
     * @type {?}
     * @protected
     */
    IgxDragDirective.prototype._ghostHostX;
    /**
     * @type {?}
     * @protected
     */
    IgxDragDirective.prototype._ghostHostY;
    /**
     * @type {?}
     * @protected
     */
    IgxDragDirective.prototype._pointerDownId;
    /**
     * @type {?}
     * @protected
     */
    IgxDragDirective.prototype._clicked;
    /**
     * @type {?}
     * @protected
     */
    IgxDragDirective.prototype._lastDropArea;
    /**
     * @type {?}
     * @protected
     */
    IgxDragDirective.prototype._destroy;
    /**
     * @type {?}
     * @protected
     */
    IgxDragDirective.prototype._removeOnDestroy;
    /** @type {?} */
    IgxDragDirective.prototype.cdr;
    /** @type {?} */
    IgxDragDirective.prototype.element;
    /** @type {?} */
    IgxDragDirective.prototype.viewContainer;
    /** @type {?} */
    IgxDragDirective.prototype.zone;
    /** @type {?} */
    IgxDragDirective.prototype.renderer;
}
var IgxDropDirective = /** @class */ (function () {
    function IgxDropDirective(element, _renderer, _zone) {
        this.element = element;
        this._renderer = _renderer;
        this._zone = _zone;
        /**
         * Event triggered when dragged element enters the area of the element.
         * ```html
         * <div class="cageArea" igxDrop (enter)="dragEnter()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragEnter(){
         *     alert("A draggable element has entered the chip area!");
         * }
         * ```
         * \@memberof IgxDropDirective
         */
        this.enter = new EventEmitter();
        /**
         * Event triggered when dragged element enters the area of the element.
         * ```html
         * <div class="cageArea" igxDrop (enter)="dragEnter()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragEnter(){
         *     alert("A draggable element has entered the chip area!");
         * }
         * ```
         * \@memberof IgxDropDirective
         */
        this.over = new EventEmitter();
        /**
         * Event triggered when dragged element leaves the area of the element.
         * ```html
         * <div class="cageArea" igxDrop (leave)="dragLeave()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragLeave(){
         *     alert("A draggable element has left the chip area!");
         * }
         * ```
         * \@memberof IgxDropDirective
         */
        this.leave = new EventEmitter();
        /**
         * Event triggered when dragged element is dropped in the area of the element.
         * Since the `igxDrop` has default logic that appends the dropped element as a child, it can be canceled here.
         * To cancel the default logic the `cancel` property of the event needs to be set to true.
         * ```html
         * <div class="cageArea" igxDrop (dropped)="dragDrop()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
         * </div>
         * ```
         * ```typescript
         * public dragDrop(){
         *     alert("A draggable element has been dropped in the chip area!");
         * }
         * ```
         * \@memberof IgxDropDirective
         */
        this.dropped = new EventEmitter();
        /**
         * @hidden
         */
        this.droppable = true;
        /**
         * @hidden
         */
        this.dragover = false;
        /**
         * @hidden
         */
        this._destroy = new Subject();
        this._dropStrategy = new IgxDefaultDropStrategy();
    }
    Object.defineProperty(IgxDropDirective.prototype, "dropStrategy", {
        get: /**
         * @return {?}
         */
        function () {
            return this._dropStrategy;
        },
        /**
         * An @Input property that specifies a drop strategy type that will be executed when an `IgxDrag` element is released inside
         *  the current drop area. The provided strategies are:
         *  - IgxDefaultDropStrategy - This is the default base strategy and it doesn't perform any actions.
         *  - IgxAppendDropStrategy - Appends the dropped element to last position as a direct child to the `igxDrop`.
         *  - IgxPrependDropStrategy - Prepends the dropped element to first position as a direct child to the `igxDrop`.
         *  - IgxInsertDropStrategy - If the dropped element is released above a child element of the `igxDrop`, it will be inserted
         *      at that position. Otherwise the dropped element will be appended if released outside any child of the `igxDrop`.
         * ```html
         * <div igxDrag>
         *      <span>DragMe</span>
         * </div>
         * <div igxDrop [dropStrategy]="myDropStrategy">
         *         <span>Numbers drop area!</span>
         * </div>
         * ```
         * ```typescript
         * import { IgxAppendDropStrategy } from 'igniteui-angular';
         *
         * export class App {
         *      public myDropStrategy = IgxAppendDropStrategy;
         * }
         * ```
         * @memberof IgxDropDirective
         */
        set: /**
         * An \@Input property that specifies a drop strategy type that will be executed when an `IgxDrag` element is released inside
         *  the current drop area. The provided strategies are:
         *  - IgxDefaultDropStrategy - This is the default base strategy and it doesn't perform any actions.
         *  - IgxAppendDropStrategy - Appends the dropped element to last position as a direct child to the `igxDrop`.
         *  - IgxPrependDropStrategy - Prepends the dropped element to first position as a direct child to the `igxDrop`.
         *  - IgxInsertDropStrategy - If the dropped element is released above a child element of the `igxDrop`, it will be inserted
         *      at that position. Otherwise the dropped element will be appended if released outside any child of the `igxDrop`.
         * ```html
         * <div igxDrag>
         *      <span>DragMe</span>
         * </div>
         * <div igxDrop [dropStrategy]="myDropStrategy">
         *         <span>Numbers drop area!</span>
         * </div>
         * ```
         * ```typescript
         * import { IgxAppendDropStrategy } from 'igniteui-angular';
         *
         * export class App {
         *      public myDropStrategy = IgxAppendDropStrategy;
         * }
         * ```
         * \@memberof IgxDropDirective
         * @param {?} classRef
         * @return {?}
         */
        function (classRef) {
            this._dropStrategy = new classRef(this._renderer);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxDropDirective.prototype.ngOnInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        var _this = this;
        this._zone.runOutsideAngular(function () {
            fromEvent(_this.element.nativeElement, 'igxDragEnter').pipe(takeUntil(_this._destroy))
                .subscribe(function (res) { return _this.onDragEnter((/** @type {?} */ (res))); });
            fromEvent(_this.element.nativeElement, 'igxDragLeave').pipe(takeUntil(_this._destroy)).subscribe(function (res) { return _this.onDragLeave(res); });
            fromEvent(_this.element.nativeElement, 'igxDragOver').pipe(takeUntil(_this._destroy)).subscribe(function (res) { return _this.onDragOver(res); });
        });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxDropDirective.prototype.ngOnDestroy = /**
     * @hidden
     * @return {?}
     */
    function () {
        this._destroy.next(true);
        this._destroy.complete();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxDropDirective.prototype.onDragOver = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        /** @type {?} */
        var elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
        /** @type {?} */
        var elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
        /** @type {?} */
        var offsetX = event.detail.pageX - elementPosX;
        /** @type {?} */
        var offsetY = event.detail.pageY - elementPosY;
        /** @type {?} */
        var eventArgs = {
            originalEvent: event.detail.originalEvent,
            owner: this,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY,
            offsetX: offsetX,
            offsetY: offsetY
        };
        this.over.emit(eventArgs);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxDropDirective.prototype.onDragEnter = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        if (!this.isDragLinked(event.detail.owner)) {
            return;
        }
        this.dragover = true;
        /** @type {?} */
        var elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
        /** @type {?} */
        var elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
        /** @type {?} */
        var offsetX = event.detail.pageX - elementPosX;
        /** @type {?} */
        var offsetY = event.detail.pageY - elementPosY;
        /** @type {?} */
        var eventArgs = {
            originalEvent: event.detail.originalEvent,
            owner: this,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY,
            offsetX: offsetX,
            offsetY: offsetY
        };
        this._zone.run(function () {
            _this.enter.emit(eventArgs);
        });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxDropDirective.prototype.onDragLeave = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        if (!this.isDragLinked(event.detail.owner)) {
            return;
        }
        this.dragover = false;
        /** @type {?} */
        var elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
        /** @type {?} */
        var elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
        /** @type {?} */
        var offsetX = event.detail.pageX - elementPosX;
        /** @type {?} */
        var offsetY = event.detail.pageY - elementPosY;
        /** @type {?} */
        var eventArgs = {
            originalEvent: event.detail.originalEvent,
            owner: this,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY,
            offsetX: offsetX,
            offsetY: offsetY
        };
        this._zone.run(function () {
            _this.leave.emit(eventArgs);
        });
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxDropDirective.prototype.onDragDrop = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        if (!this.isDragLinked(event.detail.owner)) {
            return;
        }
        /** @type {?} */
        var elementPosX = this.element.nativeElement.getBoundingClientRect().left + this.getWindowScrollLeft();
        /** @type {?} */
        var elementPosY = this.element.nativeElement.getBoundingClientRect().top + this.getWindowScrollTop();
        /** @type {?} */
        var offsetX = event.detail.pageX - elementPosX;
        /** @type {?} */
        var offsetY = event.detail.pageY - elementPosY;
        /** @type {?} */
        var args = {
            owner: this,
            originalEvent: event.detail.originalEvent,
            drag: event.detail.owner,
            dragData: event.detail.owner.data,
            startX: event.detail.startX,
            startY: event.detail.startY,
            pageX: event.detail.pageX,
            pageY: event.detail.pageY,
            offsetX: offsetX,
            offsetY: offsetY,
            cancel: false
        };
        this._zone.run(function () {
            _this.dropped.emit(args);
        });
        if (this._dropStrategy && !args.cancel) {
            /** @type {?} */
            var elementsAtPoint = event.detail.owner.getElementsAtPoint(event.detail.pageX, event.detail.pageY);
            /** @type {?} */
            var insertIndex = this.getInsertIndexAt(event.detail.owner, elementsAtPoint);
            this._dropStrategy.dropAction(event.detail.owner, this, insertIndex);
        }
    };
    /**
     * @protected
     * @return {?}
     */
    IgxDropDirective.prototype.getWindowScrollTop = /**
     * @protected
     * @return {?}
     */
    function () {
        return window.scrollY ? window.scrollY : (window.pageYOffset ? window.pageYOffset : 0);
    };
    /**
     * @protected
     * @return {?}
     */
    IgxDropDirective.prototype.getWindowScrollLeft = /**
     * @protected
     * @return {?}
     */
    function () {
        return window.scrollX ? window.scrollX : (window.pageXOffset ? window.pageXOffset : 0);
    };
    /**
     * @protected
     * @param {?} drag
     * @return {?}
     */
    IgxDropDirective.prototype.isDragLinked = /**
     * @protected
     * @param {?} drag
     * @return {?}
     */
    function (drag) {
        /** @type {?} */
        var dragLinkArray = drag.dragChannel instanceof Array;
        /** @type {?} */
        var dropLinkArray = this.dropChannel instanceof Array;
        if (!dragLinkArray && !dropLinkArray) {
            return this.dropChannel === drag.dragChannel;
        }
        else if (!dragLinkArray && dropLinkArray) {
            /** @type {?} */
            var dropLinks = (/** @type {?} */ (this.dropChannel));
            for (var i = 0; i < dropLinks.length; i++) {
                if (dropLinks[i] === drag.dragChannel) {
                    return true;
                }
            }
        }
        else if (dragLinkArray && !dropLinkArray) {
            /** @type {?} */
            var dragLinks = (/** @type {?} */ (drag.dragChannel));
            for (var i = 0; i < dragLinks.length; i++) {
                if (dragLinks[i] === this.dropChannel) {
                    return true;
                }
            }
        }
        else {
            /** @type {?} */
            var dragLinks = (/** @type {?} */ (drag.dragChannel));
            /** @type {?} */
            var dropLinks = (/** @type {?} */ (this.dropChannel));
            for (var i = 0; i < dragLinks.length; i++) {
                for (var j = 0; j < dropLinks.length; j++) {
                    if (dragLinks[i] === dropLinks[j]) {
                        return true;
                    }
                }
            }
        }
        return false;
    };
    /**
     * @protected
     * @param {?} draggedDir
     * @param {?} elementsAtPoint
     * @return {?}
     */
    IgxDropDirective.prototype.getInsertIndexAt = /**
     * @protected
     * @param {?} draggedDir
     * @param {?} elementsAtPoint
     * @return {?}
     */
    function (draggedDir, elementsAtPoint) {
        /** @type {?} */
        var insertIndex = -1;
        /** @type {?} */
        var dropChildren = Array.prototype.slice.call(this.element.nativeElement.children);
        if (!dropChildren.length) {
            return insertIndex;
        }
        /** @type {?} */
        var i = 0;
        /** @type {?} */
        var childUnder = null;
        while (!childUnder && i < elementsAtPoint.length) {
            if (elementsAtPoint[i].parentElement === this.element.nativeElement) {
                childUnder = elementsAtPoint[i];
            }
            i++;
        }
        /** @type {?} */
        var draggedElemIndex = dropChildren.indexOf(draggedDir.element.nativeElement);
        insertIndex = dropChildren.indexOf(childUnder);
        if (draggedElemIndex !== -1 && draggedElemIndex < insertIndex) {
            insertIndex++;
        }
        return insertIndex;
    };
    IgxDropDirective.decorators = [
        { type: Directive, args: [{
                    exportAs: 'drop',
                    selector: '[igxDrop]'
                },] }
    ];
    /** @nocollapse */
    IgxDropDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: Renderer2 },
        { type: NgZone }
    ]; };
    IgxDropDirective.propDecorators = {
        data: [{ type: Input, args: ['igxDrop',] }],
        dropChannel: [{ type: Input }],
        dropStrategy: [{ type: Input }],
        enter: [{ type: Output }],
        over: [{ type: Output }],
        leave: [{ type: Output }],
        dropped: [{ type: Output }],
        droppable: [{ type: HostBinding, args: ['attr.droppable',] }],
        dragover: [{ type: HostBinding, args: ['class.dragOver',] }],
        onDragDrop: [{ type: HostListener, args: ['igxDrop', ['$event'],] }]
    };
    return IgxDropDirective;
}());
export { IgxDropDirective };
if (false) {
    /**
     * - Save data inside the `igxDrop` directive. This can be set when instancing `igxDrop` on an element.
     * ```html
     * <div [igxDrop]="{ source: myElement }"></div>
     * ```
     * \@memberof IgxDropDirective
     * @type {?}
     */
    IgxDropDirective.prototype.data;
    /**
     * An \@Input property that provide a way for igxDrag and igxDrop to be linked through channels.
     * It accepts single value or an array of values and evaluates then using strict equality.
     * ```html
     * <div igxDrag [dragChannel]="'odd'">
     *         <span>95</span>
     * </div>
     * <div igxDrop [dropChannel]="['odd', 'irrational']">
     *         <span>Numbers drop area!</span>
     * </div>
     * ```
     * \@memberof IgxDropDirective
     * @type {?}
     */
    IgxDropDirective.prototype.dropChannel;
    /**
     * Event triggered when dragged element enters the area of the element.
     * ```html
     * <div class="cageArea" igxDrop (enter)="dragEnter()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
     * </div>
     * ```
     * ```typescript
     * public dragEnter(){
     *     alert("A draggable element has entered the chip area!");
     * }
     * ```
     * \@memberof IgxDropDirective
     * @type {?}
     */
    IgxDropDirective.prototype.enter;
    /**
     * Event triggered when dragged element enters the area of the element.
     * ```html
     * <div class="cageArea" igxDrop (enter)="dragEnter()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
     * </div>
     * ```
     * ```typescript
     * public dragEnter(){
     *     alert("A draggable element has entered the chip area!");
     * }
     * ```
     * \@memberof IgxDropDirective
     * @type {?}
     */
    IgxDropDirective.prototype.over;
    /**
     * Event triggered when dragged element leaves the area of the element.
     * ```html
     * <div class="cageArea" igxDrop (leave)="dragLeave()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
     * </div>
     * ```
     * ```typescript
     * public dragLeave(){
     *     alert("A draggable element has left the chip area!");
     * }
     * ```
     * \@memberof IgxDropDirective
     * @type {?}
     */
    IgxDropDirective.prototype.leave;
    /**
     * Event triggered when dragged element is dropped in the area of the element.
     * Since the `igxDrop` has default logic that appends the dropped element as a child, it can be canceled here.
     * To cancel the default logic the `cancel` property of the event needs to be set to true.
     * ```html
     * <div class="cageArea" igxDrop (dropped)="dragDrop()" (igxDragEnter)="onDragCageEnter()" (igxDragLeave)="onDragCageLeave()">
     * </div>
     * ```
     * ```typescript
     * public dragDrop(){
     *     alert("A draggable element has been dropped in the chip area!");
     * }
     * ```
     * \@memberof IgxDropDirective
     * @type {?}
     */
    IgxDropDirective.prototype.dropped;
    /**
     * @hidden
     * @type {?}
     */
    IgxDropDirective.prototype.droppable;
    /**
     * @hidden
     * @type {?}
     */
    IgxDropDirective.prototype.dragover;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxDropDirective.prototype._destroy;
    /**
     * @type {?}
     * @protected
     */
    IgxDropDirective.prototype._dropStrategy;
    /** @type {?} */
    IgxDropDirective.prototype.element;
    /**
     * @type {?}
     * @private
     */
    IgxDropDirective.prototype._renderer;
    /**
     * @type {?}
     * @private
     */
    IgxDropDirective.prototype._zone;
}
/**
 * @hidden
 */
var IgxDragDropModule = /** @class */ (function () {
    function IgxDragDropModule() {
    }
    IgxDragDropModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [IgxDragDirective, IgxDropDirective, IgxDragHandleDirective],
                    exports: [IgxDragDirective, IgxDropDirective, IgxDragHandleDirective]
                },] }
    ];
    return IgxDragDropModule;
}());
export { IgxDragDropModule };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJhZy1kcm9wLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvZGlyZWN0aXZlcy9kcmFnLWRyb3AvZHJhZy1kcm9wLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFDSCxTQUFTLEVBQ1QsVUFBVSxFQUNWLFlBQVksRUFDWixXQUFXLEVBQ1gsWUFBWSxFQUNaLEtBQUssRUFDTCxRQUFRLEVBQ1IsTUFBTSxFQUdOLE1BQU0sRUFDTixTQUFTLEVBQ1QsaUJBQWlCLEVBQ2pCLGdCQUFnQixFQUVoQixXQUFXLEVBQ1gsZUFBZSxFQUNmLFNBQVMsRUFDWixNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsdUJBQXVCLEVBQUUsU0FBUyxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDN0UsT0FBTyxFQUFFLFNBQVMsRUFBRSxRQUFRLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNyRCxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUNqRSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUVuRSxPQUFPLEVBQWlCLHNCQUFzQixFQUFFLE1BQU0sc0JBQXNCLENBQUM7OztJQUd6RSxhQUFVO0lBQ1YsZUFBWTtJQUNaLE9BQUk7Ozs7Ozs7OztBQUdSLCtDQU9DOzs7SUFORywyQ0FBZTs7SUFDZiwyQ0FBZTs7SUFDZiwwQ0FBYzs7SUFDZCwwQ0FBYzs7SUFDZCwwQ0FBd0I7O0lBQ3hCLGtEQUFtQjs7Ozs7QUFHdkIsd0NBb0NDOzs7Ozs7O0lBL0JHLDJDQUFtQjs7Ozs7SUFFbkIsbUNBQXdCOzs7OztJQUV4QixrQ0FBdUI7Ozs7O0lBRXZCLHNDQUFjOzs7OztJQUVkLG9DQUFlOzs7OztJQUVmLG9DQUFlOzs7Ozs7SUFLZixtQ0FBYzs7Ozs7O0lBS2QsbUNBQWM7Ozs7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ekIsZ0NBQ2lCOzs7Ozs7Ozs7Ozs7Ozs7SUFlakIsdUNBQzBEOzs7Ozs7Ozs7Ozs7Ozs7SUFnRDFELGlDQUNzRDs7Ozs7Ozs7Ozs7Ozs7O0lBY3RELGdDQUNxRDs7Ozs7Ozs7Ozs7Ozs7O0lBY3JELGlDQUNzRDs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFnQnRELG1DQUMyRDs7Ozs7SUFLM0QscUNBQ3dCOzs7OztJQUt4QixvQ0FDd0I7Ozs7OztJQUt4QixvQ0FBNEM7Ozs7O0lBQzVDLHlDQUF1Qzs7SUFFM0IsbUNBQTBCOzs7OztJQUFFLHFDQUE0Qjs7Ozs7SUFBRSxpQ0FBcUI7Ozs7O0FBMk4vRjtJQUFBO0lBSWlDLENBQUM7O2dCQUpqQyxRQUFRLFNBQUM7b0JBQ04sWUFBWSxFQUFFLENBQUMsZ0JBQWdCLEVBQUUsZ0JBQWdCLEVBQUUsc0JBQXNCLENBQUM7b0JBQzFFLE9BQU8sRUFBRSxDQUFDLGdCQUFnQixFQUFFLGdCQUFnQixFQUFFLHNCQUFzQixDQUFDO2lCQUN4RTs7SUFDZ0Msd0JBQUM7Q0FBQSxBQUpsQyxJQUlrQztTQUFyQixpQkFBaUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIERpcmVjdGl2ZSxcbiAgICBFbGVtZW50UmVmLFxuICAgIEV2ZW50RW1pdHRlcixcbiAgICBIb3N0QmluZGluZyxcbiAgICBIb3N0TGlzdGVuZXIsXG4gICAgSW5wdXQsXG4gICAgTmdNb2R1bGUsXG4gICAgTmdab25lLFxuICAgIE9uRGVzdHJveSxcbiAgICBPbkluaXQsXG4gICAgT3V0cHV0LFxuICAgIFJlbmRlcmVyMixcbiAgICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBWaWV3Q29udGFpbmVyUmVmLFxuICAgIEFmdGVyQ29udGVudEluaXQsXG4gICAgVGVtcGxhdGVSZWYsXG4gICAgQ29udGVudENoaWxkcmVuLFxuICAgIFF1ZXJ5TGlzdFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyLCBmcm9tRXZlbnQsIGludGVydmFsLCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyB0YWtlVW50aWwsIHRocm90dGxlIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgSWd4RHJhZ0hhbmRsZURpcmVjdGl2ZSB9IGZyb20gJy4vZHJhZy1oYW5kbGUuZGlyZWN0aXZlJztcbmltcG9ydCB7IERlcHJlY2F0ZVByb3BlcnR5IH0gZnJvbSAnLi4vLi4vY29yZS9kZXByZWNhdGVEZWNvcmF0b3JzJztcbmltcG9ydCB7IElCYXNlRXZlbnRBcmdzIH0gZnJvbSAnLi4vLi4vY29yZS91dGlscyc7XG5pbXBvcnQgeyBJRHJvcFN0cmF0ZWd5LCBJZ3hEZWZhdWx0RHJvcFN0cmF0ZWd5IH0gZnJvbSAnLi9kcmFnLWRyb3Auc3RyYXRlZ3knO1xuXG5leHBvcnQgZW51bSBSZXN0cmljdERyYWcge1xuICAgIFZFUlRJQ0FMTFksXG4gICAgSE9SSVpPTlRBTExZLFxuICAgIE5PTkVcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJZ3hEcmFnQ3VzdG9tRXZlbnREZXRhaWxzIHtcbiAgICBzdGFydFg6IG51bWJlcjtcbiAgICBzdGFydFk6IG51bWJlcjtcbiAgICBwYWdlWDogbnVtYmVyO1xuICAgIHBhZ2VZOiBudW1iZXI7XG4gICAgb3duZXI6IElneERyYWdEaXJlY3RpdmU7XG4gICAgb3JpZ2luYWxFdmVudDogYW55O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElEcm9wQmFzZUV2ZW50QXJncyBleHRlbmRzIElCYXNlRXZlbnRBcmdzIHtcbiAgICAgICAgLyoqXG4gICAgICogUmVmZXJlbmNlIHRvIHRoZSBvcmlnaW5hbCBldmVudCB0aGF0IGNhdXNlZCB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQgdG8gZW50ZXIgdGhlIGlneERyb3AgZWxlbWVudC5cbiAgICAgKiBDYW4gYmUgUG9pbnRlckV2ZW50LCBUb3VjaEV2ZW50IG9yIE1vdXNlRXZlbnQuXG4gICAgICovXG4gICAgb3JpZ2luYWxFdmVudDogYW55O1xuICAgIC8qKiBUaGUgb3duZXIgaWd4RHJvcCBkaXJlY3RpdmUgdGhhdCB0cmlnZ2VyZWQgdGhpcyBldmVudC4gKi9cbiAgICBvd25lcjogSWd4RHJvcERpcmVjdGl2ZTtcbiAgICAvKiogVGhlIGlneERyYWcgZGlyZWN0aXZlIGluc3RhbmNlZCBvbiBhbiBlbGVtZW50IHRoYXQgZW50ZXJlZCB0aGUgYXJlYSBvZiB0aGUgaWd4RHJvcCBlbGVtZW50ICovXG4gICAgZHJhZzogSWd4RHJhZ0RpcmVjdGl2ZTtcbiAgICAvKiogVGhlIGRhdGEgY29udGFpbmVkIGZvciB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQgaW4gaWd4RHJhZyBkaXJlY3RpdmUuICovXG4gICAgZHJhZ0RhdGE6IGFueTtcbiAgICAvKiogVGhlIGluaXRpYWwgcG9zaXRpb24gb2YgdGhlIHBvaW50ZXIgb24gWCBheGlzIHdoZW4gdGhlIGRyYWdnZWQgZWxlbWVudCBiZWdhbiBtb3ZpbmcgKi9cbiAgICBzdGFydFg6IG51bWJlcjtcbiAgICAvKiogVGhlIGluaXRpYWwgcG9zaXRpb24gb2YgdGhlIHBvaW50ZXIgb24gWSBheGlzIHdoZW4gdGhlIGRyYWdnZWQgZWxlbWVudCBiZWdhbiBtb3ZpbmcgKi9cbiAgICBzdGFydFk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgcG9pbnRlciBvbiBYIGF4aXMgd2hlbiB0aGUgZXZlbnQgd2FzIHRyaWdnZXJlZC5cbiAgICAgKiBOb3RlOiBUaGUgYnJvd3NlciBtaWdodCB0cmlnZ2VyIHRoZSBldmVudCB3aXRoIHNvbWUgZGVsYXkgYW5kIHBvaW50ZXIgd291bGQgYmUgYWxyZWFkeSBpbnNpZGUgdGhlIGlneERyb3AuXG4gICAgICovXG4gICAgcGFnZVg6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgcG9pbnRlciBvbiBZIGF4aXMgd2hlbiB0aGUgZXZlbnQgd2FzIHRyaWdnZXJlZC5cbiAgICAgKiBOb3RlOiBUaGUgYnJvd3NlciBtaWdodCB0cmlnZ2VyIHRoZSBldmVudCB3aXRoIHNvbWUgZGVsYXkgYW5kIHBvaW50ZXIgd291bGQgYmUgYWxyZWFkeSBpbnNpZGUgdGhlIGlneERyb3AuXG4gICAgICovXG4gICAgcGFnZVk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgcG9pbnRlciBvbiBYIGF4aXMgcmVsYXRpdmUgdG8gdGhlIGNvbnRhaW5lciB0aGF0IGluaXRpYWxpemVzIHRoZSBpZ3hEcm9wLlxuICAgICAqIE5vdGU6IFRoZSBicm93c2VyIG1pZ2h0IHRyaWdnZXIgdGhlIGV2ZW50IHdpdGggc29tZSBkZWxheSBhbmQgcG9pbnRlciB3b3VsZCBiZSBhbHJlYWR5IGluc2lkZSB0aGUgaWd4RHJvcC5cbiAgICAgKi9cbiAgICBvZmZzZXRYOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIHBvaW50ZXIgb24gWSBheGlzIHJlbGF0aXZlIHRvIHRoZSBjb250YWluZXIgdGhhdCBpbml0aWFsaXplcyB0aGUgaWd4RHJvcC5cbiAgICAgKiBOb3RlOiBUaGUgYnJvd3NlciBtaWdodCB0cmlnZ2VyIHRoZSBldmVudCB3aXRoIHNvbWUgZGVsYXkgYW5kIHBvaW50ZXIgd291bGQgYmUgYWxyZWFkeSBpbnNpZGUgdGhlIGlneERyb3AuXG4gICAgICovXG4gICAgb2Zmc2V0WTogbnVtYmVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElEcm9wRHJvcHBlZEV2ZW50QXJncyBleHRlbmRzIElEcm9wQmFzZUV2ZW50QXJncyB7XG4gICAgLyoqIFNwZWNpZmllcyBpZiB0aGUgZGVmYXVsdCBkcm9wIGxvZ2ljIHJlbGF0ZWQgdG8gdGhlIGV2ZW50IHNob3VsZCBiZSBjYW5jZWxlZC4gKi9cbiAgICBjYW5jZWw6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSURyYWdCYXNlRXZlbnRBcmdzIGV4dGVuZHMgSUJhc2VFdmVudEFyZ3Mge1xuICAgIC8qKlxuICAgICAqIFJlZmVyZW5jZSB0byB0aGUgb3JpZ2luYWwgZXZlbnQgdGhhdCBjYXVzZWQgdGhlIGludGVyYWN0aW9uIHdpdGggdGhlIGVsZW1lbnQuXG4gICAgICogQ2FuIGJlIFBvaW50ZXJFdmVudCwgVG91Y2hFdmVudCBvciBNb3VzZUV2ZW50LlxuICAgICAqL1xuICAgIG9yaWdpbmFsRXZlbnQ6IFBvaW50ZXJFdmVudCB8IE1vdXNlRXZlbnQgfCBUb3VjaEV2ZW50O1xuICAgIC8qKiBUaGUgb3duZXIgaWd4RHJhZyBkaXJlY3RpdmUgdGhhdCB0cmlnZ2VyZWQgdGhpcyBldmVudC4gKi9cbiAgICBvd25lcjogSWd4RHJhZ0RpcmVjdGl2ZTtcbiAgICAvKiogVGhlIGluaXRpYWwgcG9zaXRpb24gb2YgdGhlIHBvaW50ZXIgb24gWCBheGlzIHdoZW4gdGhlIGRyYWdnZWQgZWxlbWVudCBiZWdhbiBtb3ZpbmcgKi9cbiAgICBzdGFydFg6IG51bWJlcjtcbiAgICAvKiogVGhlIGluaXRpYWwgcG9zaXRpb24gb2YgdGhlIHBvaW50ZXIgb24gWSBheGlzIHdoZW4gdGhlIGRyYWdnZWQgZWxlbWVudCBiZWdhbiBtb3ZpbmcgKi9cbiAgICBzdGFydFk6IG51bWJlcjtcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBwb3NpdGlvbiBvZiB0aGUgcG9pbnRlciBvbiBYIGF4aXMgd2hlbiB0aGUgZXZlbnQgd2FzIHRyaWdnZXJlZC5cbiAgICAgKiBOb3RlOiBUaGUgYnJvd3NlciBtaWdodCB0cmlnZ2VyIHRoZSBldmVudCB3aXRoIHNvbWUgZGVsYXkgYW5kIHBvaW50ZXIgd291bGQgYmUgYWxyZWFkeSBpbnNpZGUgdGhlIGlneERyb3AuXG4gICAgICovXG4gICAgcGFnZVg6IG51bWJlcjtcbiAgICAgICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgcG9zaXRpb24gb2YgdGhlIHBvaW50ZXIgb24gWSBheGlzIHdoZW4gdGhlIGV2ZW50IHdhcyB0cmlnZ2VyZWQuXG4gICAgICogTm90ZTogVGhlIGJyb3dzZXIgbWlnaHQgdHJpZ2dlciB0aGUgZXZlbnQgd2l0aCBzb21lIGRlbGF5IGFuZCBwb2ludGVyIHdvdWxkIGJlIGFscmVhZHkgaW5zaWRlIHRoZSBpZ3hEcm9wLlxuICAgICAqL1xuICAgIHBhZ2VZOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSURyYWdTdGFydEV2ZW50QXJncyBleHRlbmRzIElEcmFnQmFzZUV2ZW50QXJncyB7XG4gICAgLyoqIFNldCBpZiB0aGUgdGhlIGRyYWdnaW5nIHNob3VsZCBiZSBjYW5jZWxlZC4gKi9cbiAgICBjYW5jZWw6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSURyYWdNb3ZlRXZlbnRBcmdzIGV4dGVuZHMgSURyYWdTdGFydEV2ZW50QXJncyB7XG4gICAgLyoqIFRoZSBuZXcgcGFnZVggcG9zaXRpb24gb2YgdGhlIHBvaW50ZXIgdGhhdCB0aGUgaWd4RHJhZyB3aWxsIHVzZS4gSXQgY2FuIGJlIG92ZXJyaWRkZW4gdG8gbGltaXQgZHJhZ2dlZCBlbGVtZW50IFggbW92ZW1lbnQuICovXG4gICAgbmV4dFBhZ2VYOiBudW1iZXI7XG4gICAgLyoqIFRoZSBuZXcgcGFnZVggcG9zaXRpb24gb2YgdGhlIHBvaW50ZXIgdGhhdCB0aGUgaWd4RHJhZyB3aWxsIHVzZS4gSXQgY2FuIGJlIG92ZXJyaWRkZW4gdG8gbGltaXQgZHJhZ2dlZCBlbGVtZW50IFkgbW92ZW1lbnQuICovXG4gICAgbmV4dFBhZ2VZOiBudW1iZXI7XG59XG5cblxuZXhwb3J0IGludGVyZmFjZSBJRHJhZ0dob3N0QmFzZUV2ZW50QXJncyBleHRlbmRzIElCYXNlRXZlbnRBcmdzIHtcbiAgICAvKiogVGhlIG93bmVyIGlneERyYWcgZGlyZWN0aXZlIHRoYXQgdHJpZ2dlcmVkIHRoaXMgZXZlbnQuICovXG4gICAgb3duZXI6IElneERyYWdEaXJlY3RpdmU7XG4gICAgLyoqIEluc3RhbmNlIHRvIHRoZSBnaG9zdCBlbGVtZW50IHRoYXQgaXMgY3JlYXRlZCB3aGVuIGRyYWdnaW5nIHN0YXJ0cy4gKi9cbiAgICBnaG9zdEVsZW1lbnQ6IGFueTtcbiAgICAvKiogU2V0IGlmIHRoZSBnaG9zdCBjcmVhdGlvbi9kZXN0cnVjdGlvbiBzaG91bGQgYmUgY2FuY2VsZWQuICovXG4gICAgY2FuY2VsOiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIElEcmFnQ3VzdG9tVHJhbnNpdGlvbkFyZ3Mge1xuICAgIGR1cmF0aW9uPzogbnVtYmVyO1xuICAgIHRpbWluZ0Z1bmN0aW9uPzogc3RyaW5nO1xuICAgIGRlbGF5PzogbnVtYmVyO1xufVxuXG5leHBvcnQgY2xhc3MgSWd4RHJhZ0xvY2F0aW9uIHtcbiAgICBwdWJsaWMgcGFnZVg6IG51bWJlcjtcbiAgICBwdWJsaWMgcGFnZVk6IG51bWJlcjtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgX3BhZ2VYLCBwcml2YXRlIF9wYWdlWSkge1xuICAgICAgICB0aGlzLnBhZ2VYID0gcGFyc2VGbG9hdChfcGFnZVgpO1xuICAgICAgICB0aGlzLnBhZ2VZID0gcGFyc2VGbG9hdChfcGFnZVkpO1xuICAgIH1cbn1cblxuQERpcmVjdGl2ZSh7XG4gICAgZXhwb3J0QXM6ICdkcmFnJyxcbiAgICBzZWxlY3RvcjogJ1tpZ3hEcmFnXSdcbn0pXG5leHBvcnQgY2xhc3MgSWd4RHJhZ0RpcmVjdGl2ZSBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQsIE9uRGVzdHJveSB7XG5cbiAgICBwcm90ZWN0ZWQgZ2hvc3RDb250ZXh0OiBhbnkgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogLSBTYXZlIGRhdGEgaW5zaWRlIHRoZSBgaWd4RHJhZ2AgZGlyZWN0aXZlLiBUaGlzIGNhbiBiZSBzZXQgd2hlbiBpbnN0YW5jaW5nIGBpZ3hEcmFnYCBvbiBhbiBlbGVtZW50LlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IFtpZ3hEcmFnXT1cInsgc291cmNlOiBteUVsZW1lbnQgfVwiPjwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcmFnRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KCdpZ3hEcmFnJylcbiAgICBwdWJsaWMgZGF0YTogYW55O1xuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgaW5kaWNhdGVzIHdoZW4gdGhlIGRyYWcgc2hvdWxkIHN0YXJ0LlxuICAgICAqIEJ5IGRlZmF1bHQgdGhlIGRyYWcgc3RhcnRzIGFmdGVyIHRoZSBkcmFnZ2FibGUgZWxlbWVudCBpcyBtb3ZlZCBieSA1cHguXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyBbZHJhZ1RvbGVyYW5jZV09XCIxMDBcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcmFnRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZHJhZ1RvbGVyYW5jZSA9IDU7XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBwcm92aWRlIGEgd2F5IGZvciBpZ3hEcmFnIGFuZCBpZ3hEcm9wIHRvIGJlIGxpbmtlZCB0aHJvdWdoIGNoYW5uZWxzLlxuICAgICAqIEl0IGFjY2VwdHMgc2luZ2xlIHZhbHVlIG9yIGFuIGFycmF5IG9mIHZhbHVlcyBhbmQgZXZhbHVhdGVzIHRoZW4gdXNpbmcgc3RyaWN0IGVxdWFsaXR5LlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWcgW2RyYWdDaGFubmVsXT1cIidvZGQnXCI+XG4gICAgICogICAgICAgICA8c3Bhbj45NTwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiA8ZGl2IGlneERyb3AgW2Ryb3BDaGFubmVsXT1cIlsnb2RkJywgJ2lycmF0aW9uYWwnXVwiPlxuICAgICAqICAgICAgICAgPHNwYW4+TnVtYmVycyBkcm9wIGFyZWEhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcmFnRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZHJhZ0NoYW5uZWw6IG51bWJlciB8IHN0cmluZyB8IG51bWJlcltdIHwgc3RyaW5nW107XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzcGVjaWZpZXMgaWYgdGhlIGJhc2UgZWxlbWVudCBzaG91bGQgbm90IGJlIG1vdmVkIGFuZCBhIGdob3N0IGVsZW1lbnQgc2hvdWxkIGJlIHJlbmRlcmVkIHRoYXQgcmVwcmVzZW50cyBpdC5cbiAgICAgKiBCeSBkZWZhdWx0IGl0IGlzIHNldCB0byBgdHJ1ZWAuXG4gICAgICogSWYgaXQgaXMgc2V0IHRvIGBmYWxzZWAgd2hlbiBkcmFnZ2luZyB0aGUgYmFzZSBlbGVtZW50IGlzIG1vdmVkIGluc3RlYWQgYW5kIG5vIGdob3N0IGVsZW1lbnRzIGFyZSByZW5kZXJlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hEcmFnIFtnaG9zdF09XCJmYWxzZVwiPlxuICAgICAqICAgICAgPHNwYW4+RHJhZyBNZSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyYWdEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnaG9zdCA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgY3VzdG9tIGNsYXNzIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgYGdob3N0RWxlbWVudGAgZWxlbWVudC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hEcmFnIFtnaG9zdENsYXNzXT1cIidnaG9zdEVsZW1lbnQnXCI+XG4gICAgICogICAgICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJhZ0RpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdob3N0Q2xhc3MgPSAnJztcblxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIFBsZWFzZSB1c2UgY3VzdG9tIGJhc2Ugc3R5bGluZyBpbnN0ZWFkLlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IGhpZGVzIHRoZSBkcmFnZ2FibGUgZWxlbWVudC5cbiAgICAgKiBCeSBkZWZhdWx0IGl0J3Mgc2V0IHRvIGZhbHNlLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWcgW2RyYWdUb2xlcmFuY2VdPVwiMTAwXCIgW2hpZGVCYXNlT25EcmFnXT1cIid0cnVlJ1wiPlxuICAgICAqICAgICAgICAgPHNwYW4+RHJhZyBNZSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyYWdEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBARGVwcmVjYXRlUHJvcGVydHkoYCdoaWRlQmFzZU9uRHJhZycgQElucHV0IHByb3BlcnR5IGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgbWFqb3IgdmVyc2lvbnMuXG4gICAgICAgIEFsdGVybmF0aXZlcyB0byBpdCBhcmUgdXNpbmcgdGhlIG5ldyBubyBnaG9zdCBkcmFnZ2luZyBhbmQgY3VzdG9tIGJhc2Ugc3R5bGluZy5gKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGhpZGVCYXNlT25EcmFnID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBQbGVhc2UgdXNlIHByb3ZpZGVkIHRyYW5zaXRpb24gZnVuY3Rpb25zIGluIGZ1dHVyZS5cbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBlbmFibGVzL2Rpc2FibGVzIHRoZSBkcmFnZ2FibGUgZWxlbWVudCBhbmltYXRpb25cbiAgICAgKiB3aGVuIHRoZSBlbGVtZW50IGlzIHJlbGVhc2VkLlxuICAgICAqIEJ5IGRlZmF1bHQgaXQncyBzZXQgdG8gZmFsc2UuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyBbYW5pbWF0ZU9uUmVsZWFzZV09XCIndHJ1ZSdcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcmFnRGlyZWN0aXZlXG4gICAgICovXG4gICAgQERlcHJlY2F0ZVByb3BlcnR5KGAnYW5pbWF0ZU9uUmVsZWFzZScgQElucHV0IHByb3BlcnR5IGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgbWFqb3IgdmVyc2lvbnMuXG4gICAgICAgIFBsZWFzZSB1c2UgJ3RyYW5zaXRpb25Ub09yaWdpbicgb3IgJ3RyYW5zaXRpb25UbycgbWV0aG9kcyBpbnN0ZWFkLmApXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgYW5pbWF0ZU9uUmVsZWFzZSA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc3BlY2lmaWVzIGEgdGVtcGxhdGUgZm9yIHRoZSBnaG9zdCBlbGVtZW50IGNyZWF0ZWQgd2hlbiBkcmFnZ2luZyBzdGFydHMgYW5kIGBnaG9zdGAgaXMgdHJ1ZS5cbiAgICAgKiBCeSBkZWZhdWx0IGEgY2xvbmUgb2YgdGhlIGJhc2UgZWxlbWVudCB0aGUgaWd4RHJhZyBpcyBpbnN0YW5jZWQgaXMgY3JlYXRlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hEcmFnIFtnaG9zdFRlbXBsYXRlXT1cImN1c3RvbUdob3N0XCI+XG4gICAgICogICAgICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiA8bmctdGVtcGxhdGUgI2N1c3RvbUdob3N0PlxuICAgICAqICAgICAgPGRpdiBjbGFzcz1cImN1c3RvbUdob3N0U3R5bGVcIj5cbiAgICAgKiAgICAgICAgICA8c3Bhbj5JIGFtIGJlaW5nIGRyYWdnZWQhPC9zcGFuPlxuICAgICAqICAgICAgPC9kaXY+XG4gICAgICogPC9uZy10ZW1wbGF0ZT5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJhZ0RpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdob3N0VGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHRoZSBlbGVtZW50IHRvIHdoaWNoIHRoZSBkcmFnZ2VkIGVsZW1lbnQgd2lsbCBiZSBhcHBlbmRlZC5cbiAgICAgKiBCeSBkZWZhdWx0IGl0J3Mgc2V0IHRvIG51bGwgYW5kIHRoZSBkcmFnZ2VkIGVsZW1lbnQgaXMgYXBwZW5kZWQgdG8gdGhlIGJvZHkuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgI2hvc3REaXY+PC9kaXY+XG4gICAgICogPGRpdiBpZ3hEcmFnIFtnaG9zdEhvc3RdPVwiaG9zdERpdlwiPlxuICAgICAqICAgICAgICAgPHNwYW4+RHJhZyBNZSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyYWdEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnaG9zdEhvc3Q7XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzcGVjaWZpZXMgdGhlIG9mZnNldCBvZiB0aGUgZHJhZ2dlZCBlbGVtZW50IHJlbGF0aXZlIHRvIHRoZSBtb3VzZSBpbiBwaXhlbHMuXG4gICAgICogQnkgZGVmYXVsdCBpdCdzIHRha2luZyB0aGUgcmVsYXRpdmUgcG9zaXRpb24gdG8gdGhlIG1vdXNlIHdoZW4gdGhlIGRyYWcgc3RhcnRlZCBhbmQga2VlcHMgaXQgdGhlIHNhbWUuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgI2hvc3REaXY+PC9kaXY+XG4gICAgICogPGRpdiBpZ3hEcmFnIFtnaG9zdE9mZnNldFhdPVwiMFwiPlxuICAgICAqICAgICAgICAgPHNwYW4+RHJhZyBNZSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyYWdEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZXQgZ2hvc3RPZmZzZXRYKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX29mZnNldFggPSBwYXJzZUludCh2YWx1ZSwgMTApO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgZ2hvc3RPZmZzZXRYKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb2Zmc2V0WCAhPT0gdW5kZWZpbmVkID8gdGhpcy5fb2Zmc2V0WCA6IHRoaXMuX2RlZmF1bHRPZmZzZXRYO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNwZWNpZmllcyB0aGUgb2Zmc2V0IG9mIHRoZSBkcmFnZ2VkIGVsZW1lbnQgcmVsYXRpdmUgdG8gdGhlIG1vdXNlIGluIHBpeGVscy5cbiAgICAgKiBCeSBkZWZhdWx0IGl0J3MgdGFraW5nIHRoZSByZWxhdGl2ZSBwb3NpdGlvbiB0byB0aGUgbW91c2Ugd2hlbiB0aGUgZHJhZyBzdGFydGVkIGFuZCBrZWVwcyBpdCB0aGUgc2FtZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiAjaG9zdERpdj48L2Rpdj5cbiAgICAgKiA8ZGl2IGlneERyYWcgW2dob3N0T2Zmc2V0WV09XCIwXCI+XG4gICAgICogICAgICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJhZ0RpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNldCBnaG9zdE9mZnNldFkodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fb2Zmc2V0WSA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG4gICAgfVxuXG4gICAgcHVibGljIGdldCBnaG9zdE9mZnNldFkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vZmZzZXRZICE9PSB1bmRlZmluZWQgPyB0aGlzLl9vZmZzZXRZIDogdGhpcy5fZGVmYXVsdE9mZnNldFkgO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV2ZW50IHRyaWdnZXJlZCB3aGVuIHRoZSBkcmFnZ2FibGUgZWxlbWVudCBkcmFnIHN0YXJ0cy5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hEcmFnIChkcmFnU3RhcnQpPVwib25EcmFnU3RhcnQoKVwiPlxuICAgICAqICAgICAgICAgPHNwYW4+RHJhZyBNZSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBvbkRyYWdTdGFydCgpe1xuICAgICAqICAgICAgYWxlcnQoXCJUaGUgZHJhZyBoYXMgc3RhcmVkIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyYWdEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgZHJhZ1N0YXJ0ID0gbmV3IEV2ZW50RW1pdHRlcjxJRHJhZ1N0YXJ0RXZlbnRBcmdzPigpO1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgdHJpZ2dlcmVkIHdoZW4gdGhlIGRyYWdnYWJsZSBlbGVtZW50IGhhcyBiZWVuIG1vdmVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWcgIChkcmFnTW92ZSk9XCJvbkRyYWdNb3ZlKClcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgb25EcmFnTW92ZSgpe1xuICAgICAqICAgICAgYWxlcnQoXCJUaGUgZWxlbWVudCBoYXMgbW92ZWQhXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJhZ0RpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBkcmFnTW92ZSA9IG5ldyBFdmVudEVtaXR0ZXI8SURyYWdNb3ZlRXZlbnRBcmdzPigpO1xuXG4gICAgLyoqXG4gICAgICogRXZlbnQgdHJpZ2dlcmVkIHdoZW4gdGhlIGRyYWdnYWJsZSBlbGVtZW50IGlzIHJlbGVhc2VkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWcgKGRyYWdFbmQpPVwib25EcmFnRW5kKClcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgb25EcmFnRW5kKCl7XG4gICAgICogICAgICBhbGVydChcIlRoZSBkcmFnIGhhcyBlbmRlZCFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcmFnRGlyZWN0aXZlXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIGRyYWdFbmQgPSBuZXcgRXZlbnRFbWl0dGVyPElEcmFnQmFzZUV2ZW50QXJncz4oKTtcblxuICAgIC8qKlxuICAgICAqIEV2ZW50IHRyaWdnZXJlZCB3aGVuIHRoZSBkcmFnZ2FibGUgZWxlbWVudCBpcyBjbGlja2VkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWcgKGRyYWdDbGljayk9XCJvbkRyYWdDbGljaygpXCI+XG4gICAgICogICAgICAgICA8c3Bhbj5EcmFnIE1lITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIG9uRHJhZ0NsaWNrKCl7XG4gICAgICogICAgICBhbGVydChcIlRoZSBlbGVtZW50IGhhcyBiZWVuIGNsaWNrZWQhXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJhZ0RpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBkcmFnQ2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyPElEcmFnQmFzZUV2ZW50QXJncz4oKTtcblxuICAgIC8qKlxuICAgICAqIEV2ZW50IHRyaWdnZXJlZCB3aGVuIHRoZSBkcmFnIGdob3N0IGVsZW1lbnQgaXMgY3JlYXRlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hEcmFnIChnaG9zdENyZWF0ZSk9XCJnaG9zdENyZWF0ZWQoKVwiPlxuICAgICAqICAgICAgICAgPHNwYW4+RHJhZyBNZSE8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHB1YmxpYyBnaG9zdENyZWF0ZWQoKXtcbiAgICAgKiAgICAgIGFsZXJ0KFwiVGhlIGdob3N0IGhhcyBiZWVuIGNyZWF0ZWQhXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJhZ0RpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBnaG9zdENyZWF0ZSA9IG5ldyBFdmVudEVtaXR0ZXI8SURyYWdHaG9zdEJhc2VFdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCB0cmlnZ2VyZWQgd2hlbiB0aGUgZHJhZyBnaG9zdCBlbGVtZW50IGlzIGNyZWF0ZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgaWd4RHJhZyAoZ2hvc3REZXN0cm95KT1cImdob3N0RGVzdHJveWVkKClcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgZ2hvc3REZXN0cm95ZWQoKXtcbiAgICAgKiAgICAgIGFsZXJ0KFwiVGhlIGdob3N0IGhhcyBiZWVuIGRlc3Ryb3llZCFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcmFnRGlyZWN0aXZlXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIGdob3N0RGVzdHJveSA9IG5ldyBFdmVudEVtaXR0ZXI8SURyYWdHaG9zdEJhc2VFdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFdmVudCB0cmlnZ2VyZWQgYWZ0ZXIgdGhlIGRyYWdnYWJsZSBlbGVtZW50IGlzIHJlbGVhc2VkIGFuZCBhZnRlciBpdHMgYW5pbWF0aW9uIGhhcyBmaW5pc2hlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBpZ3hEcmFnICh0cmFuc2l0aW9uZWQpPVwib25Nb3ZlRW5kKClcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPkRyYWcgTWUhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgb25Nb3ZlRW5kKCl7XG4gICAgICogICAgICBhbGVydChcIlRoZSBtb3ZlIGhhcyBlbmRlZCFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcmFnRGlyZWN0aXZlXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIHRyYW5zaXRpb25lZCA9IG5ldyBFdmVudEVtaXR0ZXI8SURyYWdCYXNlRXZlbnRBcmdzPigpO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGRyZW4oSWd4RHJhZ0hhbmRsZURpcmVjdGl2ZSlcbiAgICBwdWJsaWMgZHJhZ0hhbmRsZXM6IFF1ZXJ5TGlzdDxJZ3hEcmFnSGFuZGxlRGlyZWN0aXZlPjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ3N0eWxlLnZpc2liaWxpdHknKVxuICAgIHB1YmxpYyBfdmlzaWJpbGl0eSA9ICd2aXNpYmxlJztcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1kcmFnJylcbiAgICBwdWJsaWMgYmFzZUNsYXNzID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1kcmFnLS1zZWxlY3QtZGlzYWJsZWQnKVxuICAgIHB1YmxpYyBzZWxlY3REaXNhYmxlZCA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgUGxlYXNlIHVzZSBuYXRpdmUgYW5ndWxhciB3YXlzIG9mIGhpZGluZyBpdCB1c2luZyBjdXN0b20gdG8gdGhlIGJhc2UgZWxlbWVudCBzdHlsaW5nIGZvciBmdXR1cmUgdmVyc2lvbnMuXG4gICAgICogU2V0cyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoXCJteURyYWdcIiAse3JlYWQ6IElneERyYWdEaXJlY3RpdmV9KVxuICAgICAqIHB1YmxpYyBteURyYWc6IElneERyYWdEaXJlY3RpdmU7XG4gICAgICogbmdBZnRlclZpZXdJbml0KCl7XG4gICAgICogICAgIHRoaXMubXlEcmFnLnZpc2libGUgPSBmYWxzZTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQERlcHJlY2F0ZVByb3BlcnR5KGAndmlzaWJsZScgQElucHV0IHByb3BlcnR5IGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgbWFqb3IgdmVyc2lvbnMuXG4gICAgICAgIFBsZWFzZSB1c2UgbmF0aXZlIGFuZ3VsYXIgd2F5cyBvZiBoaWRpbmcgdGhlIGJhc2UgZWxlbWVudCB1c2luZyBzdHlsaW5nLmApXG4gICAgcHVibGljIHNldCB2aXNpYmxlKGJWaXNpYmxlKSB7XG4gICAgICAgIHRoaXMuX3Zpc2liaWxpdHkgPSBiVmlzaWJsZSA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nO1xuICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmlzaWJpbGl0eSBzdGF0ZSBvZiB0aGUgZHJhZ2dhYmxlIGVsZW1lbnQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoXCJteURyYWdcIiAse3JlYWQ6IElneERyYWdEaXJlY3RpdmV9KVxuICAgICAqIHB1YmxpYyBteURyYWc6IElneERyYWdEaXJlY3RpdmU7XG4gICAgICogbmdBZnRlclZpZXdJbml0KCl7XG4gICAgICogICAgIGxldCBkcmFnVmlzaWJpbGl0eSA9IHRoaXMubXlEcmFnLnZpc2libGU7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgdmlzaWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Zpc2liaWxpdHkgPT09ICd2aXNpYmxlJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IGxvY2F0aW9uIG9mIHRoZSBlbGVtZW50IHJlbGF0aXZlIHRvIHRoZSBwYWdlLlxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgbG9jYXRpb24oKTogSWd4RHJhZ0xvY2F0aW9uIHtcbiAgICAgICAgcmV0dXJuIG5ldyBJZ3hEcmFnTG9jYXRpb24odGhpcy5wYWdlWCwgdGhpcy5wYWdlWSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgb3JpZ2luYWwgbG9jYXRpb24gb2YgdGhlIGVsZW1lbnQgYmVmb3JlIGRyYWdnaW5nIHN0YXJ0ZWQuXG4gICAgICovXG4gICAgcHVibGljIGdldCBvcmlnaW5Mb2NhdGlvbigpOiBJZ3hEcmFnTG9jYXRpb24ge1xuICAgICAgICByZXR1cm4gbmV3IElneERyYWdMb2NhdGlvbih0aGlzLmJhc2VPcmlnaW5MZWZ0LCB0aGlzLmJhc2VPcmlnaW5Ub3ApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHBvaW50ZXJFdmVudHNFbmFibGVkKCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIFBvaW50ZXJFdmVudCAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgdG91Y2hFdmVudHNFbmFibGVkKCkge1xuICAgICAgICByZXR1cm4gJ29udG91Y2hzdGFydCcgaW4gd2luZG93O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHBhZ2VYKCkge1xuICAgICAgICBpZiAodGhpcy5naG9zdCAmJiB0aGlzLmdob3N0RWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2hvc3RMZWZ0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VMZWZ0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHBhZ2VZKCkge1xuICAgICAgICBpZiAodGhpcy5naG9zdCAmJiB0aGlzLmdob3N0RWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2hvc3RUb3A7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZVRvcDtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0IGJhc2VMZWZ0KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXQgYmFzZVRvcCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXQgYmFzZU9yaWdpbkxlZnQoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmFzZUxlZnQgLSB0aGlzLmdldFRyYW5zZm9ybVgodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXQgYmFzZU9yaWdpblRvcCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXNlVG9wIC0gdGhpcy5nZXRUcmFuc2Zvcm1ZKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgc2V0IGdob3N0TGVmdChwYWdlWDogbnVtYmVyKSB7XG4gICAgICAgIC8vIFRvIERvOiBSZW1vdmUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHdoZW4gZGVwcmVjYXRlZCBhbmltYXRpb25zIGlucHV0cyBhcmUgcmVtb3ZlZCBhcyB3ZWxsLlxuICAgICAgICAvLyBXZSB1c2UgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGZvciB0aGUgb2xkIGRyb3AgYW5pbWF0aW9ucyBpbiBjb21iaW5hdGlvbiB3aXRoIHVwZGF0ZURyYWdSZWxhdGl2ZVBvcy5cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdob3N0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gdGFrZSBpbnRvIGFjY291bnQgbWFyZ2luTGVmdCwgc2luY2UgdG9wIHN0eWxlIGRvZXMgbm90IGluY2x1ZGUgbWFyZ2luLCBidXQgcGFnZVggaW5jbHVkZXMgdGhlIG1hcmdpbi5cbiAgICAgICAgICAgICAgICBjb25zdCBnaG9zdE1hcmdpbkxlZnQgPSBwYXJzZUludChkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZ2hvc3RFbGVtZW50KVsnbWFyZ2luLWxlZnQnXSwgMTApO1xuICAgICAgICAgICAgICAgIC8vIElmIGdob3N0IGhvc3QgaXMgZGVmaW5lZCBpdCBuZWVkcyB0byBiZSB0YWtlbiBpbnRvIGFjY291bnQuXG4gICAgICAgICAgICAgICAgdGhpcy5naG9zdEVsZW1lbnQuc3R5bGUubGVmdCA9IChwYWdlWCAtIGdob3N0TWFyZ2luTGVmdCAtIHRoaXMuX2dob3N0SG9zdFgpICsgJ3B4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdldCBnaG9zdExlZnQoKSB7XG4gICAgICAgIHJldHVybiBwYXJzZUludCh0aGlzLmdob3N0RWxlbWVudC5zdHlsZS5sZWZ0LCAxMCkgKyB0aGlzLl9naG9zdEhvc3RYO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBzZXQgZ2hvc3RUb3AocGFnZVk6IG51bWJlcikge1xuICAgICAgICAvLyBUbyBEbzogUmVtb3ZlIHJlcXVlc3RBbmltYXRpb25GcmFtZSB3aGVuIGRlcHJlY2F0ZWQgYW5pbWF0aW9ucyBpbnB1dHMgYXJlIHJlbW92ZWQgYXMgd2VsbC5cbiAgICAgICAgLy8gV2UgdXNlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBmb3IgdGhlIG9sZCBkcm9wIGFuaW1hdGlvbnMgaW4gY29tYmluYXRpb24gd2l0aCB1cGRhdGVEcmFnUmVsYXRpdmVQb3MuXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5naG9zdEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHRha2UgaW50byBhY2NvdW50IG1hcmdpblRvcCwgc2luY2UgdG9wIHN0eWxlIGRvZXMgbm90IGluY2x1ZGUgbWFyZ2luLCBidXQgcGFnZVkgaW5jbHVkZXMgdGhlIG1hcmdpbi5cbiAgICAgICAgICAgICAgICBjb25zdCBnaG9zdE1hcmdpblRvcCA9IHBhcnNlSW50KGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUodGhpcy5naG9zdEVsZW1lbnQpWydtYXJnaW4tdG9wJ10sIDEwKTtcbiAgICAgICAgICAgICAgICAvLyBJZiBnaG9zdCBob3N0IGlzIGRlZmluZWQgaXQgbmVlZHMgdG8gYmUgdGFrZW4gaW50byBhY2NvdW50LlxuICAgICAgICAgICAgICAgIHRoaXMuZ2hvc3RFbGVtZW50LnN0eWxlLnRvcCA9IChwYWdlWSAtIGdob3N0TWFyZ2luVG9wIC0gdGhpcy5fZ2hvc3RIb3N0WSkgKyAncHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgZ2V0IGdob3N0VG9wKCkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQodGhpcy5naG9zdEVsZW1lbnQuc3R5bGUudG9wLCAxMCkgKyB0aGlzLl9naG9zdEhvc3RZO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZGVmYXVsdFJldHVybkR1cmF0aW9uID0gJzAuNXMnO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBnaG9zdEVsZW1lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGFuaW1JblByb2dyZXNzID0gZmFsc2U7XG5cbiAgICBwcm90ZWN0ZWQgX2Jhc2VNYXJnaW5MZWZ0ID0gMDtcbiAgICBwcm90ZWN0ZWQgX2Jhc2VNYXJnaW5Ub3AgPSAwO1xuICAgIHByb3RlY3RlZCBfYmFzZU9yaWdpblg7XG4gICAgcHJvdGVjdGVkIF9iYXNlT3JpZ2luWTtcbiAgICBwcm90ZWN0ZWQgX3N0YXJ0WCA9IDA7XG4gICAgcHJvdGVjdGVkIF9zdGFydFkgPSAwO1xuICAgIHByb3RlY3RlZCBfbGFzdFggPSAwO1xuICAgIHByb3RlY3RlZCBfbGFzdFkgPSAwO1xuICAgIHByb3RlY3RlZCBfZHJhZ1N0YXJ0ZWQgPSBmYWxzZTtcblxuICAgIC8qKiBEcmFnIGdob3N0IHJlbGF0ZWQgcHJvcGVydGllcyAqL1xuICAgIHByb3RlY3RlZCBfZGVmYXVsdE9mZnNldFg7XG4gICAgcHJvdGVjdGVkIF9kZWZhdWx0T2Zmc2V0WTtcbiAgICBwcm90ZWN0ZWQgX29mZnNldFg7XG4gICAgcHJvdGVjdGVkIF9vZmZzZXRZO1xuICAgIHByb3RlY3RlZCBfZ2hvc3RTdGFydFg7XG4gICAgcHJvdGVjdGVkIF9naG9zdFN0YXJ0WTtcbiAgICBwcm90ZWN0ZWQgX2dob3N0SG9zdFggPSAwO1xuICAgIHByb3RlY3RlZCBfZ2hvc3RIb3N0WSA9IDA7XG5cbiAgICBwcm90ZWN0ZWQgX3BvaW50ZXJEb3duSWQgPSBudWxsO1xuICAgIHByb3RlY3RlZCBfY2xpY2tlZCA9IGZhbHNlO1xuICAgIHByb3RlY3RlZCBfbGFzdERyb3BBcmVhID0gbnVsbDtcblxuICAgIHByb3RlY3RlZCBfZGVzdHJveSA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG4gICAgcHJvdGVjdGVkIF9yZW1vdmVPbkRlc3Ryb3kgPSB0cnVlO1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIHB1YmxpYyBjZHI6IENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBwdWJsaWMgZWxlbWVudDogRWxlbWVudFJlZixcbiAgICAgICAgcHVibGljIHZpZXdDb250YWluZXI6IFZpZXdDb250YWluZXJSZWYsXG4gICAgICAgIHB1YmxpYyB6b25lOiBOZ1pvbmUsXG4gICAgICAgIHB1YmxpYyByZW5kZXJlcjogUmVuZGVyZXIyXG4gICAgKSB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgICAgIGlmICghdGhpcy5kcmFnSGFuZGxlcyB8fCAhdGhpcy5kcmFnSGFuZGxlcy5sZW5ndGggKSB7XG4gICAgICAgICAgICAvLyBTZXQgdXNlciBzZWxlY3Qgbm9uZSB0byB0aGUgd2hvbGUgZHJhZ2dhYmxlIGVsZW1lbnQgaWYgbm8gZHJhZyBoYW5kbGVzIGFyZSBkZWZpbmVkLlxuICAgICAgICAgICAgdGhpcy5zZWxlY3REaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCaW5kIGV2ZW50c1xuICAgICAgICB0aGlzLnpvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudHMgPSB0aGlzLmRyYWdIYW5kbGVzICYmIHRoaXMuZHJhZ0hhbmRsZXMubGVuZ3RoID9cbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdIYW5kbGVzLm1hcCgoaXRlbSkgPT4gaXRlbS5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpIDogW3RoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50XTtcbiAgICAgICAgICAgIHRhcmdldEVsZW1lbnRzLmZvckVhY2goKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wb2ludGVyRXZlbnRzRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICBmcm9tRXZlbnQoZWxlbWVudCwgJ3BvaW50ZXJkb3duJykucGlwZSh0YWtlVW50aWwodGhpcy5fZGVzdHJveSkpXG4gICAgICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKHJlcykgPT4gdGhpcy5vblBvaW50ZXJEb3duKHJlcykpO1xuXG4gICAgICAgICAgICAgICAgICAgIGZyb21FdmVudChlbGVtZW50LCAncG9pbnRlcm1vdmUnKS5waXBlKFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3R0bGUoKCkgPT4gaW50ZXJ2YWwoMCwgYW5pbWF0aW9uRnJhbWVTY2hlZHVsZXIpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRha2VVbnRpbCh0aGlzLl9kZXN0cm95KVxuICAgICAgICAgICAgICAgICAgICApLnN1YnNjcmliZSgocmVzKSA9PiB0aGlzLm9uUG9pbnRlck1vdmUocmVzKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZnJvbUV2ZW50KGVsZW1lbnQsICdwb2ludGVydXAnKS5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95KSlcbiAgICAgICAgICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKHJlcykgPT4gdGhpcy5vblBvaW50ZXJVcChyZXMpKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZ2hvc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdCBiaW5kIGBsb3N0cG9pbnRlcmNhcHR1cmVgIHRvIHRoZSB0YXJnZXQsIGJlY2F1c2Ugd2Ugd2lsbCBiaW5kIGl0IG9uIHRoZSBnaG9zdCBsYXRlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZyb21FdmVudChlbGVtZW50LCAnbG9zdHBvaW50ZXJjYXB0dXJlJykucGlwZSh0YWtlVW50aWwodGhpcy5fZGVzdHJveSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKChyZXMpID0+IHRoaXMub25Qb2ludGVyTG9zdChyZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy50b3VjaEV2ZW50c0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbUV2ZW50KGVsZW1lbnQsICd0b3VjaHN0YXJ0JykucGlwZSh0YWtlVW50aWwodGhpcy5fZGVzdHJveSkpXG4gICAgICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKHJlcykgPT4gdGhpcy5vblBvaW50ZXJEb3duKHJlcykpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IGhhdmUgcG9pbnRlciBldmVudHMgYW5kIHRvdWNoIGV2ZW50cy4gVXNlIHRoZW4gbW91c2UgZXZlbnRzLlxuICAgICAgICAgICAgICAgICAgICBmcm9tRXZlbnQoZWxlbWVudCwgJ21vdXNlZG93bicpLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kpKVxuICAgICAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKChyZXMpID0+IHRoaXMub25Qb2ludGVyRG93bihyZXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gV2Ugc2hvdWxkIGJpbmQgdG8gZG9jdW1lbnQgZXZlbnRzIG9ubHkgb25jZSB3aGVuIHRoZXJlIGFyZSBubyBwb2ludGVyIGV2ZW50cy5cbiAgICAgICAgICAgIGlmICghdGhpcy5wb2ludGVyRXZlbnRzRW5hYmxlZCAmJiB0aGlzLnRvdWNoRXZlbnRzRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGZyb21FdmVudChkb2N1bWVudC5kZWZhdWx0VmlldywgJ3RvdWNobW92ZScpLnBpcGUoXG4gICAgICAgICAgICAgICAgICAgIHRocm90dGxlKCgpID0+IGludGVydmFsKDAsIGFuaW1hdGlvbkZyYW1lU2NoZWR1bGVyKSksXG4gICAgICAgICAgICAgICAgICAgIHRha2VVbnRpbCh0aGlzLl9kZXN0cm95KVxuICAgICAgICAgICAgICAgICkuc3Vic2NyaWJlKChyZXMpID0+IHRoaXMub25Qb2ludGVyTW92ZShyZXMpKTtcblxuICAgICAgICAgICAgICAgIGZyb21FdmVudChkb2N1bWVudC5kZWZhdWx0VmlldywgJ3RvdWNoZW5kJykucGlwZSh0YWtlVW50aWwodGhpcy5fZGVzdHJveSkpXG4gICAgICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKHJlcykgPT4gdGhpcy5vblBvaW50ZXJVcChyZXMpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMucG9pbnRlckV2ZW50c0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBmcm9tRXZlbnQoZG9jdW1lbnQuZGVmYXVsdFZpZXcsICdtb3VzZW1vdmUnKS5waXBlKFxuICAgICAgICAgICAgICAgICAgICB0aHJvdHRsZSgoKSA9PiBpbnRlcnZhbCgwLCBhbmltYXRpb25GcmFtZVNjaGVkdWxlcikpLFxuICAgICAgICAgICAgICAgICAgICB0YWtlVW50aWwodGhpcy5fZGVzdHJveSlcbiAgICAgICAgICAgICAgICApLnN1YnNjcmliZSgocmVzKSA9PiB0aGlzLm9uUG9pbnRlck1vdmUocmVzKSk7XG5cbiAgICAgICAgICAgICAgICBmcm9tRXZlbnQoZG9jdW1lbnQuZGVmYXVsdFZpZXcsICdtb3VzZXVwJykucGlwZSh0YWtlVW50aWwodGhpcy5fZGVzdHJveSkpXG4gICAgICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKHJlcykgPT4gdGhpcy5vblBvaW50ZXJVcChyZXMpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIChhcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblRyYW5zaXRpb25FbmQoYXJncyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fYmFzZU1hcmdpbkxlZnQgPSBwYXJzZUludChkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KVsnbWFyZ2luLWxlZnQnXSwgMTApO1xuICAgICAgICB0aGlzLl9iYXNlTWFyZ2luVG9wID0gcGFyc2VJbnQoZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudClbJ21hcmdpbi10b3AnXSwgMTApO1xuICAgICAgICB0aGlzLl9iYXNlT3JpZ2luWCA9IHRoaXMuYmFzZUxlZnQ7XG4gICAgICAgIHRoaXMuX2Jhc2VPcmlnaW5ZID0gdGhpcy5iYXNlVG9wO1xuICAgICAgICB0aGlzLl9naG9zdFN0YXJ0WCA9IHRoaXMuYmFzZUxlZnQ7XG4gICAgICAgIHRoaXMuX2dob3N0U3RhcnRZID0gdGhpcy5iYXNlVG9wO1xuICAgICAgICAvLyBTZXQgdHJhbnNpdGlvbiBkdXJhdGlvbiB0byAwcy4gVGhpcyBhbHNvIGhlbHBzIHdpdGggc2V0dGluZyBgdmlzaWJpbGl0eTogaGlkZGVuYCB0byB0aGUgYmFzZSB0byBub3QgbGFnLlxuICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSAnMC4wcyc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveS5uZXh0KHRydWUpO1xuICAgICAgICB0aGlzLl9kZXN0cm95LmNvbXBsZXRlKCk7XG5cbiAgICAgICAgaWYgKHRoaXMuZ2hvc3QgJiYgdGhpcy5naG9zdEVsZW1lbnQgJiYgdGhpcy5fcmVtb3ZlT25EZXN0cm95KSB7XG4gICAgICAgICAgICB0aGlzLmdob3N0RWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZ2hvc3RFbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuZ2hvc3RFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgZGVzaXJlZCBsb2NhdGlvbiBvZiB0aGUgYmFzZSBlbGVtZW50IG9yIGdob3N0IGVsZW1lbnQgaWYgcmVuZGVkIHJlbGF0aXZlIHRvIHRoZSBkb2N1bWVudC5cbiAgICAgKiBAcGFyYW0gbmV3TG9jYXRpb24gTmV3IGxvY2F0aW9uIHRoYXQgc2hvdWxkIGJlIGFwcGxpZWQuIEl0IGlzIGFkdmlzZWQgdG8gZ2V0IG5ldyBsb2NhdGlvbiB1c2luZyBnZXRCb3VuZGluZ0NsaWVudFJlY3RzKCkgKyBzY3JvbGwuXG4gICAgICovXG4gICAgcHVibGljIHNldExvY2F0aW9uKG5ld0xvY2F0aW9uOiBJZ3hEcmFnTG9jYXRpb24pIHtcbiAgICAgICAgLy8gV2UgZG8gbm90IHN1YnRyYWN0IG1hcmdpbkxlZnQgYW5kIG1hcmdpblRvcCBoZXJlIGJlY2F1c2UgaGVyZSB3ZSBjYWxjdWxhdGUgZGVsdGFzLlxuICAgICAgICBpZiAodGhpcy5naG9zdCAmJiB0aGlzLmdob3N0RWxlbWVudCkge1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0SG9zdFggPSB0aGlzLmdob3N0SG9zdCA/IHRoaXMuZ2hvc3RIb3N0T2Zmc2V0TGVmdCh0aGlzLmdob3N0SG9zdCkgOiAwO1xuICAgICAgICAgICAgY29uc3Qgb2Zmc2V0SG9zdFkgPSB0aGlzLmdob3N0SG9zdCA/IHRoaXMuZ2hvc3RIb3N0T2Zmc2V0VG9wKHRoaXMuZ2hvc3RIb3N0KSA6IDA7XG4gICAgICAgICAgICB0aGlzLmdob3N0TGVmdCA9IG5ld0xvY2F0aW9uLnBhZ2VYIC0gb2Zmc2V0SG9zdFggKyB0aGlzLmdldFdpbmRvd1Njcm9sbExlZnQoKTtcbiAgICAgICAgICAgIHRoaXMuZ2hvc3RUb3AgPSBuZXdMb2NhdGlvbi5wYWdlWSAtIG9mZnNldEhvc3RZICsgdGhpcy5nZXRXaW5kb3dTY3JvbGxUb3AoKTtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5naG9zdCkge1xuICAgICAgICAgICAgY29uc3QgZGVsdGFYID0gbmV3TG9jYXRpb24ucGFnZVggLSB0aGlzLnBhZ2VYO1xuICAgICAgICAgICAgY29uc3QgZGVsdGFZID0gbmV3TG9jYXRpb24ucGFnZVkgLSB0aGlzLnBhZ2VZO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtWCA9IHRoaXMuZ2V0VHJhbnNmb3JtWCh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1ZID0gdGhpcy5nZXRUcmFuc2Zvcm1ZKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtWFkodHJhbnNmb3JtWCArIGRlbHRhWCwgdHJhbnNmb3JtWSArIGRlbHRhWSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zdGFydFggPSB0aGlzLmJhc2VMZWZ0O1xuICAgICAgICB0aGlzLl9zdGFydFkgPSB0aGlzLmJhc2VUb3A7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW5pbWF0ZXMgdGhlIGJhc2Ugb3IgZ2hvc3QgZWxlbWVudCBkZXBlbmRpbmcgb24gdGhlIGBnaG9zdGAgaW5wdXQgdG8gaXRzIGluaXRpYWwgbG9jYXRpb24uXG4gICAgICogSWYgYGdob3N0YCBpcyB0cnVlIGJ1dCB0aGVyZSBpcyBub3QgZ2hvc3QgcmVuZGVyZWQsIGl0IHdpbGwgYmUgY3JlYXRlZCBhbmQgYW5pbWF0ZWQuXG4gICAgICogSWYgdGhlIGJhc2UgZWxlbWVudCBoYXMgY2hhbmdlZCBpdHMgRE9NIHBvc2l0aW9uIGl0cyBpbml0aWFsIGxvY2F0aW9uIHdpbGwgYmUgY2hhbmdlZCBhY2NvcmRpbmdseS5cbiAgICAgKiBAcGFyYW0gY3VzdG9tQW5pbUFyZ3MgQ3VzdG9tIHRyYW5zaXRpb24gcHJvcGVydGllcyB0aGF0IHdpbGwgYmUgYXBwbGllZCB3aGVuIHBlcmZvcm1pbmcgdGhlIHRyYW5zaXRpb24uXG4gICAgICogQHBhcmFtIHN0YXJ0TG9jYXRpb24gU3RhcnQgbG9jYXRpb24gZnJvbSB3aGVyZSB0aGUgdHJhbnNpdGlvbiBzaG91bGQgc3RhcnQuXG4gICAgICovXG4gICAgcHVibGljIHRyYW5zaXRpb25Ub09yaWdpbihjdXN0b21BbmltQXJncz86IElEcmFnQ3VzdG9tVHJhbnNpdGlvbkFyZ3MsIHN0YXJ0TG9jYXRpb24/OiBJZ3hEcmFnTG9jYXRpb24pIHtcbiAgICAgICAgaWYgKCghIXN0YXJ0TG9jYXRpb24gJiYgc3RhcnRMb2NhdGlvbi5wYWdlWCA9PT0gdGhpcy5iYXNlT3JpZ2luTGVmdCAmJiBzdGFydExvY2F0aW9uLnBhZ2VZID09PSB0aGlzLmJhc2VPcmlnaW5MZWZ0KSB8fFxuICAgICAgICAgICAgKCFzdGFydExvY2F0aW9uICYmIHRoaXMuZ2hvc3QgJiYgIXRoaXMuZ2hvc3RFbGVtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCEhc3RhcnRMb2NhdGlvbiAmJiBzdGFydExvY2F0aW9uLnBhZ2VYICE9PSB0aGlzLnBhZ2VYICYmIHN0YXJ0TG9jYXRpb24ucGFnZVkgIT09IHRoaXMucGFnZVkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdob3N0ICYmICF0aGlzLmdob3N0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0WCA9IHN0YXJ0TG9jYXRpb24ucGFnZVg7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRZID0gc3RhcnRMb2NhdGlvbi5wYWdlWTtcbiAgICAgICAgICAgICAgICB0aGlzLl9naG9zdFN0YXJ0WCA9IHRoaXMuX3N0YXJ0WDtcbiAgICAgICAgICAgICAgICB0aGlzLl9naG9zdFN0YXJ0WSA9IHRoaXMuX3N0YXJ0WTtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUdob3N0KHRoaXMuX3N0YXJ0WCwgdGhpcy5fc3RhcnRZKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zZXRMb2NhdGlvbihzdGFydExvY2F0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYW5pbUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAvLyBVc2Ugc2V0VGltZW91dCBiZWNhdXNlIHdlIG5lZWQgdG8gYmUgc3VyZSB0aGF0IHRoZSBlbGVtZW50IGlzIHBvc2l0aW9uZWQgZmlyc3QgY29ycmVjdGx5IGlmIHRoZXJlIGlzIHN0YXJ0IGxvY2F0aW9uLlxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmdob3N0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5naG9zdEVsZW1lbnQuc3R5bGUudHJhbnNpdGlvblByb3BlcnR5ID0gJ3RvcCwgbGVmdCc7XG4gICAgICAgICAgICAgICAgdGhpcy5naG9zdEVsZW1lbnQuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID1cbiAgICAgICAgICAgICAgICAgICAgY3VzdG9tQW5pbUFyZ3MgJiYgY3VzdG9tQW5pbUFyZ3MuZHVyYXRpb24gPyBjdXN0b21BbmltQXJncy5kdXJhdGlvbiArICdzJyA6IHRoaXMuZGVmYXVsdFJldHVybkR1cmF0aW9uIDtcbiAgICAgICAgICAgICAgICB0aGlzLmdob3N0RWxlbWVudC5zdHlsZS50cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24gPVxuICAgICAgICAgICAgICAgICAgICBjdXN0b21BbmltQXJncyAmJiBjdXN0b21BbmltQXJncy50aW1pbmdGdW5jdGlvbiA/IGN1c3RvbUFuaW1BcmdzLnRpbWluZ0Z1bmN0aW9uIDogJyc7XG4gICAgICAgICAgICAgICAgdGhpcy5naG9zdEVsZW1lbnQuc3R5bGUudHJhbnNpdGlvbkRlbGF5ID0gY3VzdG9tQW5pbUFyZ3MgJiYgY3VzdG9tQW5pbUFyZ3MuZGVsYXkgPyBjdXN0b21BbmltQXJncy5kZWxheSArICdzJyA6ICcnO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0TG9jYXRpb24obmV3IElneERyYWdMb2NhdGlvbih0aGlzLmJhc2VMZWZ0LCB0aGlzLmJhc2VUb3ApKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuZ2hvc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5zdHlsZS50cmFuc2l0aW9uUHJvcGVydHkgPSAndHJhbnNmb3JtJztcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPVxuICAgICAgICAgICAgICAgICAgICBjdXN0b21BbmltQXJncyAmJiBjdXN0b21BbmltQXJncy5kdXJhdGlvbiA/IGN1c3RvbUFuaW1BcmdzLmR1cmF0aW9uICsgJ3MnIDogdGhpcy5kZWZhdWx0UmV0dXJuRHVyYXRpb24gO1xuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLnRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbiA9XG4gICAgICAgICAgICAgICAgICAgIGN1c3RvbUFuaW1BcmdzICYmIGN1c3RvbUFuaW1BcmdzLnRpbWluZ0Z1bmN0aW9uID8gY3VzdG9tQW5pbUFyZ3MudGltaW5nRnVuY3Rpb24gOiAnJztcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5zdHlsZS50cmFuc2l0aW9uRGVsYXkgPSBjdXN0b21BbmltQXJncyAmJiBjdXN0b21BbmltQXJncy5kZWxheSA/IGN1c3RvbUFuaW1BcmdzLmRlbGF5ICsgJ3MnIDogJyc7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3RhcnRYID0gdGhpcy5iYXNlTGVmdDtcbiAgICAgICAgICAgICAgICB0aGlzLl9zdGFydFkgPSB0aGlzLmJhc2VUb3A7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm1YWSgwLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQW5pbWF0ZXMgdGhlIGJhc2Ugb3IgZ2hvc3QgZWxlbWVudCB0byBhIHNwZWNpZmljIHRhcmdldCBsb2NhdGlvbiBvciBvdGhlciBlbGVtZW50IHVzaW5nIHRyYW5zaXRpb24uXG4gICAgICogSWYgYGdob3N0YCBpcyB0cnVlIGJ1dCB0aGVyZSBpcyBub3QgZ2hvc3QgcmVuZGVyZWQsIGl0IHdpbGwgYmUgY3JlYXRlZCBhbmQgYW5pbWF0ZWQuXG4gICAgICogSXQgaXMgcmVjb21tZW5kZWQgdG8gdXNlICdnZXRCb3VuZGluZ0NsaWVudFJlY3RzKCkgKyBwYWdlU2Nyb2xsJyB3aGVuIGRldGVybWluaW5nIGRlc2lyZWQgbG9jYXRpb24uXG4gICAgICogQHBhcmFtIHRhcmdldCBUYXJnZXQgdGhhdCB0aGUgYmFzZSBvciBnaG9zdCB3aWxsIHRyYW5zaXRpb24gdG8uIEl0IGNhbiBiZSBlaXRoZXIgbG9jYXRpb24gaW4gdGhlIHBhZ2Ugb3IgYW5vdGhlciBIVE1MIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIGN1c3RvbUFuaW1BcmdzIEN1c3RvbSB0cmFuc2l0aW9uIHByb3BlcnRpZXMgdGhhdCB3aWxsIGJlIGFwcGxpZWQgd2hlbiBwZXJmb3JtaW5nIHRoZSB0cmFuc2l0aW9uLlxuICAgICAqIEBwYXJhbSBzdGFydExvY2F0aW9uIFN0YXJ0IGxvY2F0aW9uIGZyb20gd2hlcmUgdGhlIHRyYW5zaXRpb24gc2hvdWxkIHN0YXJ0LlxuICAgICAqL1xuICAgIHB1YmxpYyB0cmFuc2l0aW9uVG8odGFyZ2V0OiBJZ3hEcmFnTG9jYXRpb24gfCBFbGVtZW50UmVmLCBjdXN0b21BbmltQXJncz86IElEcmFnQ3VzdG9tVHJhbnNpdGlvbkFyZ3MsIHN0YXJ0TG9jYXRpb24/OiBJZ3hEcmFnTG9jYXRpb24pIHtcbiAgICAgICAgaWYgKCEhc3RhcnRMb2NhdGlvbiAmJiB0aGlzLmdob3N0ICYmICF0aGlzLmdob3N0RWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRYID0gc3RhcnRMb2NhdGlvbi5wYWdlWDtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0WSA9IHN0YXJ0TG9jYXRpb24ucGFnZVk7XG4gICAgICAgICAgICB0aGlzLl9naG9zdFN0YXJ0WCA9IHRoaXMuX3N0YXJ0WDtcbiAgICAgICAgICAgIHRoaXMuX2dob3N0U3RhcnRZID0gdGhpcy5fc3RhcnRZO1xuICAgICAgICB9IGVsc2UgaWYgKCEhc3RhcnRMb2NhdGlvbiAmJiAoIXRoaXMuZ2hvc3QgfHwgdGhpcy5naG9zdEVsZW1lbnQpKSB7XG4gICAgICAgICAgICB0aGlzLnNldExvY2F0aW9uKHN0YXJ0TG9jYXRpb24pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZ2hvc3QgJiYgIXRoaXMuZ2hvc3RFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9zdGFydFggPSB0aGlzLmJhc2VMZWZ0O1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRZID0gdGhpcy5iYXNlVG9wO1xuICAgICAgICAgICAgdGhpcy5fZ2hvc3RTdGFydFggPSB0aGlzLl9zdGFydFggKyB0aGlzLmdldFdpbmRvd1Njcm9sbExlZnQoKTtcbiAgICAgICAgICAgIHRoaXMuX2dob3N0U3RhcnRZID0gdGhpcy5fc3RhcnRZICsgdGhpcy5nZXRXaW5kb3dTY3JvbGxUb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmdob3N0ICYmICF0aGlzLmdob3N0RWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVHaG9zdCh0aGlzLl9zdGFydFgsIHRoaXMuX3N0YXJ0WSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFuaW1JblByb2dyZXNzID0gdHJ1ZTtcbiAgICAgICAgLy8gVXNlIHNldFRpbWVvdXQgYmVjYXVzZSB3ZSBuZWVkIHRvIGJlIHN1cmUgdGhhdCB0aGUgZWxlbWVudCBpcyBwb3NpdGlvbmVkIGZpcnN0IGNvcnJlY3RseSBpZiB0aGVyZSBpcyBzdGFydCBsb2NhdGlvbi5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtb3ZlZEVsZW0gPSB0aGlzLmdob3N0ID8gdGhpcy5naG9zdEVsZW1lbnQgOiB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgICAgIG1vdmVkRWxlbS5zdHlsZS50cmFuc2l0aW9uUHJvcGVydHkgPSB0aGlzLmdob3N0ICYmIHRoaXMuZ2hvc3RFbGVtZW50ID8gJ2xlZnQsIHRvcCcgOiAndHJhbnNmb3JtJztcbiAgICAgICAgICAgIG1vdmVkRWxlbS5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPVxuICAgICAgICAgICAgICAgIGN1c3RvbUFuaW1BcmdzICYmIGN1c3RvbUFuaW1BcmdzLmR1cmF0aW9uID8gY3VzdG9tQW5pbUFyZ3MuZHVyYXRpb24gKyAncycgOiB0aGlzLmRlZmF1bHRSZXR1cm5EdXJhdGlvbiA7XG4gICAgICAgICAgICBtb3ZlZEVsZW0uc3R5bGUudHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uID1cbiAgICAgICAgICAgICAgICBjdXN0b21BbmltQXJncyAmJiBjdXN0b21BbmltQXJncy50aW1pbmdGdW5jdGlvbiA/IGN1c3RvbUFuaW1BcmdzLnRpbWluZ0Z1bmN0aW9uIDogJyc7XG4gICAgICAgICAgICBtb3ZlZEVsZW0uc3R5bGUudHJhbnNpdGlvbkRlbGF5ID0gY3VzdG9tQW5pbUFyZ3MgJiYgY3VzdG9tQW5pbUFyZ3MuZGVsYXkgPyBjdXN0b21BbmltQXJncy5kZWxheSArICdzJyA6ICcnO1xuXG4gICAgICAgICAgICBpZiAodGFyZ2V0IGluc3RhbmNlb2YgSWd4RHJhZ0xvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRMb2NhdGlvbihuZXcgSWd4RHJhZ0xvY2F0aW9uICh0YXJnZXQucGFnZVgsIHRhcmdldC5wYWdlWSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXJnZXRSZWN0cyA9IHRhcmdldC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0TG9jYXRpb24obmV3IElneERyYWdMb2NhdGlvbihcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0UmVjdHMubGVmdCAtICB0aGlzLmdldFdpbmRvd1Njcm9sbExlZnQoKSxcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0UmVjdHMudG9wIC0gdGhpcy5nZXRXaW5kb3dTY3JvbGxUb3AoKVxuICAgICAgICAgICAgICAgICkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogTWV0aG9kIGJvdW5kIHRvIHRoZSBQb2ludGVyRG93biBldmVudCBvZiB0aGUgYmFzZSBlbGVtZW50IGlneERyYWcgaXMgaW5pdGlhbGl6ZWQuXG4gICAgICogQHBhcmFtIGV2ZW50IFBvaW50ZXJEb3duIGV2ZW50IGNhcHR1cmVkXG4gICAgICovXG4gICAgcHVibGljIG9uUG9pbnRlckRvd24oZXZlbnQpIHtcbiAgICAgICAgdGhpcy5fY2xpY2tlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3BvaW50ZXJEb3duSWQgPSBldmVudC5wb2ludGVySWQ7XG5cbiAgICAgICAgLy8gU2V0IHBvaW50ZXIgY2FwdHVyZSBzbyB3ZSBkZXRlY3QgcG9pbnRlcm1vdmUgZXZlbiBpZiBtb3VzZSBpcyBvdXQgb2YgYm91bmRzIHVudGlsIGdob3N0RWxlbWVudCBpcyBjcmVhdGVkLlxuICAgICAgICBjb25zdCBoYW5kbGVGb3VuZCA9IHRoaXMuZHJhZ0hhbmRsZXMuZmluZChoYW5kbGUgPT4gaGFuZGxlLmVsZW1lbnQubmF0aXZlRWxlbWVudCA9PT0gZXZlbnQuY3VycmVudFRhcmdldCk7XG4gICAgICAgIGNvbnN0IHRhcmdldEVsZW1lbnQgPSBoYW5kbGVGb3VuZCA/IGhhbmRsZUZvdW5kLmVsZW1lbnQubmF0aXZlRWxlbWVudCA6IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICBpZiAodGhpcy5wb2ludGVyRXZlbnRzRW5hYmxlZCkge1xuICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5zZXRQb2ludGVyQ2FwdHVyZSh0aGlzLl9wb2ludGVyRG93bklkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldEVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX2Jhc2VPcmlnaW5YICYmICF0aGlzLl9iYXNlT3JpZ2luWSkge1xuICAgICAgICAgICAgdGhpcy5fYmFzZU9yaWdpblggPSB0aGlzLmJhc2VMZWZ0O1xuICAgICAgICAgICAgdGhpcy5fYmFzZU9yaWdpblkgPSB0aGlzLmJhc2VUb3A7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5wb2ludGVyRXZlbnRzRW5hYmxlZCB8fCAhdGhpcy50b3VjaEV2ZW50c0VuYWJsZWQpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZpcnN0IGZvciBwb2ludGVyIGV2ZW50cyBvciBub24gdG91Y2gsIGJlY2F1c2Ugd2UgY2FuIGhhdmUgcG9pbnRlciBldmVudHMgYW5kIHRvdWNoIGV2ZW50cyBhdCBvbmNlLlxuICAgICAgICAgICAgdGhpcy5fc3RhcnRYID0gZXZlbnQucGFnZVg7XG4gICAgICAgICAgICB0aGlzLl9zdGFydFkgPSBldmVudC5wYWdlWTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnRvdWNoRXZlbnRzRW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5fc3RhcnRYID0gZXZlbnQudG91Y2hlc1swXS5wYWdlWDtcbiAgICAgICAgICAgIHRoaXMuX3N0YXJ0WSA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kZWZhdWx0T2Zmc2V0WCA9IHRoaXMuYmFzZUxlZnQgLSB0aGlzLl9zdGFydFggKyB0aGlzLmdldFdpbmRvd1Njcm9sbExlZnQoKTtcbiAgICAgICAgdGhpcy5fZGVmYXVsdE9mZnNldFkgPSB0aGlzLmJhc2VUb3AgLSB0aGlzLl9zdGFydFkgKyB0aGlzLmdldFdpbmRvd1Njcm9sbFRvcCgpO1xuICAgICAgICB0aGlzLl9naG9zdFN0YXJ0WCA9IHRoaXMuX3N0YXJ0WCArIHRoaXMuZ2hvc3RPZmZzZXRYO1xuICAgICAgICB0aGlzLl9naG9zdFN0YXJ0WSA9IHRoaXMuX3N0YXJ0WSArIHRoaXMuZ2hvc3RPZmZzZXRZO1xuICAgICAgICB0aGlzLl9sYXN0WCA9IHRoaXMuX3N0YXJ0WDtcbiAgICAgICAgdGhpcy5fbGFzdFkgPSB0aGlzLl9zdGFydFk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFBlcmZvcm0gZHJhZyBtb3ZlIGxvZ2ljIHdoZW4gZHJhZ2dpbmcgYW5kIGRpc3BhdGNoaW5nIGV2ZW50cyBpZiB0aGVyZSBpcyBpZ3hEcm9wIHVuZGVyIHRoZSBwb2ludGVyLlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGJvdW5kIGF0IGZpcnN0IGF0IHRoZSBiYXNlIGVsZW1lbnQuXG4gICAgICogSWYgZHJhZ2dpbmcgc3RhcnRzIGFuZCBhZnRlciB0aGUgZ2hvc3RFbGVtZW50IGlzIHJlbmRlcmVkIHRoZSBwb2ludGVySWQgaXMgcmVhc3NpZ25lZCBpdC4gVGhlbiB0aGlzIG1ldGhvZCBpcyBib3VuZCB0byBpdC5cbiAgICAgKiBAcGFyYW0gZXZlbnQgUG9pbnRlck1vdmUgZXZlbnQgY2FwdHVyZWRcbiAgICAgKi9cbiAgICBwdWJsaWMgb25Qb2ludGVyTW92ZShldmVudCkge1xuICAgICAgICBpZiAodGhpcy5fY2xpY2tlZCkge1xuICAgICAgICAgICAgbGV0IHBhZ2VYLCBwYWdlWTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvaW50ZXJFdmVudHNFbmFibGVkIHx8ICF0aGlzLnRvdWNoRXZlbnRzRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGZpcnN0IGZvciBwb2ludGVyIGV2ZW50cyBvciBub24gdG91Y2gsIGJlY2F1c2Ugd2UgY2FuIGhhdmUgcG9pbnRlciBldmVudHMgYW5kIHRvdWNoIGV2ZW50cyBhdCBvbmNlLlxuICAgICAgICAgICAgICAgIHBhZ2VYID0gZXZlbnQucGFnZVg7XG4gICAgICAgICAgICAgICAgcGFnZVkgPSBldmVudC5wYWdlWTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy50b3VjaEV2ZW50c0VuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBwYWdlWCA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVg7XG4gICAgICAgICAgICAgICAgcGFnZVkgPSBldmVudC50b3VjaGVzWzBdLnBhZ2VZO1xuXG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCBzY3JvbGxpbmcgb24gdG91Y2ggd2hpbGUgZHJhZ2dpbmdcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCB0b3RhbE1vdmVkWCA9IHBhZ2VYIC0gdGhpcy5fc3RhcnRYO1xuICAgICAgICAgICAgY29uc3QgdG90YWxNb3ZlZFkgPSBwYWdlWSAtIHRoaXMuX3N0YXJ0WTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fZHJhZ1N0YXJ0ZWQgJiZcbiAgICAgICAgICAgICAgICAoTWF0aC5hYnModG90YWxNb3ZlZFgpID4gdGhpcy5kcmFnVG9sZXJhbmNlIHx8IE1hdGguYWJzKHRvdGFsTW92ZWRZKSA+IHRoaXMuZHJhZ1RvbGVyYW5jZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkcmFnU3RhcnRBcmdzOiBJRHJhZ1N0YXJ0RXZlbnRBcmdzID0ge1xuICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldmVudCxcbiAgICAgICAgICAgICAgICAgICAgb3duZXI6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0WDogcGFnZVggLSB0b3RhbE1vdmVkWCxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRZOiBwYWdlWSAtIHRvdGFsTW92ZWRZLFxuICAgICAgICAgICAgICAgICAgICBwYWdlWDogcGFnZVgsXG4gICAgICAgICAgICAgICAgICAgIHBhZ2VZOiBwYWdlWSxcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsOiBmYWxzZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZHJhZ1N0YXJ0LmVtaXQoZHJhZ1N0YXJ0QXJncyk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWRyYWdTdGFydEFyZ3MuY2FuY2VsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RyYWdTdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2hvc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG1vdmVkIGVub3VnaCBzbyBnaG9zdEVsZW1lbnQgY2FuIGJlIHJlbmRlcmVkIGFuZCBhY3R1YWwgZHJhZ2dpbmcgdG8gc3RhcnQuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGNyZWF0aW5nIGl0IHdpbGwgdGFrZSBpbnRvIGFjY291bnQgYW55IG9mZnNldCBzZXQgYnkgdGhlIHVzZXIgYnkgZGVmYXVsdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlR2hvc3QocGFnZVgsIHBhZ2VZKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9vZmZzZXRYICE9PSB1bmRlZmluZWQgfHwgdGhpcy5fb2Zmc2V0WSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBuZWVkIGZvciBnaG9zdCwgYnV0IHdlIHdpbGwgbmVlZCB0byBwb3NpdGlvbiBpbml0aWFsbHkgdGhlIGJhc2UgZWxlbWVudCB0byByZWZsZWN0IGFueSBvZmZzZXQuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1YID0gKHRoaXMuX29mZnNldFggIT09IHVuZGVmaW5lZCA/IHRoaXMuX29mZnNldFggLSB0aGlzLl9kZWZhdWx0T2Zmc2V0WCA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldFRyYW5zZm9ybVgodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtWSA9ICh0aGlzLl9vZmZzZXRZICE9PSB1bmRlZmluZWQgPyB0aGlzLl9vZmZzZXRZIC0gdGhpcy5fZGVmYXVsdE9mZnNldFkgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRUcmFuc2Zvcm1ZKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0VHJhbnNmb3JtWFkodHJhbnNmb3JtWCwgdHJhbnNmb3JtWSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fZHJhZ1N0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IG1vdmVBcmdzOiBJRHJhZ01vdmVFdmVudEFyZ3MgPSB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQsXG4gICAgICAgICAgICAgICAgb3duZXI6IHRoaXMsXG4gICAgICAgICAgICAgICAgc3RhcnRYOiB0aGlzLl9zdGFydFgsXG4gICAgICAgICAgICAgICAgc3RhcnRZOiB0aGlzLl9zdGFydFksXG4gICAgICAgICAgICAgICAgcGFnZVg6IHRoaXMuX2xhc3RYLFxuICAgICAgICAgICAgICAgIHBhZ2VZOiB0aGlzLl9sYXN0WSxcbiAgICAgICAgICAgICAgICBuZXh0UGFnZVg6IHBhZ2VYLFxuICAgICAgICAgICAgICAgIG5leHRQYWdlWTogcGFnZVksXG4gICAgICAgICAgICAgICAgY2FuY2VsOiBmYWxzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ01vdmUuZW1pdChtb3ZlQXJncyk7XG5cbiAgICAgICAgICAgIGNvbnN0IHNldFBhZ2VYID0gbW92ZUFyZ3MubmV4dFBhZ2VYO1xuICAgICAgICAgICAgY29uc3Qgc2V0UGFnZVkgPSBtb3ZlQXJncy5uZXh0UGFnZVk7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkTW92ZWRYID0gc2V0UGFnZVggLSB0aGlzLl9zdGFydFg7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkTW92ZWRZID0gc2V0UGFnZVkgLSB0aGlzLl9zdGFydFk7XG5cbiAgICAgICAgICAgIGlmICghbW92ZUFyZ3MuY2FuY2VsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2hvc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5naG9zdExlZnQgPSB0aGlzLl9naG9zdFN0YXJ0WCArIHVwZGF0ZWRNb3ZlZFg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2hvc3RUb3AgPSB0aGlzLl9naG9zdFN0YXJ0WSArIHVwZGF0ZWRNb3ZlZFk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdE1vdmVkWCA9IHNldFBhZ2VYIC0gdGhpcy5fbGFzdFg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RNb3ZlZFkgPSBzZXRQYWdlWSAtIHRoaXMuX2xhc3RZO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2xhdGVYID0gdGhpcy5nZXRUcmFuc2Zvcm1YKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KSArIGxhc3RNb3ZlZFg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zbGF0ZVkgPSB0aGlzLmdldFRyYW5zZm9ybVkodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpICsgbGFzdE1vdmVkWTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm1YWSh0cmFuc2xhdGVYLCB0cmFuc2xhdGVZKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaERyYWdFdmVudHMocGFnZVgsIHBhZ2VZLCBldmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2xhc3RYID0gc2V0UGFnZVg7XG4gICAgICAgICAgICB0aGlzLl9sYXN0WSA9IHNldFBhZ2VZO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFBlcmZvcm0gZHJhZyBlbmQgbG9naWMgd2hlbiByZWxlYXNpbmcgdGhlIGdob3N0RWxlbWVudCBhbmQgZGlzcGF0Y2hpbmcgZHJvcCBldmVudCBpZiBpZ3hEcm9wIGlzIHVuZGVyIHRoZSBwb2ludGVyLlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGJvdW5kIGF0IGZpcnN0IGF0IHRoZSBiYXNlIGVsZW1lbnQuXG4gICAgICogSWYgZHJhZ2dpbmcgc3RhcnRzIGFuZCBhZnRlciB0aGUgZ2hvc3RFbGVtZW50IGlzIHJlbmRlcmVkIHRoZSBwb2ludGVySWQgaXMgcmVhc3NpZ25lZCB0byBpdC4gVGhlbiB0aGlzIG1ldGhvZCBpcyBib3VuZCB0byBpdC5cbiAgICAgKiBAcGFyYW0gZXZlbnQgUG9pbnRlclVwIGV2ZW50IGNhcHR1cmVkXG4gICAgICovXG4gICAgcHVibGljIG9uUG9pbnRlclVwKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5fY2xpY2tlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHBhZ2VYLCBwYWdlWTtcbiAgICAgICAgaWYgKHRoaXMucG9pbnRlckV2ZW50c0VuYWJsZWQgfHwgIXRoaXMudG91Y2hFdmVudHNFbmFibGVkKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBmaXJzdCBmb3IgcG9pbnRlciBldmVudHMgb3Igbm9uIHRvdWNoLCBiZWNhdXNlIHdlIGNhbiBoYXZlIHBvaW50ZXIgZXZlbnRzIGFuZCB0b3VjaCBldmVudHMgYXQgb25jZS5cbiAgICAgICAgICAgIHBhZ2VYID0gZXZlbnQucGFnZVg7XG4gICAgICAgICAgICBwYWdlWSA9IGV2ZW50LnBhZ2VZO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudG91Y2hFdmVudHNFbmFibGVkKSB7XG4gICAgICAgICAgICBwYWdlWCA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVg7XG4gICAgICAgICAgICBwYWdlWSA9IGV2ZW50LnRvdWNoZXNbMF0ucGFnZVk7XG5cbiAgICAgICAgICAgIC8vIFByZXZlbnQgc2Nyb2xsaW5nIG9uIHRvdWNoIHdoaWxlIGRyYWdnaW5nXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZXZlbnRBcmdzOiBJRHJhZ0Jhc2VFdmVudEFyZ3MgPSB7XG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldmVudCxcbiAgICAgICAgICAgIG93bmVyOiB0aGlzLFxuICAgICAgICAgICAgc3RhcnRYOiB0aGlzLl9zdGFydFgsXG4gICAgICAgICAgICBzdGFydFk6IHRoaXMuX3N0YXJ0WSxcbiAgICAgICAgICAgIHBhZ2VYOiBwYWdlWCxcbiAgICAgICAgICAgIHBhZ2VZOiBwYWdlWVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wb2ludGVyRG93bklkID0gbnVsbDtcbiAgICAgICAgdGhpcy5fY2xpY2tlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5fZHJhZ1N0YXJ0ZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9sYXN0RHJvcEFyZWEgJiYgdGhpcy5fbGFzdERyb3BBcmVhICE9PSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRHJvcEV2ZW50KGV2ZW50LnBhZ2VYLCBldmVudC5wYWdlWSwgZXZlbnQpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmFuaW1hdGVPblJlbGVhc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25Ub09yaWdpbigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRyYWdFbmQuZW1pdChldmVudEFyZ3MpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5hbmltSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICAgIHRoaXMub25UcmFuc2l0aW9uRW5kKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVHJpZ2dlciBvdXIgb3duIGNsaWNrIGV2ZW50IGJlY2F1c2Ugd2hlbiB0aGVyZSBpcyBubyBnaG9zdCwgbmF0aXZlIGNsaWNrIGNhbm5vdCBiZSBwcmV2ZW50ZWQgd2hlbiBkcmFnZ2luZy5cbiAgICAgICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ0NsaWNrLmVtaXQoZXZlbnRBcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEV4ZWN1dGUgdGhpcyBtZXRob2Qgd2hlIHRoZSBwb2ludGVyIGNhcHR1cmUgaGFzIGJlZW4gbG9zdC5cbiAgICAgKiBUaGlzIG1lYW5zIHRoYXQgZHVyaW5nIGRyYWdnaW5nIHRoZSB1c2VyIGhhcyBwZXJmb3JtZWQgb3RoZXIgYWN0aW9uIGxpa2UgcmlnaHQgY2xpY2tpbmcgYW5kIHRoZW4gY2xpY2tpbmcgc29tZXdoZXJlIGVsc2UuXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBlbnN1cmUgdGhhdCB0aGUgZHJhZyBzdGF0ZSBpcyBiZWluZyByZXNldCBpbiB0aGlzIGNhc2UgYXMgaWYgdGhlIHVzZXIgcmVsZWFzZWQgdGhlIGRyYWdnZWQgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0gZXZlbnQgRXZlbnQgY2FwdHVyZWRcbiAgICAgKi9cbiAgICBwdWJsaWMgb25Qb2ludGVyTG9zdChldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuX2NsaWNrZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGV2ZW50QXJncyA9IHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50LFxuICAgICAgICAgICAgb3duZXI6IHRoaXMsXG4gICAgICAgICAgICBzdGFydFg6IHRoaXMuX3N0YXJ0WCxcbiAgICAgICAgICAgIHN0YXJ0WTogdGhpcy5fc3RhcnRZLFxuICAgICAgICAgICAgcGFnZVg6IGV2ZW50LnBhZ2VYLFxuICAgICAgICAgICAgcGFnZVk6IGV2ZW50LnBhZ2VZXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3BvaW50ZXJEb3duSWQgPSBudWxsO1xuICAgICAgICB0aGlzLl9jbGlja2VkID0gZmFsc2U7XG4gICAgICAgIGlmICh0aGlzLl9kcmFnU3RhcnRlZCkge1xuICAgICAgICAgICAgdGhpcy56b25lLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5kcmFnRW5kLmVtaXQoZXZlbnRBcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuYW5pbWF0ZU9uUmVsZWFzZSkge1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvT3JpZ2luKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLmFuaW1JblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vblRyYW5zaXRpb25FbmQobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQ3JlYXRlIGdob3N0IGVsZW1lbnQgLSBpZiBhIE5vZGUgb2JqZWN0IGlzIHByb3ZpZGVkIGl0IGNyZWF0ZXMgYSBjbG9uZSBvZiB0aGF0IG5vZGUsXG4gICAgICogb3RoZXJ3aXNlIGl0IGNsb25lcyB0aGUgaG9zdCBlbGVtZW50LlxuICAgICAqIEJpbmQgYWxsIG5lZWRlZCBldmVudHMuXG4gICAgICogQHBhcmFtIHBhZ2VYIExhdGVzdCBwb2ludGVyIHBvc2l0aW9uIG9uIHRoZSBYIGF4aXMgcmVsYXRpdmUgdG8gdGhlIHBhZ2UuXG4gICAgICogQHBhcmFtIHBhZ2VZIExhdGVzdCBwb2ludGVyIHBvc2l0aW9uIG9uIHRoZSBZIGF4aXMgcmVsYXRpdmUgdG8gdGhlIHBhZ2UuXG4gICAgICogQHBhcmFtIG5vZGUgVGhlIE5vZGUgb2JqZWN0IHRvIGJlIGNsb25lZC5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgY3JlYXRlR2hvc3QocGFnZVgsIHBhZ2VZLCBub2RlOiBhbnkgPSBudWxsKSB7XG4gICAgICAgIGlmICghdGhpcy5naG9zdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGR5bmFtaWNHaG9zdFJlZjtcbiAgICAgICAgaWYgKHRoaXMuZ2hvc3RUZW1wbGF0ZSkge1xuICAgICAgICAgICAgZHluYW1pY0dob3N0UmVmID0gdGhpcy52aWV3Q29udGFpbmVyLmNyZWF0ZUVtYmVkZGVkVmlldyh0aGlzLmdob3N0VGVtcGxhdGUsIHRoaXMuZ2hvc3RDb250ZXh0KTtcbiAgICAgICAgICAgIHRoaXMuZ2hvc3RFbGVtZW50ID0gZHluYW1pY0dob3N0UmVmLnJvb3ROb2Rlc1swXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZ2hvc3RFbGVtZW50ID0gbm9kZSA/IG5vZGUuY2xvbmVOb2RlKHRydWUpIDogdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdG90YWxNb3ZlZFggPSBwYWdlWCAtIHRoaXMuX3N0YXJ0WDtcbiAgICAgICAgY29uc3QgdG90YWxNb3ZlZFkgPSBwYWdlWSAtIHRoaXMuX3N0YXJ0WTtcbiAgICAgICAgdGhpcy5fZ2hvc3RIb3N0WCA9IHRoaXMuZ2hvc3RIb3N0ID8gdGhpcy5naG9zdEhvc3RPZmZzZXRMZWZ0KHRoaXMuZ2hvc3RIb3N0KSA6IDA7XG4gICAgICAgIHRoaXMuX2dob3N0SG9zdFkgPSB0aGlzLmdob3N0SG9zdCA/IHRoaXMuZ2hvc3RIb3N0T2Zmc2V0VG9wKHRoaXMuZ2hvc3RIb3N0KSA6IDA7XG5cbiAgICAgICAgdGhpcy5naG9zdEVsZW1lbnQuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gJzAuMHMnO1xuICAgICAgICB0aGlzLmdob3N0RWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG5cblxuICAgICAgICBpZiAodGhpcy5naG9zdENsYXNzKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLmFkZENsYXNzKHRoaXMuZ2hvc3RFbGVtZW50LCB0aGlzLmdob3N0Q2xhc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY3JlYXRlRXZlbnRBcmdzID0ge1xuICAgICAgICAgICAgb3duZXI6IHRoaXMsXG4gICAgICAgICAgICBnaG9zdEVsZW1lbnQ6IHRoaXMuZ2hvc3RFbGVtZW50LFxuICAgICAgICAgICAgY2FuY2VsOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmdob3N0Q3JlYXRlLmVtaXQoY3JlYXRlRXZlbnRBcmdzKTtcbiAgICAgICAgaWYgKGNyZWF0ZUV2ZW50QXJncy5jYW5jZWwpIHtcbiAgICAgICAgICAgIHRoaXMuZ2hvc3RFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh0aGlzLmdob3N0VGVtcGxhdGUgJiYgZHluYW1pY0dob3N0UmVmKSB7XG4gICAgICAgICAgICAgICAgZHluYW1pY0dob3N0UmVmLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmdob3N0SG9zdCkge1xuICAgICAgICAgICAgdGhpcy5naG9zdEhvc3QuYXBwZW5kQ2hpbGQodGhpcy5naG9zdEVsZW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLmdob3N0RWxlbWVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBnaG9zdE1hcmdpbkxlZnQgPSBwYXJzZUludChkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuZ2hvc3RFbGVtZW50KVsnbWFyZ2luLWxlZnQnXSwgMTApO1xuICAgICAgICBjb25zdCBnaG9zdE1hcmdpblRvcCA9IHBhcnNlSW50KGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUodGhpcy5naG9zdEVsZW1lbnQpWydtYXJnaW4tdG9wJ10sIDEwKTtcbiAgICAgICAgdGhpcy5naG9zdEVsZW1lbnQuc3R5bGUubGVmdCA9ICh0aGlzLl9naG9zdFN0YXJ0WCAtIGdob3N0TWFyZ2luTGVmdCArIHRvdGFsTW92ZWRYIC0gdGhpcy5fZ2hvc3RIb3N0WCkgKyAncHgnO1xuICAgICAgICB0aGlzLmdob3N0RWxlbWVudC5zdHlsZS50b3AgPSAodGhpcy5fZ2hvc3RTdGFydFkgLSBnaG9zdE1hcmdpblRvcCArIHRvdGFsTW92ZWRZIC0gdGhpcy5fZ2hvc3RIb3N0WCkgKyAncHgnO1xuXG4gICAgICAgIGlmICh0aGlzLnBvaW50ZXJFdmVudHNFbmFibGVkKSB7XG4gICAgICAgICAgICAvLyBUaGUgZ2hvc3RFbGVtZW50IHRha2VzIGNvbnRyb2wgZm9yIG1vdmluZyBhbmQgZHJhZ2dpbmcgYWZ0ZXIgaXQgaGFzIGJlZW4gcmVuZGVyZWQuXG4gICAgICAgICAgICBpZiAodGhpcy5fcG9pbnRlckRvd25JZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2hvc3RFbGVtZW50LnNldFBvaW50ZXJDYXB0dXJlKHRoaXMuX3BvaW50ZXJEb3duSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5naG9zdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcm1vdmUnLCAoYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub25Qb2ludGVyTW92ZShhcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5naG9zdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncG9pbnRlcnVwJywgKGFyZ3MpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uUG9pbnRlclVwKGFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmdob3N0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdsb3N0cG9pbnRlcmNhcHR1cmUnLCAoYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub25Qb2ludGVyTG9zdChhcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVHJhbnNpdGlvbiBhbmltYXRpb24gd2hlbiB0aGUgZ2hvc3RFbGVtZW50IGlzIHJlbGVhc2VkIGFuZCBpdCByZXR1cm5zIHRvIGl0J3Mgb3JpZ2luYWwgcG9zaXRpb24uXG4gICAgICAgIHRoaXMuZ2hvc3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCAoYXJncykgPT4ge1xuICAgICAgICAgICAgdGhpcy5vblRyYW5zaXRpb25FbmQoYXJncyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEhpZGUgdGhlIGJhc2UgYWZ0ZXIgdGhlIGdob3N0RWxlbWVudCBpcyBjcmVhdGVkLCBiZWNhdXNlIG90aGVyd2lzZSB0aGUgZ2hvc3RFbGVtZW50IHdpbGwgYmUgbm90IHZpc2libGUuXG4gICAgICAgIGlmICh0aGlzLmhpZGVCYXNlT25EcmFnKSB7XG4gICAgICAgICAgICB0aGlzLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuY2RyLmRldGVjdENoYW5nZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogRGlzcGF0Y2ggY3VzdG9tIGlneERyYWdFbnRlci9pZ3hEcmFnTGVhdmUgZXZlbnRzIGJhc2VkIG9uIGN1cnJlbnQgcG9pbnRlciBwb3NpdGlvbiBhbmQgaWYgZHJvcCBhcmVhIGlzIHVuZGVyLlxuICAgICAqL1xuICAgIHByb3RlY3RlZCBkaXNwYXRjaERyYWdFdmVudHMocGFnZVg6IG51bWJlciwgcGFnZVk6IG51bWJlciwgb3JpZ2luYWxFdmVudCkge1xuICAgICAgICBsZXQgdG9wRHJvcEFyZWE7XG4gICAgICAgIGNvbnN0IGN1c3RvbUV2ZW50QXJnczogSWd4RHJhZ0N1c3RvbUV2ZW50RGV0YWlscyA9IHtcbiAgICAgICAgICAgIHN0YXJ0WDogdGhpcy5fc3RhcnRYLFxuICAgICAgICAgICAgc3RhcnRZOiB0aGlzLl9zdGFydFksXG4gICAgICAgICAgICBwYWdlWDogcGFnZVgsXG4gICAgICAgICAgICBwYWdlWTogcGFnZVksXG4gICAgICAgICAgICBvd25lcjogdGhpcyxcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IG9yaWdpbmFsRXZlbnRcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBlbGVtZW50c0Zyb21Qb2ludCA9IHRoaXMuZ2V0RWxlbWVudHNBdFBvaW50KHBhZ2VYLCBwYWdlWSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHNGcm9tUG9pbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50c0Zyb21Qb2ludFtpXS5nZXRBdHRyaWJ1dGUoJ2Ryb3BwYWJsZScpID09PSAndHJ1ZScgJiZcbiAgICAgICAgICAgICAgICBlbGVtZW50c0Zyb21Qb2ludFtpXSAhPT0gdGhpcy5naG9zdEVsZW1lbnQgJiYgZWxlbWVudHNGcm9tUG9pbnRbaV0gIT09IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdG9wRHJvcEFyZWEgPSBlbGVtZW50c0Zyb21Qb2ludFtpXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0b3BEcm9wQXJlYSAmJlxuICAgICAgICAgICAgKCF0aGlzLl9sYXN0RHJvcEFyZWEgfHwgKHRoaXMuX2xhc3REcm9wQXJlYSAmJiB0aGlzLl9sYXN0RHJvcEFyZWEgIT09IHRvcERyb3BBcmVhKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbGFzdERyb3BBcmVhKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh0aGlzLl9sYXN0RHJvcEFyZWEsICdpZ3hEcmFnTGVhdmUnLCBjdXN0b21FdmVudEFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3REcm9wQXJlYSA9IHRvcERyb3BBcmVhO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh0aGlzLl9sYXN0RHJvcEFyZWEsICdpZ3hEcmFnRW50ZXInLCBjdXN0b21FdmVudEFyZ3MpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghdG9wRHJvcEFyZWEgJiYgdGhpcy5fbGFzdERyb3BBcmVhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHRoaXMuX2xhc3REcm9wQXJlYSwgJ2lneERyYWdMZWF2ZScsIGN1c3RvbUV2ZW50QXJncyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdERyb3BBcmVhID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRvcERyb3BBcmVhKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQodG9wRHJvcEFyZWEsICdpZ3hEcmFnT3ZlcicsIGN1c3RvbUV2ZW50QXJncyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogRGlzcGF0Y2ggY3VzdG9tIGlneERyb3AgZXZlbnQgYmFzZWQgb24gY3VycmVudCBwb2ludGVyIHBvc2l0aW9uIGlmIHRoZXJlIGlzIGxhc3QgcmVjb3JkZXIgZHJvcCBhcmVhIHVuZGVyIHRoZSBwb2ludGVyLlxuICAgICAqIExhc3QgcmVjb3JkZXIgZHJvcCBhcmVhIGlzIHVwZGF0ZWQgaW4gQGRpc3BhdGNoRHJhZ0V2ZW50cyBtZXRob2QuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGRpc3BhdGNoRHJvcEV2ZW50KHBhZ2VYOiBudW1iZXIsIHBhZ2VZOiBudW1iZXIsIG9yaWdpbmFsRXZlbnQpIHtcbiAgICAgICAgY29uc3QgZXZlbnRBcmdzOiBJZ3hEcmFnQ3VzdG9tRXZlbnREZXRhaWxzID0ge1xuICAgICAgICAgICAgc3RhcnRYOiB0aGlzLl9zdGFydFgsXG4gICAgICAgICAgICBzdGFydFk6IHRoaXMuX3N0YXJ0WSxcbiAgICAgICAgICAgIHBhZ2VYOiBwYWdlWCxcbiAgICAgICAgICAgIHBhZ2VZOiBwYWdlWSxcbiAgICAgICAgICAgIG93bmVyOiB0aGlzLFxuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogb3JpZ2luYWxFdmVudFxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudCh0aGlzLl9sYXN0RHJvcEFyZWEsICdpZ3hEcm9wJywgZXZlbnRBcmdzKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KHRoaXMuX2xhc3REcm9wQXJlYSwgJ2lneERyYWdMZWF2ZScsIGV2ZW50QXJncyk7XG4gICAgICAgIHRoaXMuX2xhc3REcm9wQXJlYSA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIFVwZGF0ZSByZWxhdGl2ZSBwb3NpdGlvbnNcbiAgICAgKi9cbiAgICBwdWJsaWMgdXBkYXRlRHJhZ1JlbGF0aXZlUG9zKCkge1xuICAgICAgICBsZXQgbmV3UG9zWCwgbmV3UG9zWTtcbiAgICAgICAgaWYgKHRoaXMuZ2hvc3QgJiYgdGhpcy5naG9zdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbmV3IGdob3N0RWxlbWVudCBwb3NpdGlvbiB0byByZW1haW4gd2hlcmUgdGhlIG1vdXNlIGlzLCBzbyBpdCBkb2Vzbid0IGp1bXBcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsRHJhZ2dlZFggPSB0aGlzLmdob3N0TGVmdCAtIHRoaXMuX2dob3N0U3RhcnRYO1xuICAgICAgICAgICAgY29uc3QgdG90YWxEcmFnZ2VkWSA9IHRoaXMuZ2hvc3RUb3AgLSB0aGlzLl9naG9zdFN0YXJ0WTtcbiAgICAgICAgICAgIG5ld1Bvc1ggPSB0aGlzLmJhc2VMZWZ0O1xuICAgICAgICAgICAgbmV3UG9zWSA9IHRoaXMuYmFzZVRvcDtcbiAgICAgICAgICAgIGNvbnN0IGRpZmZTdGFydFggPSB0aGlzLl9naG9zdFN0YXJ0WCAtIG5ld1Bvc1g7XG4gICAgICAgICAgICBjb25zdCBkaWZmU3RhcnRZID0gdGhpcy5fZ2hvc3RTdGFydFkgLSBuZXdQb3NZO1xuICAgICAgICAgICAgdGhpcy5naG9zdFRvcCA9IG5ld1Bvc1ggKyB0b3RhbERyYWdnZWRYIC0gZGlmZlN0YXJ0WDtcbiAgICAgICAgICAgIHRoaXMuZ2hvc3RMZWZ0ID0gbmV3UG9zWSArIHRvdGFsRHJhZ2dlZFkgLSBkaWZmU3RhcnRZO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLmdob3N0KSB7XG4gICAgICAgICAgICBjb25zdCB0b3RhbERyYWdnZWRYID0gdGhpcy5nZXRUcmFuc2Zvcm1YKHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgICAgIGNvbnN0IHRvdGFsRHJhZ2dlZFkgPSB0aGlzLmdldFRyYW5zZm9ybVkodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgbmV3UG9zWCA9IHRoaXMuYmFzZUxlZnQgLSB0b3RhbERyYWdnZWRYO1xuICAgICAgICAgICAgbmV3UG9zWSA9IHRoaXMuYmFzZVRvcCAtIHRvdGFsRHJhZ2dlZFk7XG4gICAgICAgICAgICBjb25zdCBkZWx0YVggPSB0aGlzLl9iYXNlT3JpZ2luWCAtIG5ld1Bvc1g7XG4gICAgICAgICAgICBjb25zdCBkZWx0YVkgPSB0aGlzLl9iYXNlT3JpZ2luWSAtIG5ld1Bvc1k7XG4gICAgICAgICAgICB0aGlzLnNldFRyYW5zZm9ybVhZKHRvdGFsRHJhZ2dlZFggKyBkZWx0YVgsIHRvdGFsRHJhZ2dlZFkgKyBkZWx0YVkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2Jhc2VPcmlnaW5YID0gbmV3UG9zWCAhPT0gdW5kZWZpbmVkID8gbmV3UG9zWCA6IHRoaXMuX2Jhc2VPcmlnaW5YO1xuICAgICAgICB0aGlzLl9iYXNlT3JpZ2luWSA9IG5ld1Bvc1kgIT09IHVuZGVmaW5lZCA/IG5ld1Bvc1kgOiB0aGlzLl9iYXNlT3JpZ2luWTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIG1ldGhvZCB3aWxsIGJlIHJlbW92ZWQgaW4gZnV0dXJlIG1ham9yIHZlcnNpb24uIFBsZWFzZSB1c2UgYHRyYW5zaXRpb25Ub09yaWdpbmAgb3IgYHRyYW5zaXRpb25Ub2AuXG4gICAgICogSW5mb3JtcyB0aGUgYGlneERyYWdgIGRpcmVjdGl2ZSB0aGF0IGl0IGhhcyBiZWVuIGRyb3BwZWQvcmVsZWFzZWQuXG4gICAgICogVGhpcyBzaG91bGQgdXN1YWxseSBiZSBjYWxsZWQgd2hlbiBgYW5pbWF0ZU9uUmVsZWFzZWAgaXMgc2V0IHRvIGB0cnVlYC5cbiAgICAgKiBXaGVuIGNhbmNlbGluZyBvciBkZWZpbmluZyBjdXN0b20gZHJvcCBsb2dpYyB0aGlzIHRlbGxzIHRoZSBpZ3hEcmFnIHRvIHVwZGF0ZSBpdCdzIHBvc2l0aW9ucyBhbmRcbiAgICAgKiBhbmltYXRlIGNvcnJlY3RseSB0byB0aGUgbmV3IHBvc2l0aW9uLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgb25Ecm9wRWxlbShldmVudCkge1xuICAgICAqICAgICAvLyBGdW5jdGlvbiBib3VuZCB0byB0aGUgaWd4RHJvcCBkaXJlY3RpdmUgZXZlbnQgYG9uRHJvcGBcbiAgICAgKiAgICAgLy8gVGhpcyBjYW5jZWxzIHRoZSBkZWZhdWx0IGRyb3AgbG9naWMgb2YgdGhlIGBpZ3hEcm9wYFxuICAgICAqICAgICBldmVudC5jYW5jZWwgPSB0cnVlO1xuICAgICAqICAgICBldmVudC5kcmFnLmRyb3BGaW5pc2hlZCgpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAqL1xuICAgIHB1YmxpYyBkcm9wRmluaXNoZWQoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlRHJhZ1JlbGF0aXZlUG9zKCk7XG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGVPblJlbGVhc2UgJiYgdGhpcy5naG9zdEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNpdGlvblRvT3JpZ2luKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG9uVHJhbnNpdGlvbkVuZChldmVudCkge1xuICAgICAgICBpZiAoKCF0aGlzLl9kcmFnU3RhcnRlZCAmJiAhdGhpcy5hbmltSW5Qcm9ncmVzcykgfHwgdGhpcy5fY2xpY2tlZCkge1xuICAgICAgICAgICAgLy8gUmV0dXJuIGlmIG5vIGRyYWdnaW5nIHN0YXJ0ZWQgYW5kIHRoZXJlIGlzIG5vIGFuaW1hdGlvbiBpbiBwcm9ncmVzcy5cbiAgICAgICAgICAgIHJldHVybiA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5naG9zdCAmJiB0aGlzLmdob3N0RWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5fZ2hvc3RTdGFydFggPSB0aGlzLmJhc2VMZWZ0ICsgdGhpcy5nZXRXaW5kb3dTY3JvbGxMZWZ0KCk7XG4gICAgICAgICAgICB0aGlzLl9naG9zdFN0YXJ0WSA9IHRoaXMuYmFzZVRvcCArIHRoaXMuZ2V0V2luZG93U2Nyb2xsVG9wKCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGdob3N0RGVzdHJveUFyZ3M6IElEcmFnR2hvc3RCYXNlRXZlbnRBcmdzID0ge1xuICAgICAgICAgICAgICAgIG93bmVyOiB0aGlzLFxuICAgICAgICAgICAgICAgIGdob3N0RWxlbWVudDogdGhpcy5naG9zdEVsZW1lbnQsXG4gICAgICAgICAgICAgICAgY2FuY2VsOiBmYWxzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuZ2hvc3REZXN0cm95LmVtaXQoZ2hvc3REZXN0cm95QXJncyk7XG4gICAgICAgICAgICBpZiAoZ2hvc3REZXN0cm95QXJncy5jYW5jZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmhpZGVCYXNlT25EcmFnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZ2hvc3RFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5naG9zdEVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5naG9zdEVsZW1lbnQgPSBudWxsO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLmdob3N0KSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5zdHlsZS50cmFuc2l0aW9uUHJvcGVydHkgPSAnJztcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwLjBzJztcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LnN0eWxlLnRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbiA9ICcnO1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUudHJhbnNpdGlvbkRlbGF5ID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbmltSW5Qcm9ncmVzcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9kcmFnU3RhcnRlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEV4ZWN1dGUgdHJhbnNpdGlvbmVkIGFmdGVyIGV2ZXJ5dGhpbmcgaXMgcmVzZXQgc28gaWYgdGhlIHVzZXIgc2V0cyBuZXcgbG9jYXRpb24gb24gdGhlIGJhc2Ugbm93IGl0IHdvdWxkIHdvcmsgYXMgZXhwZWN0ZWQuXG4gICAgICAgIHRoaXMuem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50cmFuc2l0aW9uZWQuZW1pdCh7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQsXG4gICAgICAgICAgICAgICAgb3duZXI6IHRoaXMsXG4gICAgICAgICAgICAgICAgc3RhcnRYOiB0aGlzLl9zdGFydFgsXG4gICAgICAgICAgICAgICAgc3RhcnRZOiB0aGlzLl9zdGFydFksXG4gICAgICAgICAgICAgICAgcGFnZVg6IHRoaXMuX3N0YXJ0WCxcbiAgICAgICAgICAgICAgICBwYWdlWTogdGhpcy5fc3RhcnRZXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBnZXRFbGVtZW50c0F0UG9pbnQocGFnZVg6IG51bWJlciwgcGFnZVk6IG51bWJlcikge1xuICAgICAgICAvLyBjb3JyZWN0IHRoZSBjb29yZGluYXRlcyB3aXRoIHRoZSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbiwgYmVjYXVzZVxuICAgICAgICAvLyBkb2N1bWVudC5lbGVtZW50c0Zyb21Qb2ludCBjb25zaWRlciBwb3NpdGlvbiB3aXRoaW4gdGhlIGN1cnJlbnQgdmlld3BvcnRcbiAgICAgICAgLy8gd2luZG93LnBhZ2VYT2Zmc2V0ID09IHdpbmRvdy5zY3JvbGxYOyAvLyBhbHdheXMgdHJ1ZVxuICAgICAgICAvLyB1c2luZyB3aW5kb3cucGFnZVhPZmZzZXQgZm9yIElFOSBjb21wYXRpYmlsaXR5XG4gICAgICAgIGNvbnN0IHZpZXdQb3J0WCA9IHBhZ2VYIC0gd2luZG93LnBhZ2VYT2Zmc2V0O1xuICAgICAgICBjb25zdCB2aWV3UG9ydFkgPSBwYWdlWSAtIHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICAgICAgaWYgKGRvY3VtZW50Wydtc0VsZW1lbnRzRnJvbVBvaW50J10pIHtcbiAgICAgICAgICAgIC8vIEVkZ2UgYW5kIElFIHNwZWNpYWwgc25vd2ZsYWtlc1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudHMgPSBkb2N1bWVudFsnbXNFbGVtZW50c0Zyb21Qb2ludCddKHZpZXdQb3J0WCwgdmlld1BvcnRZKTtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50cyA9PT0gbnVsbCA/IFtdIDogZWxlbWVudHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBPdGhlciBicm93c2VycyBsaWtlIENocm9tZSwgRmlyZWZveCwgT3BlcmFcbiAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5lbGVtZW50c0Zyb21Qb2ludCh2aWV3UG9ydFgsIHZpZXdQb3J0WSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGRpc3BhdGNoRXZlbnQodGFyZ2V0LCBldmVudE5hbWU6IHN0cmluZywgZXZlbnRBcmdzOiBJZ3hEcmFnQ3VzdG9tRXZlbnREZXRhaWxzKSB7XG4gICAgICAgIC8vIFRoaXMgd2F5IGlzIElFMTEgY29tcGF0aWJsZS5cbiAgICAgICAgY29uc3QgZHJhZ0xlYXZlRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQ3VzdG9tRXZlbnQnKTtcbiAgICAgICAgZHJhZ0xlYXZlRXZlbnQuaW5pdEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgZmFsc2UsIGZhbHNlLCBldmVudEFyZ3MpO1xuICAgICAgICB0YXJnZXQuZGlzcGF0Y2hFdmVudChkcmFnTGVhdmVFdmVudCk7XG4gICAgICAgIC8vIE90aGVyd2lzZSBjYW4gYmUgdXNlZCBgdGFyZ2V0LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KGV2ZW50TmFtZSwgZXZlbnRBcmdzKSk7YFxuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXRUcmFuc2Zvcm1YKGVsZW0pIHtcbiAgICAgICAgbGV0IHBvc1ggPSAwO1xuICAgICAgICBpZiAoZWxlbS5zdHlsZS50cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdHJpeCA9IGVsZW0uc3R5bGUudHJhbnNmb3JtO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gbWF0cml4ID8gbWF0cml4Lm1hdGNoKC8tP1tcXGRcXC5dKy9nKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHBvc1ggPSB2YWx1ZXMgPyBOdW1iZXIodmFsdWVzWyAxIF0pIDogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb3NYO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXRUcmFuc2Zvcm1ZKGVsZW0pIHtcbiAgICAgICAgbGV0IHBvc1kgPSAwO1xuICAgICAgICBpZiAoZWxlbS5zdHlsZS50cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdHJpeCA9IGVsZW0uc3R5bGUudHJhbnNmb3JtO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gbWF0cml4ID8gbWF0cml4Lm1hdGNoKC8tP1tcXGRcXC5dKy9nKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHBvc1kgPSB2YWx1ZXMgPyBOdW1iZXIodmFsdWVzWyAyIF0pIDogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwb3NZO1xuICAgIH1cblxuICAgIC8qKiBNZXRob2Qgc2V0dGluZyB0cmFuc2Zvcm1hdGlvbiB0byB0aGUgYmFzZSBkcmFnZ2FibGUgZWxlbWVudC4gKi9cbiAgICBwcm90ZWN0ZWQgc2V0VHJhbnNmb3JtWFkoeDogbnVtYmVyLCB5OiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZTNkKCcgKyB4ICsgJ3B4LCAnICsgeSArICdweCwgMHB4KSc7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdldFdpbmRvd1Njcm9sbFRvcCgpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5zY3JvbGxZID8gd2luZG93LnNjcm9sbFkgOiAod2luZG93LnBhZ2VZT2Zmc2V0ID8gd2luZG93LnBhZ2VZT2Zmc2V0IDogMCk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGdldFdpbmRvd1Njcm9sbExlZnQoKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuc2Nyb2xsWCA/IHdpbmRvdy5zY3JvbGxYIDogKHdpbmRvdy5wYWdlWE9mZnNldCA/IHdpbmRvdy5wYWdlWE9mZnNldCA6IDApO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBnaG9zdEhvc3RPZmZzZXRMZWZ0KGdob3N0SG9zdDogYW55KSB7XG4gICAgICAgIGNvbnN0IGdob3N0UG9zaXRpb24gPSBkb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKGdob3N0SG9zdCkuZ2V0UHJvcGVydHlWYWx1ZSgncG9zaXRpb24nKTtcbiAgICAgICAgaWYgKGdob3N0UG9zaXRpb24gPT09ICdzdGF0aWMnICYmIGdob3N0SG9zdC5vZmZzZXRQYXJlbnQgJiYgZ2hvc3RIb3N0Lm9mZnNldFBhcmVudCA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZ2hvc3RQb3NpdGlvbiA9PT0gJ3N0YXRpYycgJiYgZ2hvc3RIb3N0Lm9mZnNldFBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGdob3N0SG9zdC5vZmZzZXRQYXJlbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtIHRoaXMuZ2V0V2luZG93U2Nyb2xsTGVmdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnaG9zdEhvc3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtIHRoaXMuZ2V0V2luZG93U2Nyb2xsTGVmdCgpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBnaG9zdEhvc3RPZmZzZXRUb3AoZ2hvc3RIb3N0OiBhbnkpIHtcbiAgICAgICAgY29uc3QgZ2hvc3RQb3NpdGlvbiA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZ2hvc3RIb3N0KS5nZXRQcm9wZXJ0eVZhbHVlKCdwb3NpdGlvbicpO1xuICAgICAgICBpZiAoZ2hvc3RQb3NpdGlvbiA9PT0gJ3N0YXRpYycgJiYgZ2hvc3RIb3N0Lm9mZnNldFBhcmVudCAmJiBnaG9zdEhvc3Qub2Zmc2V0UGFyZW50ID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSBlbHNlIGlmIChnaG9zdFBvc2l0aW9uID09PSAnc3RhdGljJyAmJiBnaG9zdEhvc3Qub2Zmc2V0UGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZ2hvc3RIb3N0Lm9mZnNldFBhcmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgLSB0aGlzLmdldFdpbmRvd1Njcm9sbFRvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnaG9zdEhvc3QuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIC0gdGhpcy5nZXRXaW5kb3dTY3JvbGxUb3AoKTtcbiAgICB9XG59XG5cbkBEaXJlY3RpdmUoe1xuICAgIGV4cG9ydEFzOiAnZHJvcCcsXG4gICAgc2VsZWN0b3I6ICdbaWd4RHJvcF0nXG59KVxuZXhwb3J0IGNsYXNzIElneERyb3BEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG5cbiAgICAvKipcbiAgICAgKiAtIFNhdmUgZGF0YSBpbnNpZGUgdGhlIGBpZ3hEcm9wYCBkaXJlY3RpdmUuIFRoaXMgY2FuIGJlIHNldCB3aGVuIGluc3RhbmNpbmcgYGlneERyb3BgIG9uIGFuIGVsZW1lbnQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgW2lneERyb3BdPVwieyBzb3VyY2U6IG15RWxlbWVudCB9XCI+PC9kaXY+XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyb3BEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoJ2lneERyb3AnKVxuICAgIHB1YmxpYyBkYXRhOiBhbnk7XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBwcm92aWRlIGEgd2F5IGZvciBpZ3hEcmFnIGFuZCBpZ3hEcm9wIHRvIGJlIGxpbmtlZCB0aHJvdWdoIGNoYW5uZWxzLlxuICAgICAqIEl0IGFjY2VwdHMgc2luZ2xlIHZhbHVlIG9yIGFuIGFycmF5IG9mIHZhbHVlcyBhbmQgZXZhbHVhdGVzIHRoZW4gdXNpbmcgc3RyaWN0IGVxdWFsaXR5LlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWcgW2RyYWdDaGFubmVsXT1cIidvZGQnXCI+XG4gICAgICogICAgICAgICA8c3Bhbj45NTwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiA8ZGl2IGlneERyb3AgW2Ryb3BDaGFubmVsXT1cIlsnb2RkJywgJ2lycmF0aW9uYWwnXVwiPlxuICAgICAqICAgICAgICAgPHNwYW4+TnVtYmVycyBkcm9wIGFyZWEhPC9zcGFuPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcm9wRGlyZWN0aXZlXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZHJvcENoYW5uZWw6IG51bWJlciB8IHN0cmluZyB8IG51bWJlcltdIHwgc3RyaW5nW107XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzcGVjaWZpZXMgYSBkcm9wIHN0cmF0ZWd5IHR5cGUgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gYW4gYElneERyYWdgIGVsZW1lbnQgaXMgcmVsZWFzZWQgaW5zaWRlXG4gICAgICogIHRoZSBjdXJyZW50IGRyb3AgYXJlYS4gVGhlIHByb3ZpZGVkIHN0cmF0ZWdpZXMgYXJlOlxuICAgICAqICAtIElneERlZmF1bHREcm9wU3RyYXRlZ3kgLSBUaGlzIGlzIHRoZSBkZWZhdWx0IGJhc2Ugc3RyYXRlZ3kgYW5kIGl0IGRvZXNuJ3QgcGVyZm9ybSBhbnkgYWN0aW9ucy5cbiAgICAgKiAgLSBJZ3hBcHBlbmREcm9wU3RyYXRlZ3kgLSBBcHBlbmRzIHRoZSBkcm9wcGVkIGVsZW1lbnQgdG8gbGFzdCBwb3NpdGlvbiBhcyBhIGRpcmVjdCBjaGlsZCB0byB0aGUgYGlneERyb3BgLlxuICAgICAqICAtIElneFByZXBlbmREcm9wU3RyYXRlZ3kgLSBQcmVwZW5kcyB0aGUgZHJvcHBlZCBlbGVtZW50IHRvIGZpcnN0IHBvc2l0aW9uIGFzIGEgZGlyZWN0IGNoaWxkIHRvIHRoZSBgaWd4RHJvcGAuXG4gICAgICogIC0gSWd4SW5zZXJ0RHJvcFN0cmF0ZWd5IC0gSWYgdGhlIGRyb3BwZWQgZWxlbWVudCBpcyByZWxlYXNlZCBhYm92ZSBhIGNoaWxkIGVsZW1lbnQgb2YgdGhlIGBpZ3hEcm9wYCwgaXQgd2lsbCBiZSBpbnNlcnRlZFxuICAgICAqICAgICAgYXQgdGhhdCBwb3NpdGlvbi4gT3RoZXJ3aXNlIHRoZSBkcm9wcGVkIGVsZW1lbnQgd2lsbCBiZSBhcHBlbmRlZCBpZiByZWxlYXNlZCBvdXRzaWRlIGFueSBjaGlsZCBvZiB0aGUgYGlneERyb3BgLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8ZGl2IGlneERyYWc+XG4gICAgICogICAgICA8c3Bhbj5EcmFnTWU8L3NwYW4+XG4gICAgICogPC9kaXY+XG4gICAgICogPGRpdiBpZ3hEcm9wIFtkcm9wU3RyYXRlZ3ldPVwibXlEcm9wU3RyYXRlZ3lcIj5cbiAgICAgKiAgICAgICAgIDxzcGFuPk51bWJlcnMgZHJvcCBhcmVhITwvc3Bhbj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogaW1wb3J0IHsgSWd4QXBwZW5kRHJvcFN0cmF0ZWd5IH0gZnJvbSAnaWduaXRldWktYW5ndWxhcic7XG4gICAgICpcbiAgICAgKiBleHBvcnQgY2xhc3MgQXBwIHtcbiAgICAgKiAgICAgIHB1YmxpYyBteURyb3BTdHJhdGVneSA9IElneEFwcGVuZERyb3BTdHJhdGVneTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyb3BEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZXQgZHJvcFN0cmF0ZWd5KGNsYXNzUmVmOiBhbnkpIHtcbiAgICAgICAgdGhpcy5fZHJvcFN0cmF0ZWd5ID0gbmV3IGNsYXNzUmVmKHRoaXMuX3JlbmRlcmVyKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgZ2V0IGRyb3BTdHJhdGVneSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Ryb3BTdHJhdGVneTtcbiAgICB9XG5cbiAgICAvKiogRXZlbnQgdHJpZ2dlcmVkIHdoZW4gZHJhZ2dlZCBlbGVtZW50IGVudGVycyB0aGUgYXJlYSBvZiB0aGUgZWxlbWVudC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBjbGFzcz1cImNhZ2VBcmVhXCIgaWd4RHJvcCAoZW50ZXIpPVwiZHJhZ0VudGVyKClcIiAoaWd4RHJhZ0VudGVyKT1cIm9uRHJhZ0NhZ2VFbnRlcigpXCIgKGlneERyYWdMZWF2ZSk9XCJvbkRyYWdDYWdlTGVhdmUoKVwiPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgZHJhZ0VudGVyKCl7XG4gICAgICogICAgIGFsZXJ0KFwiQSBkcmFnZ2FibGUgZWxlbWVudCBoYXMgZW50ZXJlZCB0aGUgY2hpcCBhcmVhIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyb3BEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgZW50ZXIgPSBuZXcgRXZlbnRFbWl0dGVyPElEcm9wQmFzZUV2ZW50QXJncz4oKTtcblxuICAgICAgICAvKiogRXZlbnQgdHJpZ2dlcmVkIHdoZW4gZHJhZ2dlZCBlbGVtZW50IGVudGVycyB0aGUgYXJlYSBvZiB0aGUgZWxlbWVudC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBjbGFzcz1cImNhZ2VBcmVhXCIgaWd4RHJvcCAoZW50ZXIpPVwiZHJhZ0VudGVyKClcIiAoaWd4RHJhZ0VudGVyKT1cIm9uRHJhZ0NhZ2VFbnRlcigpXCIgKGlneERyYWdMZWF2ZSk9XCJvbkRyYWdDYWdlTGVhdmUoKVwiPlxuICAgICAqIDwvZGl2PlxuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBwdWJsaWMgZHJhZ0VudGVyKCl7XG4gICAgICogICAgIGFsZXJ0KFwiQSBkcmFnZ2FibGUgZWxlbWVudCBoYXMgZW50ZXJlZCB0aGUgY2hpcCBhcmVhIVwiKTtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIElneERyb3BEaXJlY3RpdmVcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgb3ZlciA9IG5ldyBFdmVudEVtaXR0ZXI8SURyb3BCYXNlRXZlbnRBcmdzPigpO1xuXG4gICAgLyoqIEV2ZW50IHRyaWdnZXJlZCB3aGVuIGRyYWdnZWQgZWxlbWVudCBsZWF2ZXMgdGhlIGFyZWEgb2YgdGhlIGVsZW1lbnQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxkaXYgY2xhc3M9XCJjYWdlQXJlYVwiIGlneERyb3AgKGxlYXZlKT1cImRyYWdMZWF2ZSgpXCIgKGlneERyYWdFbnRlcik9XCJvbkRyYWdDYWdlRW50ZXIoKVwiIChpZ3hEcmFnTGVhdmUpPVwib25EcmFnQ2FnZUxlYXZlKClcIj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIGRyYWdMZWF2ZSgpe1xuICAgICAqICAgICBhbGVydChcIkEgZHJhZ2dhYmxlIGVsZW1lbnQgaGFzIGxlZnQgdGhlIGNoaXAgYXJlYSFcIik7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hEcm9wRGlyZWN0aXZlXG4gICAgICovXG4gICAgQE91dHB1dCgpXG4gICAgcHVibGljIGxlYXZlID0gbmV3IEV2ZW50RW1pdHRlcjxJRHJvcEJhc2VFdmVudEFyZ3M+KCk7XG5cbiAgICAvKiogRXZlbnQgdHJpZ2dlcmVkIHdoZW4gZHJhZ2dlZCBlbGVtZW50IGlzIGRyb3BwZWQgaW4gdGhlIGFyZWEgb2YgdGhlIGVsZW1lbnQuXG4gICAgICogU2luY2UgdGhlIGBpZ3hEcm9wYCBoYXMgZGVmYXVsdCBsb2dpYyB0aGF0IGFwcGVuZHMgdGhlIGRyb3BwZWQgZWxlbWVudCBhcyBhIGNoaWxkLCBpdCBjYW4gYmUgY2FuY2VsZWQgaGVyZS5cbiAgICAgKiBUbyBjYW5jZWwgdGhlIGRlZmF1bHQgbG9naWMgdGhlIGBjYW5jZWxgIHByb3BlcnR5IG9mIHRoZSBldmVudCBuZWVkcyB0byBiZSBzZXQgdG8gdHJ1ZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGRpdiBjbGFzcz1cImNhZ2VBcmVhXCIgaWd4RHJvcCAoZHJvcHBlZCk9XCJkcmFnRHJvcCgpXCIgKGlneERyYWdFbnRlcik9XCJvbkRyYWdDYWdlRW50ZXIoKVwiIChpZ3hEcmFnTGVhdmUpPVwib25EcmFnQ2FnZUxlYXZlKClcIj5cbiAgICAgKiA8L2Rpdj5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIGRyYWdEcm9wKCl7XG4gICAgICogICAgIGFsZXJ0KFwiQSBkcmFnZ2FibGUgZWxlbWVudCBoYXMgYmVlbiBkcm9wcGVkIGluIHRoZSBjaGlwIGFyZWEhXCIpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4RHJvcERpcmVjdGl2ZVxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBkcm9wcGVkID0gbmV3IEV2ZW50RW1pdHRlcjxJRHJvcERyb3BwZWRFdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmRyb3BwYWJsZScpXG4gICAgcHVibGljIGRyb3BwYWJsZSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdjbGFzcy5kcmFnT3ZlcicpXG4gICAgcHVibGljIGRyYWdvdmVyID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9kZXN0cm95ID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcbiAgICBwcm90ZWN0ZWQgX2Ryb3BTdHJhdGVneTogSURyb3BTdHJhdGVneTtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBlbGVtZW50OiBFbGVtZW50UmVmLCBwcml2YXRlIF9yZW5kZXJlcjogUmVuZGVyZXIyLCBwcml2YXRlIF96b25lOiBOZ1pvbmUpIHtcbiAgICAgICAgdGhpcy5fZHJvcFN0cmF0ZWd5ID0gbmV3IElneERlZmF1bHREcm9wU3RyYXRlZ3koKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLl96b25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIGZyb21FdmVudCh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgJ2lneERyYWdFbnRlcicpLnBpcGUodGFrZVVudGlsKHRoaXMuX2Rlc3Ryb3kpKVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKHJlcykgPT4gdGhpcy5vbkRyYWdFbnRlcihyZXMgYXMgQ3VzdG9tRXZlbnQ8SWd4RHJhZ0N1c3RvbUV2ZW50RGV0YWlscz4pKTtcblxuICAgICAgICAgICAgZnJvbUV2ZW50KHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCAnaWd4RHJhZ0xlYXZlJykucGlwZSh0YWtlVW50aWwodGhpcy5fZGVzdHJveSkpLnN1YnNjcmliZSgocmVzKSA9PiB0aGlzLm9uRHJhZ0xlYXZlKHJlcykpO1xuICAgICAgICAgICAgZnJvbUV2ZW50KHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LCAnaWd4RHJhZ092ZXInKS5waXBlKHRha2VVbnRpbCh0aGlzLl9kZXN0cm95KSkuc3Vic2NyaWJlKChyZXMpID0+IHRoaXMub25EcmFnT3ZlcihyZXMpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveS5uZXh0KHRydWUpO1xuICAgICAgICB0aGlzLl9kZXN0cm95LmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBvbkRyYWdPdmVyKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRQb3NYID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCArIHRoaXMuZ2V0V2luZG93U2Nyb2xsTGVmdCgpO1xuICAgICAgICBjb25zdCBlbGVtZW50UG9zWSA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCArIHRoaXMuZ2V0V2luZG93U2Nyb2xsVG9wKCk7XG4gICAgICAgIGNvbnN0IG9mZnNldFggPSBldmVudC5kZXRhaWwucGFnZVggLSBlbGVtZW50UG9zWDtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WSA9IGV2ZW50LmRldGFpbC5wYWdlWSAtIGVsZW1lbnRQb3NZO1xuICAgICAgICBjb25zdCBldmVudEFyZ3M6IElEcm9wQmFzZUV2ZW50QXJncyA9IHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50LmRldGFpbC5vcmlnaW5hbEV2ZW50LFxuICAgICAgICAgICAgb3duZXI6IHRoaXMsXG4gICAgICAgICAgICBkcmFnOiBldmVudC5kZXRhaWwub3duZXIsXG4gICAgICAgICAgICBkcmFnRGF0YTogZXZlbnQuZGV0YWlsLm93bmVyLmRhdGEsXG4gICAgICAgICAgICBzdGFydFg6IGV2ZW50LmRldGFpbC5zdGFydFgsXG4gICAgICAgICAgICBzdGFydFk6IGV2ZW50LmRldGFpbC5zdGFydFksXG4gICAgICAgICAgICBwYWdlWDogZXZlbnQuZGV0YWlsLnBhZ2VYLFxuICAgICAgICAgICAgcGFnZVk6IGV2ZW50LmRldGFpbC5wYWdlWSxcbiAgICAgICAgICAgIG9mZnNldFg6IG9mZnNldFgsXG4gICAgICAgICAgICBvZmZzZXRZOiBvZmZzZXRZXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5vdmVyLmVtaXQoZXZlbnRBcmdzKTtcbiAgICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBvbkRyYWdFbnRlcihldmVudDogQ3VzdG9tRXZlbnQ8SWd4RHJhZ0N1c3RvbUV2ZW50RGV0YWlscz4pIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRHJhZ0xpbmtlZChldmVudC5kZXRhaWwub3duZXIpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRyYWdvdmVyID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgZWxlbWVudFBvc1ggPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0ICsgdGhpcy5nZXRXaW5kb3dTY3JvbGxMZWZ0KCk7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRQb3NZID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgdGhpcy5nZXRXaW5kb3dTY3JvbGxUb3AoKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WCA9IGV2ZW50LmRldGFpbC5wYWdlWCAtIGVsZW1lbnRQb3NYO1xuICAgICAgICBjb25zdCBvZmZzZXRZID0gZXZlbnQuZGV0YWlsLnBhZ2VZIC0gZWxlbWVudFBvc1k7XG4gICAgICAgIGNvbnN0IGV2ZW50QXJnczogSURyb3BCYXNlRXZlbnRBcmdzID0ge1xuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZlbnQuZGV0YWlsLm9yaWdpbmFsRXZlbnQsXG4gICAgICAgICAgICBvd25lcjogdGhpcyxcbiAgICAgICAgICAgIGRyYWc6IGV2ZW50LmRldGFpbC5vd25lcixcbiAgICAgICAgICAgIGRyYWdEYXRhOiBldmVudC5kZXRhaWwub3duZXIuZGF0YSxcbiAgICAgICAgICAgIHN0YXJ0WDogZXZlbnQuZGV0YWlsLnN0YXJ0WCxcbiAgICAgICAgICAgIHN0YXJ0WTogZXZlbnQuZGV0YWlsLnN0YXJ0WSxcbiAgICAgICAgICAgIHBhZ2VYOiBldmVudC5kZXRhaWwucGFnZVgsXG4gICAgICAgICAgICBwYWdlWTogZXZlbnQuZGV0YWlsLnBhZ2VZLFxuICAgICAgICAgICAgb2Zmc2V0WDogb2Zmc2V0WCxcbiAgICAgICAgICAgIG9mZnNldFk6IG9mZnNldFlcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fem9uZS5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbnRlci5lbWl0KGV2ZW50QXJncyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgb25EcmFnTGVhdmUoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRHJhZ0xpbmtlZChldmVudC5kZXRhaWwub3duZXIpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRyYWdvdmVyID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGVsZW1lbnRQb3NYID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCArIHRoaXMuZ2V0V2luZG93U2Nyb2xsTGVmdCgpO1xuICAgICAgICBjb25zdCBlbGVtZW50UG9zWSA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCArIHRoaXMuZ2V0V2luZG93U2Nyb2xsVG9wKCk7XG4gICAgICAgIGNvbnN0IG9mZnNldFggPSBldmVudC5kZXRhaWwucGFnZVggLSBlbGVtZW50UG9zWDtcbiAgICAgICAgY29uc3Qgb2Zmc2V0WSA9IGV2ZW50LmRldGFpbC5wYWdlWSAtIGVsZW1lbnRQb3NZO1xuICAgICAgICBjb25zdCBldmVudEFyZ3M6IElEcm9wQmFzZUV2ZW50QXJncyA9IHtcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2ZW50LmRldGFpbC5vcmlnaW5hbEV2ZW50LFxuICAgICAgICAgICAgb3duZXI6IHRoaXMsXG4gICAgICAgICAgICBkcmFnOiBldmVudC5kZXRhaWwub3duZXIsXG4gICAgICAgICAgICBkcmFnRGF0YTogZXZlbnQuZGV0YWlsLm93bmVyLmRhdGEsXG4gICAgICAgICAgICBzdGFydFg6IGV2ZW50LmRldGFpbC5zdGFydFgsXG4gICAgICAgICAgICBzdGFydFk6IGV2ZW50LmRldGFpbC5zdGFydFksXG4gICAgICAgICAgICBwYWdlWDogZXZlbnQuZGV0YWlsLnBhZ2VYLFxuICAgICAgICAgICAgcGFnZVk6IGV2ZW50LmRldGFpbC5wYWdlWSxcbiAgICAgICAgICAgIG9mZnNldFg6IG9mZnNldFgsXG4gICAgICAgICAgICBvZmZzZXRZOiBvZmZzZXRZXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubGVhdmUuZW1pdChldmVudEFyZ3MpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RMaXN0ZW5lcignaWd4RHJvcCcsIFsnJGV2ZW50J10pXG4gICAgcHVibGljIG9uRHJhZ0Ryb3AoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRHJhZ0xpbmtlZChldmVudC5kZXRhaWwub3duZXIpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBlbGVtZW50UG9zWCA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgKyB0aGlzLmdldFdpbmRvd1Njcm9sbExlZnQoKTtcbiAgICAgICAgY29uc3QgZWxlbWVudFBvc1kgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgKyB0aGlzLmdldFdpbmRvd1Njcm9sbFRvcCgpO1xuICAgICAgICBjb25zdCBvZmZzZXRYID0gZXZlbnQuZGV0YWlsLnBhZ2VYIC0gZWxlbWVudFBvc1g7XG4gICAgICAgIGNvbnN0IG9mZnNldFkgPSBldmVudC5kZXRhaWwucGFnZVkgLSBlbGVtZW50UG9zWTtcbiAgICAgICAgY29uc3QgYXJnczogSURyb3BEcm9wcGVkRXZlbnRBcmdzID0ge1xuICAgICAgICAgICAgb3duZXI6IHRoaXMsXG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldmVudC5kZXRhaWwub3JpZ2luYWxFdmVudCxcbiAgICAgICAgICAgIGRyYWc6IGV2ZW50LmRldGFpbC5vd25lcixcbiAgICAgICAgICAgIGRyYWdEYXRhOiBldmVudC5kZXRhaWwub3duZXIuZGF0YSxcbiAgICAgICAgICAgIHN0YXJ0WDogZXZlbnQuZGV0YWlsLnN0YXJ0WCxcbiAgICAgICAgICAgIHN0YXJ0WTogZXZlbnQuZGV0YWlsLnN0YXJ0WSxcbiAgICAgICAgICAgIHBhZ2VYOiBldmVudC5kZXRhaWwucGFnZVgsXG4gICAgICAgICAgICBwYWdlWTogZXZlbnQuZGV0YWlsLnBhZ2VZLFxuICAgICAgICAgICAgb2Zmc2V0WDogb2Zmc2V0WCxcbiAgICAgICAgICAgIG9mZnNldFk6IG9mZnNldFksXG4gICAgICAgICAgICBjYW5jZWw6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3pvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZHJvcHBlZC5lbWl0KGFyZ3MpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5fZHJvcFN0cmF0ZWd5ICYmICFhcmdzLmNhbmNlbCkge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudHNBdFBvaW50ID0gZXZlbnQuZGV0YWlsLm93bmVyLmdldEVsZW1lbnRzQXRQb2ludChldmVudC5kZXRhaWwucGFnZVgsIGV2ZW50LmRldGFpbC5wYWdlWSk7XG4gICAgICAgICAgICBjb25zdCBpbnNlcnRJbmRleCA9IHRoaXMuZ2V0SW5zZXJ0SW5kZXhBdChldmVudC5kZXRhaWwub3duZXIsIGVsZW1lbnRzQXRQb2ludCk7XG4gICAgICAgICAgICB0aGlzLl9kcm9wU3RyYXRlZ3kuZHJvcEFjdGlvbihldmVudC5kZXRhaWwub3duZXIsIHRoaXMsIGluc2VydEluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXRXaW5kb3dTY3JvbGxUb3AoKSB7XG4gICAgICAgIHJldHVybiB3aW5kb3cuc2Nyb2xsWSA/IHdpbmRvdy5zY3JvbGxZIDogKHdpbmRvdy5wYWdlWU9mZnNldCA/IHdpbmRvdy5wYWdlWU9mZnNldCA6IDApO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXRXaW5kb3dTY3JvbGxMZWZ0KCkge1xuICAgICAgICByZXR1cm4gd2luZG93LnNjcm9sbFggPyB3aW5kb3cuc2Nyb2xsWCA6ICh3aW5kb3cucGFnZVhPZmZzZXQgPyB3aW5kb3cucGFnZVhPZmZzZXQgOiAwKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgaXNEcmFnTGlua2VkKGRyYWc6IElneERyYWdEaXJlY3RpdmUpOiBib29sZWFuIHtcbiAgICAgICAgY29uc3QgZHJhZ0xpbmtBcnJheSA9IGRyYWcuZHJhZ0NoYW5uZWwgaW5zdGFuY2VvZiBBcnJheTtcbiAgICAgICAgY29uc3QgZHJvcExpbmtBcnJheSA9IHRoaXMuZHJvcENoYW5uZWwgaW5zdGFuY2VvZiBBcnJheTtcblxuICAgICAgICBpZiAoIWRyYWdMaW5rQXJyYXkgJiYgIWRyb3BMaW5rQXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRyb3BDaGFubmVsID09PSBkcmFnLmRyYWdDaGFubmVsO1xuICAgICAgICB9IGVsc2UgaWYgKCFkcmFnTGlua0FycmF5ICYmIGRyb3BMaW5rQXJyYXkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRyb3BMaW5rcyA9IDxBcnJheTxhbnk+PnRoaXMuZHJvcENoYW5uZWw7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRyb3BMaW5rcy5sZW5ndGg7IGkgKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoZHJvcExpbmtzW2ldID09PSBkcmFnLmRyYWdDaGFubmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChkcmFnTGlua0FycmF5ICYmICFkcm9wTGlua0FycmF5KSB7XG4gICAgICAgICAgICBjb25zdCBkcmFnTGlua3MgPSA8QXJyYXk8YW55Pj5kcmFnLmRyYWdDaGFubmVsO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkcmFnTGlua3MubGVuZ3RoOyBpICsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRyYWdMaW5rc1tpXSA9PT0gdGhpcy5kcm9wQ2hhbm5lbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBkcmFnTGlua3MgPSA8QXJyYXk8YW55Pj5kcmFnLmRyYWdDaGFubmVsO1xuICAgICAgICAgICAgY29uc3QgZHJvcExpbmtzID0gPEFycmF5PGFueT4+dGhpcy5kcm9wQ2hhbm5lbDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZHJhZ0xpbmtzLmxlbmd0aDsgaSArKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZHJvcExpbmtzLmxlbmd0aDsgaiArKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZHJhZ0xpbmtzW2ldID09PSBkcm9wTGlua3Nbal0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBnZXRJbnNlcnRJbmRleEF0KGRyYWdnZWREaXI6IElneERyYWdEaXJlY3RpdmUsIGVsZW1lbnRzQXRQb2ludDogYW55W10pOiBudW1iZXIge1xuICAgICAgICBsZXQgaW5zZXJ0SW5kZXggPSAtMTtcbiAgICAgICAgY29uc3QgZHJvcENoaWxkcmVuID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQuY2hpbGRyZW4pO1xuICAgICAgICBpZiAoIWRyb3BDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnNlcnRJbmRleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgbGV0IGNoaWxkVW5kZXIgPSBudWxsO1xuICAgICAgICB3aGlsZSAoIWNoaWxkVW5kZXIgJiYgaSA8IGVsZW1lbnRzQXRQb2ludC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50c0F0UG9pbnRbaV0ucGFyZW50RWxlbWVudCA9PT0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjaGlsZFVuZGVyID0gZWxlbWVudHNBdFBvaW50W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZHJhZ2dlZEVsZW1JbmRleCA9IGRyb3BDaGlsZHJlbi5pbmRleE9mKGRyYWdnZWREaXIuZWxlbWVudC5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgaW5zZXJ0SW5kZXggPSBkcm9wQ2hpbGRyZW4uaW5kZXhPZihjaGlsZFVuZGVyKTtcbiAgICAgICAgaWYgKGRyYWdnZWRFbGVtSW5kZXggIT09IC0xICYmIGRyYWdnZWRFbGVtSW5kZXggPCBpbnNlcnRJbmRleCkge1xuICAgICAgICAgICAgaW5zZXJ0SW5kZXgrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbnNlcnRJbmRleDtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbkBOZ01vZHVsZSh7XG4gICAgZGVjbGFyYXRpb25zOiBbSWd4RHJhZ0RpcmVjdGl2ZSwgSWd4RHJvcERpcmVjdGl2ZSwgSWd4RHJhZ0hhbmRsZURpcmVjdGl2ZV0sXG4gICAgZXhwb3J0czogW0lneERyYWdEaXJlY3RpdmUsIElneERyb3BEaXJlY3RpdmUsIElneERyYWdIYW5kbGVEaXJlY3RpdmVdXG59KVxuZXhwb3J0IGNsYXNzIElneERyYWdEcm9wTW9kdWxlIHsgfVxuIl19