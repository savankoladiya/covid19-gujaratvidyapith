/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Component, ChangeDetectorRef, ElementRef, ViewChild, Inject, ChangeDetectionStrategy, NgZone, Input, TemplateRef } from '@angular/core';
import { IgxGridCellComponent } from '../cell.component';
import { GridBaseAPIService } from '../api.service';
import { getNodeSizeViaRange, PlatformUtil } from '../../core/utils';
import { DOCUMENT } from '@angular/common';
import { IgxGridSelectionService, IgxGridCRUDService } from '../../core/grid-selection';
import { HammerGesturesManager } from '../../core/touch';
var IgxTreeGridCellComponent = /** @class */ (function (_super) {
    tslib_1.__extends(IgxTreeGridCellComponent, _super);
    function IgxTreeGridCellComponent(selectionService, crudService, gridAPI, cdr, element, zone, touchManager, document, platformUtil) {
        var _this = _super.call(this, selectionService, crudService, gridAPI, cdr, element, zone, touchManager, platformUtil) || this;
        _this.zone = zone;
        _this.document = document;
        _this.platformUtil = platformUtil;
        /**
         * @hidden
         */
        _this.expanded = false;
        /**
         * @hidden
         */
        _this.level = 0;
        /**
         * @hidden
         */
        _this.showIndicator = false;
        _this.treeGridAPI = (/** @type {?} */ (gridAPI));
        return _this;
    }
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTreeGridCellComponent.prototype.ngOnInit = /**
     * @hidden
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxTreeGridCellComponent.prototype.toggle = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.stopPropagation();
        this.treeGridAPI.trigger_row_expansion_toggle(this.row.treeRow, !this.row.expanded, event, this.visibleColumnIndex);
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @return {?}
     */
    IgxTreeGridCellComponent.prototype.onIndicatorFocus = /**
     * @hidden
     * @return {?}
     */
    function () {
        this.gridAPI.submit_value();
        this.nativeElement.focus();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    IgxTreeGridCellComponent.prototype.onLoadingDblClick = /**
     * @hidden
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.stopPropagation();
    };
    /**
     * @hidden
     */
    /**
     * @hidden
     * @param {?} range
     * @return {?}
     */
    IgxTreeGridCellComponent.prototype.calculateSizeToFit = /**
     * @hidden
     * @param {?} range
     * @return {?}
     */
    function (range) {
        /** @type {?} */
        var indicatorWidth = this.indicator.nativeElement.getBoundingClientRect().width;
        /** @type {?} */
        var indicatorStyle = this.document.defaultView.getComputedStyle(this.indicator.nativeElement);
        /** @type {?} */
        var indicatorMargin = parseFloat(indicatorStyle.marginRight);
        /** @type {?} */
        var leftPadding = 0;
        if (this.indentationDiv) {
            /** @type {?} */
            var indentationStyle = this.document.defaultView.getComputedStyle(this.indentationDiv.nativeElement);
            leftPadding = parseFloat(indentationStyle.paddingLeft);
        }
        /** @type {?} */
        var largestWidth = Math.max.apply(Math, tslib_1.__spread(Array.from(this.nativeElement.children)
            .map(function (child) { return getNodeSizeViaRange(range, child); })));
        return largestWidth + indicatorWidth + indicatorMargin + leftPadding;
    };
    Object.defineProperty(IgxTreeGridCellComponent.prototype, "iconTemplate", {
        /**
         * @hidden
        */
        get: /**
         * @hidden
         * @return {?}
         */
        function () {
            if (this.expanded) {
                return this.grid.rowExpandedIndicatorTemplate || this.defaultExpandedTemplate;
            }
            else {
                return this.grid.rowCollapsedIndicatorTemplate || this.defaultCollapsedTemplate;
            }
        },
        enumerable: true,
        configurable: true
    });
    IgxTreeGridCellComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    selector: 'igx-tree-grid-cell',
                    template: "<ng-template #defaultCell>\n    <div igxTextHighlight style=\"pointer-events: none\" [cssClass]=\"highlightClass\" [activeCssClass]=\"activeHighlightClass\" [groupName]=\"gridID\"\n        [value]=\"formatter ? formatter(value) : column.dataType === 'number' ? (value | igxdecimal: grid.locale) : column.dataType === 'date' ? (value | igxdate: grid.locale) : value\"\n        [row]=\"rowData\" [column]=\"this.column.field\" [containerClass]=\"'igx-grid__td-text'\"\n        class=\"igx-grid__td-text\">{{ formatter ? formatter(value) : column.dataType === 'number' ? (value | igxdecimal:\n        grid.locale) : column.dataType === 'date' ? (value | igxdate: grid.locale) : value }}</div>\n</ng-template>\n<ng-template #inlineEditor  let-cell=\"cell\">\n    <ng-container *ngIf=\"column.dataType === 'string'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [(ngModel)]=\"editValue\" [igxFocus]=\"focused\">\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'number'\">\n        <igx-input-group displayDensity=\"compact\">\n            <input igxInput [(ngModel)]=\"editValue\" [igxFocus]=\"focused\"  type=\"number\">\n        </igx-input-group>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'boolean'\">\n        <igx-checkbox (change)=\"editValue = $event.checked\" [value]=\"editValue\" [checked]=\"editValue\" [disableRipple]=\"true\"></igx-checkbox>\n    </ng-container>\n    <ng-container *ngIf=\"column.dataType === 'date'\">\n        <igx-date-picker [style.width.%]=\"100\" [outlet]=\"grid.outletDirective\" mode=\"dropdown\"\n        [locale]=\"grid.locale\" [(value)]=\"editValue\" [igxFocus]=\"focused\" [labelVisibility]=\"false\">\n    </igx-date-picker>\n    </ng-container>\n</ng-template>\n<ng-container *ngIf=\"!editMode\">\n    <ng-container *ngIf=\"level > 0\">\n        <div #indentationDiv class=\"igx-grid__tree-cell--padding-level-{{level}}\"></div>\n    </ng-container>\n    <div #indicator\n         *ngIf=\"!isLoading\"\n         class=\"igx-grid__tree-grouping-indicator\"\n         [ngStyle]=\"{'visibility': showIndicator ? 'visible' : 'hidden'}\"\n         (click)=\"toggle($event)\" (focus)=\"onIndicatorFocus()\" tabindex=\"-1\">\n         <ng-container *ngTemplateOutlet=\"iconTemplate; context: { $implicit:  this }\">\n        </ng-container>\n    </div>\n    <div *ngIf=\"isLoading\"\n         (dblclick)=\"onLoadingDblClick($event)\"\n         class=\"igx-grid__tree-loading-indicator\">\n        <ng-container *ngTemplateOutlet=\"grid.rowLoadingIndicatorTemplate ? grid.rowLoadingIndicatorTemplate : defaultLoadingIndicatorTemplate\">\n        </ng-container>\n    </div>\n    <ng-template #defaultLoadingIndicatorTemplate>\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </ng-template>\n</ng-container>\n<ng-container *ngTemplateOutlet=\"template; context: context\">\n</ng-container>\n<ng-template #defaultExpandedTemplate>\n        <igx-icon fontSet=\"material\">expand_more</igx-icon>\n</ng-template>\n<ng-template #defaultCollapsedTemplate>\n        <igx-icon fontSet=\"material\">chevron_right</igx-icon>\n</ng-template>\n",
                    providers: [HammerGesturesManager]
                }] }
    ];
    /** @nocollapse */
    IgxTreeGridCellComponent.ctorParameters = function () { return [
        { type: IgxGridSelectionService },
        { type: IgxGridCRUDService },
        { type: GridBaseAPIService },
        { type: ChangeDetectorRef },
        { type: ElementRef },
        { type: NgZone },
        { type: HammerGesturesManager },
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
        { type: PlatformUtil }
    ]; };
    IgxTreeGridCellComponent.propDecorators = {
        expanded: [{ type: Input }],
        level: [{ type: Input }],
        showIndicator: [{ type: Input }],
        indicator: [{ type: ViewChild, args: ['indicator', { read: ElementRef, static: false },] }],
        indentationDiv: [{ type: ViewChild, args: ['indentationDiv', { read: ElementRef, static: false },] }],
        defaultContentElement: [{ type: ViewChild, args: ['defaultContentElement', { read: ElementRef, static: false },] }],
        defaultExpandedTemplate: [{ type: ViewChild, args: ['defaultExpandedTemplate', { read: TemplateRef, static: true },] }],
        defaultCollapsedTemplate: [{ type: ViewChild, args: ['defaultCollapsedTemplate', { read: TemplateRef, static: true },] }],
        isLoading: [{ type: Input }]
    };
    return IgxTreeGridCellComponent;
}(IgxGridCellComponent));
export { IgxTreeGridCellComponent };
if (false) {
    /**
     * @type {?}
     * @private
     */
    IgxTreeGridCellComponent.prototype.treeGridAPI;
    /**
     * @hidden
     * @type {?}
     */
    IgxTreeGridCellComponent.prototype.expanded;
    /**
     * @hidden
     * @type {?}
     */
    IgxTreeGridCellComponent.prototype.level;
    /**
     * @hidden
     * @type {?}
     */
    IgxTreeGridCellComponent.prototype.showIndicator;
    /** @type {?} */
    IgxTreeGridCellComponent.prototype.indicator;
    /** @type {?} */
    IgxTreeGridCellComponent.prototype.indentationDiv;
    /** @type {?} */
    IgxTreeGridCellComponent.prototype.defaultContentElement;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxTreeGridCellComponent.prototype.defaultExpandedTemplate;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxTreeGridCellComponent.prototype.defaultCollapsedTemplate;
    /**
     * @hidden
     * @type {?}
     */
    IgxTreeGridCellComponent.prototype.isLoading;
    /**
     * @type {?}
     * @protected
     */
    IgxTreeGridCellComponent.prototype.zone;
    /** @type {?} */
    IgxTreeGridCellComponent.prototype.document;
    /**
     * @type {?}
     * @protected
     */
    IgxTreeGridCellComponent.prototype.platformUtil;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS1jZWxsLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvZ3JpZHMvdHJlZS1ncmlkL3RyZWUtY2VsbC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLGlCQUFpQixFQUFFLFVBQVUsRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUMvRCx1QkFBdUIsRUFBRSxNQUFNLEVBQVUsS0FBSyxFQUFFLFdBQVcsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN4RixPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQztBQUV6RCxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNwRCxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsWUFBWSxFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDckUsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBRTNDLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxrQkFBa0IsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBQ3hGLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBRXpEO0lBTThDLG9EQUFvQjtJQUc5RCxrQ0FDWSxnQkFBeUMsRUFDekMsV0FBK0IsRUFDL0IsT0FBcUUsRUFDckUsR0FBc0IsRUFDdEIsT0FBbUIsRUFDVCxJQUFZLEVBQ3RCLFlBQW1DLEVBQ1YsUUFBUSxFQUN2QixZQUEwQjtRQVRoRCxZQVVJLGtCQUFNLGdCQUFnQixFQUFFLFdBQVcsRUFBRSxPQUFPLEVBQUUsR0FBRyxFQUFFLE9BQU8sRUFBRSxJQUFJLEVBQUUsWUFBWSxFQUFFLFlBQVksQ0FBQyxTQUVoRztRQU5xQixVQUFJLEdBQUosSUFBSSxDQUFRO1FBRUcsY0FBUSxHQUFSLFFBQVEsQ0FBQTtRQUN2QixrQkFBWSxHQUFaLFlBQVksQ0FBYzs7OztR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Z0JBQ25CLE1BQU07Z0JBUTNCLHFCQUFxQjtnREFtQmIsTUFBTSxTQUFDLFFBQVE7Z0JBdkJGLFlBQVk7OzsyQkFnQ3JDLEtBQUs7d0JBTUwsS0FBSztnQ0FNTCxLQUFLOzRCQUdMLFNBQVMsU0FBQyxXQUFXLEVBQUUsRUFBRSxJQUFJLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUU7aUNBRzFELFNBQVMsU0FBQyxnQkFBZ0IsRUFBRSxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRTt3Q0FHL0QsU0FBUyxTQUFDLHVCQUF1QixFQUFFLEVBQUUsSUFBSSxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFOzBDQU12RSxTQUFTLFNBQUMseUJBQXlCLEVBQUUsRUFBRSxJQUFJLEVBQUUsV0FBVyxFQUFFLE1BQU0sRUFBRSxJQUFJLEVBQUU7MkNBTXhFLFNBQVMsU0FBQywwQkFBMEIsRUFBRSxFQUFFLElBQUksRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRTs0QkFNeEUsS0FBSzs7SUE0RFYsK0JBQUM7Q0FBQSxBQTdIRCxDQU04QyxvQkFBb0IsR0F1SGpFO1NBdkhZLHdCQUF3Qjs7Ozs7O0lBQ2pDLCtDQUEyQzs7Ozs7SUFtQjNDLDRDQUNpQjs7Ozs7SUFLakIseUNBQ1U7Ozs7O0lBS1YsaURBQ3NCOztJQUV0Qiw2Q0FDNkI7O0lBRTdCLGtEQUNrQzs7SUFFbEMseURBQ3lDOzs7Ozs7SUFLMUMsMkRBQ29EOzs7Ozs7SUFLcEQsNERBQ3FEOzs7OztJQUtwRCw2Q0FDMEI7Ozs7O0lBbkRkLHdDQUFzQjs7SUFFdEIsNENBQWlDOzs7OztJQUNqQyxnREFBb0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21wb25lbnQsIENoYW5nZURldGVjdG9yUmVmLCBFbGVtZW50UmVmLCBWaWV3Q2hpbGQsIEluamVjdCxcbiAgICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIE5nWm9uZSwgT25Jbml0LCBJbnB1dCwgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IElneEdyaWRDZWxsQ29tcG9uZW50IH0gZnJvbSAnLi4vY2VsbC5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4VHJlZUdyaWRBUElTZXJ2aWNlIH0gZnJvbSAnLi90cmVlLWdyaWQtYXBpLnNlcnZpY2UnO1xuaW1wb3J0IHsgR3JpZEJhc2VBUElTZXJ2aWNlIH0gZnJvbSAnLi4vYXBpLnNlcnZpY2UnO1xuaW1wb3J0IHsgZ2V0Tm9kZVNpemVWaWFSYW5nZSwgUGxhdGZvcm1VdGlsIH0gZnJvbSAnLi4vLi4vY29yZS91dGlscyc7XG5pbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBJZ3hHcmlkQmFzZUNvbXBvbmVudCwgSUdyaWREYXRhQmluZGFibGUgfSBmcm9tICcuLi9ncmlkJztcbmltcG9ydCB7IElneEdyaWRTZWxlY3Rpb25TZXJ2aWNlLCBJZ3hHcmlkQ1JVRFNlcnZpY2UgfSBmcm9tICcuLi8uLi9jb3JlL2dyaWQtc2VsZWN0aW9uJztcbmltcG9ydCB7IEhhbW1lckdlc3R1cmVzTWFuYWdlciB9IGZyb20gJy4uLy4uL2NvcmUvdG91Y2gnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICBzZWxlY3RvcjogJ2lneC10cmVlLWdyaWQtY2VsbCcsXG4gICAgdGVtcGxhdGVVcmw6ICd0cmVlLWNlbGwuY29tcG9uZW50Lmh0bWwnLFxuICAgIHByb3ZpZGVyczogW0hhbW1lckdlc3R1cmVzTWFuYWdlcl1cbn0pXG5leHBvcnQgY2xhc3MgSWd4VHJlZUdyaWRDZWxsQ29tcG9uZW50IGV4dGVuZHMgSWd4R3JpZENlbGxDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQge1xuICAgIHByaXZhdGUgdHJlZUdyaWRBUEk6IElneFRyZWVHcmlkQVBJU2VydmljZTtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvblNlcnZpY2U6IElneEdyaWRTZWxlY3Rpb25TZXJ2aWNlLFxuICAgICAgICAgICAgICAgIGNydWRTZXJ2aWNlOiBJZ3hHcmlkQ1JVRFNlcnZpY2UsXG4gICAgICAgICAgICAgICAgZ3JpZEFQSTogR3JpZEJhc2VBUElTZXJ2aWNlPElneEdyaWRCYXNlQ29tcG9uZW50ICYgSUdyaWREYXRhQmluZGFibGU+LFxuICAgICAgICAgICAgICAgIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgICAgICAgICAgICAgZWxlbWVudDogRWxlbWVudFJlZixcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgem9uZTogTmdab25lLFxuICAgICAgICAgICAgICAgIHRvdWNoTWFuYWdlcjogSGFtbWVyR2VzdHVyZXNNYW5hZ2VyLFxuICAgICAgICAgICAgICAgIEBJbmplY3QoRE9DVU1FTlQpIHB1YmxpYyBkb2N1bWVudCxcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgcGxhdGZvcm1VdGlsOiBQbGF0Zm9ybVV0aWwpIHtcbiAgICAgICAgc3VwZXIoc2VsZWN0aW9uU2VydmljZSwgY3J1ZFNlcnZpY2UsIGdyaWRBUEksIGNkciwgZWxlbWVudCwgem9uZSwgdG91Y2hNYW5hZ2VyLCBwbGF0Zm9ybVV0aWwpO1xuICAgICAgICB0aGlzLnRyZWVHcmlkQVBJID0gPElneFRyZWVHcmlkQVBJU2VydmljZT5ncmlkQVBJO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGV4cGFuZGVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBsZXZlbCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzaG93SW5kaWNhdG9yID0gZmFsc2U7XG5cbiAgICBAVmlld0NoaWxkKCdpbmRpY2F0b3InLCB7IHJlYWQ6IEVsZW1lbnRSZWYsIHN0YXRpYzogZmFsc2UgfSlcbiAgICBwdWJsaWMgaW5kaWNhdG9yOiBFbGVtZW50UmVmO1xuXG4gICAgQFZpZXdDaGlsZCgnaW5kZW50YXRpb25EaXYnLCB7IHJlYWQ6IEVsZW1lbnRSZWYsIHN0YXRpYzogZmFsc2UgfSlcbiAgICBwdWJsaWMgaW5kZW50YXRpb25EaXY6IEVsZW1lbnRSZWY7XG5cbiAgICBAVmlld0NoaWxkKCdkZWZhdWx0Q29udGVudEVsZW1lbnQnLCB7IHJlYWQ6IEVsZW1lbnRSZWYsIHN0YXRpYzogZmFsc2UgfSlcbiAgICBwdWJsaWMgZGVmYXVsdENvbnRlbnRFbGVtZW50OiBFbGVtZW50UmVmO1xuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKi9cbiAgIEBWaWV3Q2hpbGQoJ2RlZmF1bHRFeHBhbmRlZFRlbXBsYXRlJywgeyByZWFkOiBUZW1wbGF0ZVJlZiwgc3RhdGljOiB0cnVlIH0pXG4gICBwcm90ZWN0ZWQgZGVmYXVsdEV4cGFuZGVkVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKipcbiAgICAqIEBoaWRkZW5cbiAgICAqL1xuICAgQFZpZXdDaGlsZCgnZGVmYXVsdENvbGxhcHNlZFRlbXBsYXRlJywgeyByZWFkOiBUZW1wbGF0ZVJlZiwgc3RhdGljOiB0cnVlIH0pXG4gICBwcm90ZWN0ZWQgZGVmYXVsdENvbGxhcHNlZFRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGlzTG9hZGluZzogYm9vbGVhbjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgc3VwZXIubmdPbkluaXQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHRvZ2dsZShldmVudDogRXZlbnQpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHRoaXMudHJlZUdyaWRBUEkudHJpZ2dlcl9yb3dfZXhwYW5zaW9uX3RvZ2dsZSh0aGlzLnJvdy50cmVlUm93LCAhdGhpcy5yb3cuZXhwYW5kZWQsIGV2ZW50LCB0aGlzLnZpc2libGVDb2x1bW5JbmRleCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBvbkluZGljYXRvckZvY3VzKCkge1xuICAgICAgICB0aGlzLmdyaWRBUEkuc3VibWl0X3ZhbHVlKCk7XG4gICAgICAgIHRoaXMubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgb25Mb2FkaW5nRGJsQ2xpY2soZXZlbnQ6IEV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgY2FsY3VsYXRlU2l6ZVRvRml0KHJhbmdlOiBhbnkpOiBudW1iZXIge1xuICAgICAgICBjb25zdCBpbmRpY2F0b3JXaWR0aCA9IHRoaXMuaW5kaWNhdG9yLm5hdGl2ZUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgICAgIGNvbnN0IGluZGljYXRvclN0eWxlID0gdGhpcy5kb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuaW5kaWNhdG9yLm5hdGl2ZUVsZW1lbnQpO1xuICAgICAgICBjb25zdCBpbmRpY2F0b3JNYXJnaW4gPSBwYXJzZUZsb2F0KGluZGljYXRvclN0eWxlLm1hcmdpblJpZ2h0KTtcbiAgICAgICAgbGV0IGxlZnRQYWRkaW5nID0gMDtcbiAgICAgICAgaWYgKHRoaXMuaW5kZW50YXRpb25EaXYpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGVudGF0aW9uU3R5bGUgPSB0aGlzLmRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUodGhpcy5pbmRlbnRhdGlvbkRpdi5uYXRpdmVFbGVtZW50KTtcbiAgICAgICAgICAgIGxlZnRQYWRkaW5nID0gcGFyc2VGbG9hdChpbmRlbnRhdGlvblN0eWxlLnBhZGRpbmdMZWZ0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsYXJnZXN0V2lkdGggPSBNYXRoLm1heCguLi5BcnJheS5mcm9tKHRoaXMubmF0aXZlRWxlbWVudC5jaGlsZHJlbilcbiAgICAgICAgICAgIC5tYXAoKGNoaWxkKSA9PiBnZXROb2RlU2l6ZVZpYVJhbmdlKHJhbmdlLCBjaGlsZCkpKTtcbiAgICAgICAgcmV0dXJuIGxhcmdlc3RXaWR0aCArIGluZGljYXRvcldpZHRoICsgaW5kaWNhdG9yTWFyZ2luICsgbGVmdFBhZGRpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICovXG4gICAgcHVibGljIGdldCBpY29uVGVtcGxhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLmV4cGFuZGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ncmlkLnJvd0V4cGFuZGVkSW5kaWNhdG9yVGVtcGxhdGUgfHwgdGhpcy5kZWZhdWx0RXhwYW5kZWRUZW1wbGF0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdyaWQucm93Q29sbGFwc2VkSW5kaWNhdG9yVGVtcGxhdGUgfHwgdGhpcy5kZWZhdWx0Q29sbGFwc2VkVGVtcGxhdGU7XG4gICAgICAgIH1cbiAgICB9XG59XG4iXX0=