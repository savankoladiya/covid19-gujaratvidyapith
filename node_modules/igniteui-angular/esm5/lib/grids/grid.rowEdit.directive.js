/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, ElementRef, HostListener } from '@angular/core';
import { GridBaseAPIService } from './api.service';
/**
 * @hidden
 */
var IgxRowEditTemplateDirective = /** @class */ (function () {
    function IgxRowEditTemplateDirective() {
    }
    IgxRowEditTemplateDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxRowEdit]'
                },] }
    ];
    return IgxRowEditTemplateDirective;
}());
export { IgxRowEditTemplateDirective };
/**
 * @hidden
 */
var IgxRowEditTextDirective = /** @class */ (function () {
    function IgxRowEditTextDirective() {
    }
    IgxRowEditTextDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxRowEditText]'
                },] }
    ];
    return IgxRowEditTextDirective;
}());
export { IgxRowEditTextDirective };
/**
 * @hidden
 */
var IgxRowEditActionsDirective = /** @class */ (function () {
    function IgxRowEditActionsDirective() {
    }
    IgxRowEditActionsDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[igxRowEditActions]'
                },] }
    ];
    return IgxRowEditActionsDirective;
}());
export { IgxRowEditActionsDirective };
// TODO: Refactor circular ref, deps and logic
/**
 * @hidden
 */
var IgxRowEditTabStopDirective = /** @class */ (function () {
    function IgxRowEditTabStopDirective(api, element) {
        var _this = this;
        this.api = api;
        this.element = element;
        /**
         * Sets the cell in edit mode and focus its native element
         * @param cellIndex index of the cell to activate
         */
        this.activateCell = function () {
            /** @type {?} */
            var cell = _this.grid.rowInEditMode.cells.find(function (e) { return e.visibleColumnIndex === _this.currentCellIndex; });
            cell.nativeElement.focus();
            cell.setEditMode(true);
            _this.currentCellIndex = -1;
        };
    }
    Object.defineProperty(IgxRowEditTabStopDirective.prototype, "grid", {
        get: /**
         * @return {?}
         */
        function () {
            return this.api.grid;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} event
     * @return {?}
     */
    IgxRowEditTabStopDirective.prototype.handleTab = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.stopPropagation();
        if ((this.grid.rowEditTabs.last === this && !event.shiftKey) ||
            (this.grid.rowEditTabs.first === this && event.shiftKey)) {
            this.move(event);
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    IgxRowEditTabStopDirective.prototype.handleEscape = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.grid.endEdit(false, event);
        /** @type {?} */
        var activeNode = this.grid.selectionService.activeElement;
        //  on right click activeNode is deleted, so we may have no one
        if (activeNode) {
            /** @type {?} */
            var cell = this.grid.navigation.getCellElementByVisibleIndex(activeNode.row, activeNode.layout ? activeNode.layout.columnVisibleIndex : activeNode.column);
            cell.focus();
        }
    };
    /**
     * Moves focus to first/last editable cell in the editable row and put the cell in edit mode.
     * If cell is out of view first scrolls to the cell
     * @param event keyboard event containing information about whether SHIFT key was pressed
     */
    /**
     * Moves focus to first/last editable cell in the editable row and put the cell in edit mode.
     * If cell is out of view first scrolls to the cell
     * @private
     * @param {?} event keyboard event containing information about whether SHIFT key was pressed
     * @return {?}
     */
    IgxRowEditTabStopDirective.prototype.move = /**
     * Moves focus to first/last editable cell in the editable row and put the cell in edit mode.
     * If cell is out of view first scrolls to the cell
     * @private
     * @param {?} event keyboard event containing information about whether SHIFT key was pressed
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        this.currentCellIndex = event.shiftKey ? this.grid.lastEditableColumnIndex : this.grid.firstEditableColumnIndex;
        if (!this.grid.navigation.isColumnFullyVisible(this.currentCellIndex)) {
            this.grid.navigation.performHorizontalScrollToCell(this.grid.rowInEditMode.index, this.currentCellIndex, false, this.activateCell);
        }
        else {
            this.activateCell();
        }
    };
    IgxRowEditTabStopDirective.decorators = [
        { type: Directive, args: [{
                    selector: "[igxRowEditTabStop]"
                },] }
    ];
    /** @nocollapse */
    IgxRowEditTabStopDirective.ctorParameters = function () { return [
        { type: GridBaseAPIService },
        { type: ElementRef }
    ]; };
    IgxRowEditTabStopDirective.propDecorators = {
        handleTab: [{ type: HostListener, args: ['keydown.Tab', ["$event"],] }, { type: HostListener, args: ['keydown.Shift.Tab', ["$event"],] }],
        handleEscape: [{ type: HostListener, args: ['keydown.Escape', ["$event"],] }]
    };
    return IgxRowEditTabStopDirective;
}());
export { IgxRowEditTabStopDirective };
if (false) {
    /**
     * @type {?}
     * @private
     */
    IgxRowEditTabStopDirective.prototype.currentCellIndex;
    /**
     * Sets the cell in edit mode and focus its native element
     * \@param cellIndex index of the cell to activate
     * @type {?}
     * @private
     */
    IgxRowEditTabStopDirective.prototype.activateCell;
    /** @type {?} */
    IgxRowEditTabStopDirective.prototype.api;
    /** @type {?} */
    IgxRowEditTabStopDirective.prototype.element;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JpZC5yb3dFZGl0LmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvZ3JpZHMvZ3JpZC5yb3dFZGl0LmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsWUFBWSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3BFLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGVBQWUsQ0FBQzs7OztBQUluRDtJQUFBO0lBRzJDLENBQUM7O2dCQUgzQyxTQUFTLFNBQUM7b0JBQ1AsUUFBUSxFQUFFLGNBQWM7aUJBQzNCOztJQUMwQyxrQ0FBQztDQUFBLEFBSDVDLElBRzRDO1NBQS9CLDJCQUEyQjs7OztBQUd4QztJQUFBO0lBR3VDLENBQUM7O2dCQUh2QyxTQUFTLFNBQUM7b0JBQ1AsUUFBUSxFQUFFLGtCQUFrQjtpQkFDL0I7O0lBQ3NDLDhCQUFDO0NBQUEsQUFIeEMsSUFHd0M7U0FBM0IsdUJBQXVCOzs7O0FBR3BDO0lBQUE7SUFHMEMsQ0FBQzs7Z0JBSDFDLFNBQVMsU0FBQztvQkFDUCxRQUFRLEVBQUUscUJBQXFCO2lCQUNsQzs7SUFDeUMsaUNBQUM7Q0FBQSxBQUgzQyxJQUcyQztTQUE5QiwwQkFBMEI7Ozs7O0FBS3ZDO0lBT0ksb0NBQW1CLEdBQTRCLEVBQVMsT0FBbUI7UUFBM0UsaUJBQStFO1FBQTVELFFBQUcsR0FBSCxHQUFHLENBQXlCO1FBQVMsWUFBTyxHQUFQLE9BQU8sQ0FBWTs7Ozs7UUFrRG5FLGlCQUFZLEdBQUc7O2dCQUNiLElBQUksR0FBRyxLQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFVBQUEsQ0FBQyxJQUFJLE9BQUEsQ0FBQyxDQUFDLGtCQUFrQixLQUFLLEtBQUksQ0FBQyxnQkFBZ0IsRUFBOUMsQ0FBOEMsQ0FBQztZQUNwRyxJQUFJLENBQUMsYUFB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aXN0ZW5lciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgR3JpZEJhc2VBUElTZXJ2aWNlIH0gZnJvbSAnLi9hcGkuc2VydmljZSc7XG5pbXBvcnQgeyBHcmlkVHlwZSB9IGZyb20gJy4vY29tbW9uL2dyaWQuaW50ZXJmYWNlJztcblxuLyoqIEBoaWRkZW4gKi9cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW2lneFJvd0VkaXRdJ1xufSlcbmV4cG9ydCBjbGFzcyBJZ3hSb3dFZGl0VGVtcGxhdGVEaXJlY3RpdmUgeyB9XG5cbi8qKiBAaGlkZGVuICovXG5ARGlyZWN0aXZlKHtcbiAgICBzZWxlY3RvcjogJ1tpZ3hSb3dFZGl0VGV4dF0nXG59KVxuZXhwb3J0IGNsYXNzIElneFJvd0VkaXRUZXh0RGlyZWN0aXZlIHsgfVxuXG4vKiogQGhpZGRlbiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbaWd4Um93RWRpdEFjdGlvbnNdJ1xufSlcbmV4cG9ydCBjbGFzcyBJZ3hSb3dFZGl0QWN0aW9uc0RpcmVjdGl2ZSB7IH1cblxuXG4vLyBUT0RPOiBSZWZhY3RvciBjaXJjdWxhciByZWYsIGRlcHMgYW5kIGxvZ2ljXG4vKiogQGhpZGRlbiAqL1xuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6IGBbaWd4Um93RWRpdFRhYlN0b3BdYFxufSlcbmV4cG9ydCBjbGFzcyBJZ3hSb3dFZGl0VGFiU3RvcERpcmVjdGl2ZSB7XG4gICAgcHJpdmF0ZSBjdXJyZW50Q2VsbEluZGV4OiBudW1iZXI7XG5cblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBhcGk6IEdyaWRCYXNlQVBJU2VydmljZTxhbnk+LCBwdWJsaWMgZWxlbWVudDogRWxlbWVudFJlZikge31cblxuICAgIGdldCBncmlkKCk6IEdyaWRUeXBlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBpLmdyaWQ7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcigna2V5ZG93bi5UYWInLCBbYCRldmVudGBdKVxuICAgIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24uU2hpZnQuVGFiJywgW2AkZXZlbnRgXSlcbiAgICBwdWJsaWMgaGFuZGxlVGFiKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBpZiAoKHRoaXMuZ3JpZC5yb3dFZGl0VGFicy5sYXN0ID09PSB0aGlzICYmICFldmVudC5zaGlmdEtleSkgfHxcbiAgICAgICAgICAgICh0aGlzLmdyaWQucm93RWRpdFRhYnMuZmlyc3QgPT09IHRoaXMgJiYgZXZlbnQuc2hpZnRLZXkpXG4gICAgICAgICkge1xuICAgICAgICAgICAgdGhpcy5tb3ZlKGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24uRXNjYXBlJywgW2AkZXZlbnRgXSlcbiAgICBwdWJsaWMgaGFuZGxlRXNjYXBlKGV2ZW50OiBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG4gICAgICAgIHRoaXMuZ3JpZC5lbmRFZGl0KGZhbHNlLCBldmVudCk7XG4gICAgICAgIGNvbnN0IGFjdGl2ZU5vZGUgPSB0aGlzLmdyaWQuc2VsZWN0aW9uU2VydmljZS5hY3RpdmVFbGVtZW50O1xuICAgICAgICAvLyAgb24gcmlnaHQgY2xpY2sgYWN0aXZlTm9kZSBpcyBkZWxldGVkLCBzbyB3ZSBtYXkgaGF2ZSBubyBvbmVcbiAgICAgICAgaWYgKGFjdGl2ZU5vZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNlbGwgPSB0aGlzLmdyaWQubmF2aWdhdGlvbi5nZXRDZWxsRWxlbWVudEJ5VmlzaWJsZUluZGV4KFxuICAgICAgICAgICAgICAgIGFjdGl2ZU5vZGUucm93LFxuICAgICAgICAgICAgICAgIGFjdGl2ZU5vZGUubGF5b3V0ID8gYWN0aXZlTm9kZS5sYXlvdXQuY29sdW1uVmlzaWJsZUluZGV4IDogYWN0aXZlTm9kZS5jb2x1bW4pO1xuICAgICAgICAgICAgY2VsbC5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTW92ZXMgZm9jdXMgdG8gZmlyc3QvbGFzdCBlZGl0YWJsZSBjZWxsIGluIHRoZSBlZGl0YWJsZSByb3cgYW5kIHB1dCB0aGUgY2VsbCBpbiBlZGl0IG1vZGUuXG4gICAgICogSWYgY2VsbCBpcyBvdXQgb2YgdmlldyBmaXJzdCBzY3JvbGxzIHRvIHRoZSBjZWxsXG4gICAgICogQHBhcmFtIGV2ZW50IGtleWJvYXJkIGV2ZW50IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgd2hldGhlciBTSElGVCBrZXkgd2FzIHByZXNzZWRcbiAgICAgKi9cbiAgICBwcml2YXRlIG1vdmUoZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5jdXJyZW50Q2VsbEluZGV4ID0gZXZlbnQuc2hpZnRLZXkgPyB0aGlzLmdyaWQubGFzdEVkaXRhYmxlQ29sdW1uSW5kZXggOiB0aGlzLmdyaWQuZmlyc3RFZGl0YWJsZUNvbHVtbkluZGV4O1xuICAgICAgICBpZiAoIXRoaXMuZ3JpZC5uYXZpZ2F0aW9uLmlzQ29sdW1uRnVsbHlWaXNpYmxlKHRoaXMuY3VycmVudENlbGxJbmRleCkpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JpZC5uYXZpZ2F0aW9uLnBlcmZvcm1Ib3Jpem9udGFsU2Nyb2xsVG9DZWxsKFxuICAgICAgICAgICAgICAgIHRoaXMuZ3JpZC5yb3dJbkVkaXRNb2RlLmluZGV4LCB0aGlzLmN1cnJlbnRDZWxsSW5kZXgsIGZhbHNlLCB0aGlzLmFjdGl2YXRlQ2VsbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2YXRlQ2VsbCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY2VsbCBpbiBlZGl0IG1vZGUgYW5kIGZvY3VzIGl0cyBuYXRpdmUgZWxlbWVudFxuICAgICAqIEBwYXJhbSBjZWxsSW5kZXggaW5kZXggb2YgdGhlIGNlbGwgdG8gYWN0aXZhdGVcbiAgICAgKi9cbiAgICBwcml2YXRlIGFjdGl2YXRlQ2VsbCA9ICgpOiB2b2lkID0+IHtcbiAgICAgICAgY29uc3QgY2VsbCA9IHRoaXMuZ3JpZC5yb3dJbkVkaXRNb2RlLmNlbGxzLmZpbmQoZSA9PiBlLnZpc2libGVDb2x1bW5JbmRleCA9PT0gdGhpcy5jdXJyZW50Q2VsbEluZGV4KTtcbiAgICAgICAgY2VsbC5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIGNlbGwuc2V0RWRpdE1vZGUodHJ1ZSk7XG4gICAgICAgIHRoaXMuY3VycmVudENlbGxJbmRleCA9IC0xO1xuICAgIH1cbn1cbiJdfQ==