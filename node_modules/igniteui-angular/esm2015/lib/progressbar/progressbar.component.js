/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { CommonModule } from '@angular/common';
import { Component, ElementRef, EventEmitter, HostBinding, Input, NgModule, Output, Renderer2, ViewChild, ContentChild } from '@angular/core';
import { IgxProcessBarTextTemplateDirective } from './progressbar.common';
/** @type {?} */
const ONE_PERCENT = 0.01;
/** @type {?} */
const MIN_VALUE = 0;
/** @enum {string} */
const IgxTextAlign = {
    START: 'start',
    CENTER: 'center',
    END: 'end',
};
export { IgxTextAlign };
/** @enum {string} */
const IgxProgressType = {
    DANGER: 'danger',
    INFO: 'info',
    WARNING: 'warning',
    SUCCESS: 'success',
};
export { IgxProgressType };
/**
 * @record
 */
export function IChangeProgressEventArgs() { }
if (false) {
    /** @type {?} */
    IChangeProgressEventArgs.prototype.previousValue;
    /** @type {?} */
    IChangeProgressEventArgs.prototype.currentValue;
}
/**
 * @abstract
 */
export class BaseProgress {
    constructor() {
        /**
         * @hidden
         */
        this.requestAnimationId = undefined;
        /**
         * @hidden
         */
        this._valueInPercent = MIN_VALUE;
        /**
         * @hidden
         */
        this._max = 100;
        /**
         * @hidden
         */
        this._value = MIN_VALUE;
        /**
         * @hidden
         */
        this._animate = true;
    }
    /**
     * Returns the `IgxLinearProgressBarComponent`/`IgxCircularProgressBarComponent` value in percentage.
     * ```typescript
     * \@ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent; // IgxCircularProgressBarComponent
     * public valuePercent(event){
     *    let percentValue = this.progressBar.valueInPercent;
     *    alert(percentValue);
     * }
     * ```
     * @return {?}
     */
    get valueInPercent() {
        return this._valueInPercent;
    }
    /**
     * Sets the `IgxLinearProgressBarComponent`/`IgxCircularProgressBarComponent` value in percentage.
     * ```typescript
     * \@ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent; // IgxCircularProgressBarComponent
     *    public setValue(event){
     *    this.progressBar.valueInPercent = 56;
     * }
     * //...
     * ```
     * ```html
     * <button igxButton="fab" igxRipple="" (click)="setValue()">setValue</button>
     * ```
     * @param {?} value
     * @return {?}
     */
    set valueInPercent(value) {
        this._valueInPercent = value;
    }
    /**
     * @hidden
     * @protected
     * @param {?} val
     * @param {?} step
     * @return {?}
     */
    runAnimation(val, step) {
        this.requestAnimationId = requestAnimationFrame(() => this.updateProgressSmoothly.call(this, val, step));
    }
    /**
     * @hidden
     * @protected
     * @param {?} val
     * @param {?} step
     * @return {?}
     */
    updateProgressSmoothly(val, step) {
        this._value += step;
        /** @type {?} */
        const passedValue = convertInPercentage(val, this._max);
        /** @type {?} */
        const progressValue = convertInPercentage(this._value, this._max);
        if (this.valueInPercent === passedValue) {
            this.updateProgress(val);
            cancelAnimationFrame(this.requestAnimationId);
        }
        else if (this.isInLimitRange(progressValue, passedValue, step)) {
            this.updateProgress(val);
            cancelAnimationFrame(this.requestAnimationId);
        }
        else {
            this.valueInPercent = progressValue;
            this.requestAnimationId = requestAnimationFrame(() => this.updateProgressSmoothly.call(this, val, step));
        }
    }
    /**
     * @hidden
     * @protected
     * @param {?} val
     * @return {?}
     */
    updateProgressDirectly(val) {
        this._value = val;
        this.valueInPercent = convertInPercentage(this._value, this._max);
    }
    /**
     * @hidden
     * @protected
     * @param {?} currentValue
     * @param {?} prevValue
     * @param {?} step
     * @return {?}
     */
    directionFlow(currentValue, prevValue, step) {
        if (currentValue < prevValue) {
            return step;
        }
        return -step;
    }
    /**
     * @hidden
     * @private
     * @param {?} val
     * @param {?} comparator
     * @param {?} step
     * @return {?}
     */
    isInLimitRange(val, comparator, step) {
        return this.isExceedingUpperLimit(val, comparator, step) || this.isExceedingLowerLimit(val, comparator, step);
    }
    /**
     * @hidden
     *
     *
     * @private
     * @param {?} val
     * @param {?} comparator
     * @param {?} step
     * @return {?}
     */
    isExceedingUpperLimit(val, comparator, step) {
        return val > comparator && step > 0;
    }
    /**
     * @hidden
     *
     * @private
     * @param {?} val
     * @param {?} comparator
     * @param {?} step
     * @return {?}
     */
    isExceedingLowerLimit(val, comparator, step) {
        return val < comparator && step < 0;
    }
    /**
     * @hidden
     * @private
     * @param {?} val
     * @return {?}
     */
    updateProgress(val) {
        this._value = val;
        this.valueInPercent = convertInPercentage(this._value, this._max);
    }
}
if (false) {
    /**
     * @hidden
     * @type {?}
     * @private
     */
    BaseProgress.prototype.requestAnimationId;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    BaseProgress.prototype._valueInPercent;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    BaseProgress.prototype._max;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    BaseProgress.prototype._value;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    BaseProgress.prototype._animate;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    BaseProgress.prototype._step;
}
/** @type {?} */
let NEXT_LINEAR_ID = 0;
/** @type {?} */
let NEXT_CIRCULAR_ID = 0;
export class IgxLinearProgressBarComponent extends BaseProgress {
    constructor() {
        super();
        this.valueMin = 0;
        this.cssClass = 'igx-linear-bar';
        /**
         * Set `IgxLinearProgressBarComponent` to have striped style. By default it is set to false.
         * ```html
         * <igx-linear-bar [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
         * ```
         */
        this.striped = false;
        /**
         * Set `IgxLinearProgressBarComponent` to have indeterminate. By default it is set to false.
         * ```html
         * <igx-linear-bar [indeterminate]="true"></igx-linear-bar>
         * ```
         */
        this.indeterminate = false;
        /**
         * An \@Input property that sets the value of the `role` attribute. If not provided it will be automatically set to `progressbar`.
         * ```html
         * <igx-linear-bar role="progressbar"></igx-linear-bar>
         * ```
         */
        this.role = 'progressbar';
        /**
         * An \@Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-linear-bar [id]="'igx-linear-bar-55'" [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
         * ```
         */
        this.id = `igx-linear-bar-${NEXT_LINEAR_ID++}`;
        /**
         * Set the position that defines where the text is aligned.
         * Possible options - `IgxTextAlign.START` (default), `IgxTextAlign.CENTER`, `IgxTextAlign.END`.
         * ```typescript
         * public positionCenter: IgxTextAlign;
         * public ngOnInit() {
         *    this.positionCenter = IgxTextAlign.CENTER;
         * }
         * //...
         * ```
         * ```html
         * <igx-linear-bar type="warning" [text]="'Custom text'" [textAlign]="positionCenter" [striped]="true"></igx-linear-bar>
         * ```
         */
        this.textAlign = IgxTextAlign.START;
        /**
         * Set the text to be visible. By default it is set to true.
         * ```html
         * <igx-linear-bar type="default" [textVisibility]="false"></igx-linear-bar>
         * ```
         */
        this.textVisibility = true;
        /**
         * Set the position that defines if the text should be aligned above the progress line. By default is set to false.
         * ```html
         * <igx-linear-bar type="danger" [textTop]="true"></igx-linear-bar>
         * ```
         */
        this.textTop = false;
        /**
         * Set type of the `IgxLinearProgressBarComponent`. Possible options - `default`, `success`, `info`, `warning`, and `danger`.
         * ```html
         * <igx-linear-bar [striped]="false" [max]="100" [value]="0" type="danger"></igx-linear-bar>
         * ```
         */
        this.type = 'default';
        /**
         * An event, which is triggered after a progress is changed.
         * ```typescript
         * public progressChange(event) {
         *    alert("Progress made!");
         * }
         * //...
         * ```
         * ```html
         * <igx-linear-bar (onProgressChanged)="progressChange($event)" type="success">
         * ```
         */
        this.onProgressChanged = new EventEmitter();
    }
    /**
     * Animation on progress `IgxLinearProgressBarComponent`. By default it is set to true.
     * ```html
     * <igx-linear-bar [animate]="false" [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
     * ```
     * @param {?} animate
     * @return {?}
     */
    set animate(animate) {
        this._animate = animate;
    }
    /**
     * Returns whether the `IgxLinearProgressBarComponent` has animation true/false.
     * ```typescript
     * \@ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent;
     * public animationStatus(event) {
     *    let animationStatus = this.progressBar.animate;
     *    alert(animationStatus);
     * }
     * ```
     * @return {?}
     */
    get animate() {
        return this._animate;
    }
    /**
     * Set maximum value that can be passed. By default it is set to 100.
     * ```html
     * <igx-linear-bar [striped]="false" [max]="200" [value]="0"></igx-linear-bar>
     * ```
     * @param {?} maxNum
     * @return {?}
     */
    set max(maxNum) {
        this._max = maxNum;
    }
    /**
     * Returns the the maximum progress value of the `IgxLinearProgressBarComponent`.
     * ```typescript
     * \@ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent;
     * public maxValue(event) {
     *    let max = this.progressBar.max;
     *    alert(max);
     * }
     * ```
     * @return {?}
     */
    get max() {
        return this._max;
    }
    /**
     * Returns the value which update the progress indicator of the `IgxLinearProgressBarComponent`.
     * ```typescript
     * \@ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent;
     * public stepValue(event) {
     *    let step = this.progressBar.step;
     *    alert(step);
     * }
     * ```
     * @return {?}
     */
    get step() {
        if (this._step) {
            return this._step;
        }
        return this._max * ONE_PERCENT;
    }
    /**
     * Sets the value by which progress indicator is updated. By default it is 1% of the maximum value.
     * ```html
     * <igx-linear-bar [striped]="false" [max]="200" [value]="0" [step]="1"></igx-linear-bar>
     * ```
     * @param {?} val
     * @return {?}
     */
    set step(val) {
        this._step = Number(val);
    }
    /**
     * Returns value that indicates the current `IgxLinearProgressBarComponent` position.
     * ```typescript
     * \@ViewChild("MyProgressBar")
     * public progressBar: IgxLinearProgressBarComponent;
     * public getValue(event) {
     *    let value = this.progressBar.value;
     *    alert(value);
     * }
     * ```
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * Set value that indicates the current `IgxLinearProgressBarComponent` position.
     * ```html
     * <igx-linear-bar [striped]="false" [max]="200" [value]="50"></igx-linear-bar>
     * ```
     * @param {?} val
     * @return {?}
     */
    set value(val) {
        val = Number(val);
        if (this._value === val || this.indeterminate) {
            return;
        }
        /** @type {?} */
        const valueInRange = getValueInProperRange(val, this.max);
        if (isNaN(valueInRange)) {
            return;
        }
        /** @type {?} */
        const changedValues = {
            currentValue: valueInRange,
            previousValue: this._value
        };
        /** @type {?} */
        const updateValue = super.directionFlow(this._value, val, this.step);
        if (this._animate && val >= this.step) {
            super.runAnimation(valueInRange, updateValue);
        }
        else {
            super.updateProgressDirectly(valueInRange);
        }
        this.onProgressChanged.emit(changedValues);
    }
    /**
     * @hidden
     * @return {?}
     */
    get danger() {
        return this.type === IgxProgressType.DANGER;
    }
    /**
     * @hidden
     * @return {?}
     */
    get info() {
        return this.type === IgxProgressType.INFO;
    }
    /**
     * @hidden
     * @return {?}
     */
    get warning() {
        return this.type === IgxProgressType.WARNING;
    }
    /**
     * @hidden
     * @return {?}
     */
    get success() {
        return this.type === IgxProgressType.SUCCESS;
    }
}
IgxLinearProgressBarComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-linear-bar',
                template: "<div class=\"igx-linear-bar__base\">\n    <div class=\"igx-linear-bar__indicator\"\n    [style.width.%]=\"valueInPercent\"></div>\n</div>\n\n<span\n    class=\"igx-linear-bar__value\"\n    [ngClass]=\"{\n        'igx-linear-bar__value--start': textAlign === 'start',\n        'igx-linear-bar__value--center': textAlign === 'center',\n        'igx-linear-bar__value--end': textAlign === 'end',\n        'igx-linear-bar__value--top': textTop,\n        'igx-linear-bar__value--hidden': !textVisibility\n    }\">\n        {{text ? text : valueInPercent + '%'}}\n</span>\n"
            }] }
];
/** @nocollapse */
IgxLinearProgressBarComponent.ctorParameters = () => [];
IgxLinearProgressBarComponent.propDecorators = {
    animate: [{ type: Input }],
    max: [{ type: HostBinding, args: ['attr.aria-valuemax',] }, { type: Input }],
    step: [{ type: Input }],
    valueMin: [{ type: HostBinding, args: ['attr.aria-valuemin',] }],
    cssClass: [{ type: HostBinding, args: ['class.igx-linear-bar',] }],
    striped: [{ type: HostBinding, args: ['class.igx-linear-bar--striped',] }, { type: Input }],
    indeterminate: [{ type: HostBinding, args: ['class.igx-linear-bar--indeterminate',] }, { type: Input }],
    role: [{ type: HostBinding, args: ['attr.role',] }, { type: Input }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    textAlign: [{ type: Input }],
    textVisibility: [{ type: Input }],
    textTop: [{ type: Input }],
    text: [{ type: Input }],
    type: [{ type: Input }],
    value: [{ type: HostBinding, args: ['attr.aria-valuenow',] }, { type: Input }],
    onProgressChanged: [{ type: Output }],
    danger: [{ type: HostBinding, args: ['class.igx-linear-bar--danger',] }],
    info: [{ type: HostBinding, args: ['class.igx-linear-bar--info',] }],
    warning: [{ type: HostBinding, args: ['class.igx-linear-bar--warning',] }],
    success: [{ type: HostBinding, args: ['class.igx-linear-bar--success',] }]
};
if (false) {
    /** @type {?} */
    IgxLinearProgressBarComponent.prototype.valueMin;
    /** @type {?} */
    IgxLinearProgressBarComponent.prototype.cssClass;
    /**
     * Set `IgxLinearProgressBarComponent` to have striped style. By default it is set to false.
     * ```html
     * <igx-linear-bar [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
     * ```
     * @type {?}
     */
    IgxLinearProgressBarComponent.prototype.striped;
    /**
     * Set `IgxLinearProgressBarComponent` to have indeterminate. By default it is set to false.
     * ```html
     * <igx-linear-bar [indeterminate]="true"></igx-linear-bar>
     * ```
     * @type {?}
     */
    IgxLinearProgressBarComponent.prototype.indeterminate;
    /**
     * An \@Input property that sets the value of the `role` attribute. If not provided it will be automatically set to `progressbar`.
     * ```html
     * <igx-linear-bar role="progressbar"></igx-linear-bar>
     * ```
     * @type {?}
     */
    IgxLinearProgressBarComponent.prototype.role;
    /**
     * An \@Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
     * ```html
     * <igx-linear-bar [id]="'igx-linear-bar-55'" [striped]="true" [max]="200" [value]="50"></igx-linear-bar>
     * ```
     * @type {?}
     */
    IgxLinearProgressBarComponent.prototype.id;
    /**
     * Set the position that defines where the text is aligned.
     * Possible options - `IgxTextAlign.START` (default), `IgxTextAlign.CENTER`, `IgxTextAlign.END`.
     * ```typescript
     * public positionCenter: IgxTextAlign;
     * public ngOnInit() {
     *    this.positionCenter = IgxTextAlign.CENTER;
     * }
     * //...
     * ```
     * ```html
     * <igx-linear-bar type="warning" [text]="'Custom text'" [textAlign]="positionCenter" [striped]="true"></igx-linear-bar>
     * ```
     * @type {?}
     */
    IgxLinearProgressBarComponent.prototype.textAlign;
    /**
     * Set the text to be visible. By default it is set to true.
     * ```html
     * <igx-linear-bar type="default" [textVisibility]="false"></igx-linear-bar>
     * ```
     * @type {?}
     */
    IgxLinearProgressBarComponent.prototype.textVisibility;
    /**
     * Set the position that defines if the text should be aligned above the progress line. By default is set to false.
     * ```html
     * <igx-linear-bar type="danger" [textTop]="true"></igx-linear-bar>
     * ```
     * @type {?}
     */
    IgxLinearProgressBarComponent.prototype.textTop;
    /**
     * Set a custom text that is displayed according to the defined position.
     * ```html
     * <igx-linear-bar type="warning" [text]="'Custom text'" [textAlign]="positionCenter" [striped]="true"></igx-linear-bar>
     * ```
     * @type {?}
     */
    IgxLinearProgressBarComponent.prototype.text;
    /**
     * Set type of the `IgxLinearProgressBarComponent`. Possible options - `default`, `success`, `info`, `warning`, and `danger`.
     * ```html
     * <igx-linear-bar [striped]="false" [max]="100" [value]="0" type="danger"></igx-linear-bar>
     * ```
     * @type {?}
     */
    IgxLinearProgressBarComponent.prototype.type;
    /**
     * An event, which is triggered after a progress is changed.
     * ```typescript
     * public progressChange(event) {
     *    alert("Progress made!");
     * }
     * //...
     * ```
     * ```html
     * <igx-linear-bar (onProgressChanged)="progressChange($event)" type="success">
     * ```
     * @type {?}
     */
    IgxLinearProgressBarComponent.prototype.onProgressChanged;
}
export class IgxCircularProgressBarComponent extends BaseProgress {
    /**
     * @param {?} renderer
     */
    constructor(renderer) {
        super();
        this.renderer = renderer;
        this.STROKE_OPACITY_DVIDER = 100;
        this.STROKE_OPACITY_ADDITION = .2;
        /**
         * @hidden
         */
        this.cssClass = 'igx-circular-bar';
        /**
         * An event, which is triggered after a progress is changed.
         * ```typescript
         * public progressChange(event) {
         *    alert("Progress made!");
         * }
         * //...
         * ```
         * ```html
         * <igx-circular-bar [value]="currentValue" (onProgressChanged)="progressChange($event)"></igx-circular-bar>
         * ```
         */
        this.onProgressChanged = new EventEmitter();
        /**
         * An \@Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
         * ```html
         * <igx-circular-bar [id]="'igx-circular-bar-55'" [value]="50"></igx-circular-bar>
         * ```
         */
        this.id = `igx-circular-bar-${NEXT_CIRCULAR_ID++}`;
        /**
         * An \@Input property that sets the value of the `indeterminate` attribute. If not provided it will be automatically set to false.
         * ```html
         * <igx-circular-bar [indeterminate]="true"></igx-circular-bar>
         * ```
         */
        this.indeterminate = false;
        /**
         * Sets the text visibility. By default it is set to true.
         * ```html
         * <igx-circular-bar [textVisibility]="false"></igx-circular-bar>
         * ```
         */
        this.textVisibility = true;
        this._circleRadius = 46;
        this._circumference = 2 * Math.PI * this._circleRadius;
    }
    /**
     * @hidden
     * @return {?}
     */
    get context() {
        return {
            $implicit: { value: this.value, valueInPercent: this.valueInPercent, max: this.max }
        };
    }
    /**
     * Animation on progress `IgxCircularProgressBarComponent`. By default it is set to true.
     * ```html
     * <igx-circular-bar [animate]="false" [value]="50"></igx-circular-bar>
     * ```
     * @param {?} animate
     * @return {?}
     */
    set animate(animate) {
        this._animate = animate;
    }
    /**
     * Returns whether the `IgxCircularProgressBarComponent` has animation true/false.
     * ```typescript
     * \@ViewChild("MyProgressBar")
     * public progressBar: IgxCircularProgressBarComponent;
     * public animationStatus(event) {
     *    let animationStatus = this.progressBar.animate;
     *    alert(animationStatus);
     * }
     * ```
     * @return {?}
     */
    get animate() {
        return this._animate;
    }
    /**
     * Set maximum value that can be passed. By default it is set to 100.
     * ```html
     * <igx-circular-bar [max]="200" [value]="0"></igx-circular-bar>
     * ```
     * @param {?} maxNum
     * @return {?}
     */
    set max(maxNum) {
        this._max = maxNum;
    }
    /**
     * Returns the the maximum progress value of the `IgxCircularProgressBarComponent`.
     * ```typescript
     * \@ViewChild("MyProgressBar")
     * public progressBar: IgxCircularProgressBarComponent;
     * public maxValue(event) {
     *    let max = this.progressBar.max;
     *    alert(max);
     * }
     * ```
     * ```html
     * <igx-circular-bar [max]="245" [animate]="false" [value]="currentValue"></igx-circular-bar>
     * ```
     * @return {?}
     */
    get max() {
        return this._max;
    }
    /**
     * Returns the value which update the progress indicator of the `IgxCircularProgressBarComponent`.
     * ```typescript
     * \@ViewChild("MyProgressBar")
     * public progressBar: IgxCircularProgressBarComponent;
     * public stepValue(event) {
     *    let step = this.progressBar.step;
     *    alert(step);
     * }
     * ```
     * @return {?}
     */
    get step() {
        if (this._step) {
            return this._step;
        }
        return this._max * ONE_PERCENT;
    }
    /**
     * Sets the value by which progress indicator is updated. By default it is 1% of the maximum value.
     * ```html
     * <igx-circular-bar [striped]="false" [max]="200" [value]="0" [step]="1"></igx-circular-bar>
     * ```
     * @param {?} val
     * @return {?}
     */
    set step(val) {
        this._step = Number(val);
    }
    /**
     * Returns value that indicates the current `IgxCircularProgressBarComponent` position.
     * ```typescript
     * \@ViewChild("MyProgressBar")
     * public progressBar: IgxCircularProgressBarComponent;
     * public getValue(event) {
     *    let value = this.progressBar.value;
     *    alert(value);
     * }
     * ```
     * ```html
     * <button igxButton="fab" igxRipple="" (click)="getValue()">Click</button>
     * ```
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * Set value that indicates the current `IgxCircularProgressBarComponent` position.
     * ```html
     * <igx-circular-bar [value]="50"></igx-circular-bar>
     * ```
     * @param {?} val
     * @return {?}
     */
    set value(val) {
        val = Number(val);
        if (this._value === val || this.indeterminate) {
            return;
        }
        /** @type {?} */
        const valueInProperRange = getValueInProperRange(val, this.max);
        if (isNaN(valueInProperRange)) {
            return;
        }
        /** @type {?} */
        const changedValues = {
            currentValue: valueInProperRange,
            previousValue: this._value
        };
        /** @type {?} */
        const updateValue = super.directionFlow(this._value, val, this.step);
        if (this.animate && val >= this.step) {
            super.runAnimation(valueInProperRange, updateValue);
        }
        else {
            this.updateProgressDirectly(valueInProperRange);
        }
        this.onProgressChanged.emit(changedValues);
    }
    /**
     * @hidden
     * @param {?} val
     * @param {?} step
     * @return {?}
     */
    updateProgressSmoothly(val, step) {
        // Set frames for the animation
        /** @type {?} */
        const FRAMES = [{
                strokeDashoffset: this.getProgress(this._value),
                strokeOpacity: (this._value / this.STROKE_OPACITY_DVIDER) + this.STROKE_OPACITY_ADDITION
            }, {
                strokeDashoffset: this.getProgress(this.valueInPercent),
                strokeOpacity: (this.valueInPercent / this.STROKE_OPACITY_DVIDER) + this.STROKE_OPACITY_ADDITION
            }];
        this._svgCircle.nativeElement.animate(FRAMES, {
            easing: 'ease-out',
            fill: 'forwards'
        });
        super.updateProgressSmoothly(val, step);
    }
    /**
     * @hidden
     * @return {?}
     */
    get textContent() {
        return this.text;
    }
    /**
     * @hidden
     * @param {?} val
     * @return {?}
     */
    updateProgressDirectly(val) {
        super.updateProgressDirectly(val);
        this.renderer.setStyle(this._svgCircle.nativeElement, 'stroke-dashoffset', this.getProgress(this.valueInPercent));
        this.renderer.setStyle(this._svgCircle.nativeElement, 'stroke-opacity', (this.valueInPercent / this.STROKE_OPACITY_DVIDER) + this.STROKE_OPACITY_ADDITION);
    }
    /**
     * @private
     * @param {?} percentage
     * @return {?}
     */
    getProgress(percentage) {
        // Reverse the sign here: '-' should become '+' in RTL mode
        return this._circumference - (percentage * this._circumference / 100);
    }
}
IgxCircularProgressBarComponent.decorators = [
    { type: Component, args: [{
                selector: 'igx-circular-bar',
                template: "<svg #svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\"\n    viewBox=\"0 0 100 100\"\n    preserveAspectRatio=\"xMidYMid meet\"\n    role=\"progressbar\"\n    aria-valuemin=\"0\"\n    [attr.aria-valuemax]=\"max\"\n    [attr.aria-valuenow]=\"value\">\n    <circle class=\"igx-circular-bar__inner\" cx=\"50\" cy=\"50\" r=\"46\" />\n    <circle #circle class=\"igx-circular-bar__outer\" cx=\"50\" cy=\"50\" r=\"46\" />\n    <text *ngIf=\"textVisibility\" text-anchor=\"middle\" x=\"50\" y=\"60\">\n        <ng-container *ngTemplateOutlet=\"textTemplate ? textTemplate.template : defaultTextTemplate; context: context\">\n        </ng-container>\n    </text>\n\n    <ng-template #defaultTextTemplate>\n        <tspan class=\"igx-circular-bar__text\"> {{textContent ? textContent: valueInPercent + '%'}}</tspan>\n    </ng-template>\n</svg>\n"
            }] }
];
/** @nocollapse */
IgxCircularProgressBarComponent.ctorParameters = () => [
    { type: Renderer2 }
];
IgxCircularProgressBarComponent.propDecorators = {
    cssClass: [{ type: HostBinding, args: ['class.igx-circular-bar',] }],
    onProgressChanged: [{ type: Output }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    indeterminate: [{ type: HostBinding, args: ['class.igx-circular-bar--indeterminate',] }, { type: Input }],
    textVisibility: [{ type: Input }],
    text: [{ type: Input }],
    textTemplate: [{ type: ContentChild, args: [IgxProcessBarTextTemplateDirective, { read: IgxProcessBarTextTemplateDirective, static: false },] }],
    animate: [{ type: Input }],
    max: [{ type: Input }],
    step: [{ type: Input }],
    value: [{ type: Input }],
    _svgCircle: [{ type: ViewChild, args: ['circle', { static: true },] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    IgxCircularProgressBarComponent.prototype.STROKE_OPACITY_DVIDER;
    /**
     * @type {?}
     * @private
     */
    IgxCircularProgressBarComponent.prototype.STROKE_OPACITY_ADDITION;
    /**
     * @hidden
     * @type {?}
     */
    IgxCircularProgressBarComponent.prototype.cssClass;
    /**
     * An event, which is triggered after a progress is changed.
     * ```typescript
     * public progressChange(event) {
     *    alert("Progress made!");
     * }
     * //...
     * ```
     * ```html
     * <igx-circular-bar [value]="currentValue" (onProgressChanged)="progressChange($event)"></igx-circular-bar>
     * ```
     * @type {?}
     */
    IgxCircularProgressBarComponent.prototype.onProgressChanged;
    /**
     * An \@Input property that sets the value of `id` attribute. If not provided it will be automatically generated.
     * ```html
     * <igx-circular-bar [id]="'igx-circular-bar-55'" [value]="50"></igx-circular-bar>
     * ```
     * @type {?}
     */
    IgxCircularProgressBarComponent.prototype.id;
    /**
     * An \@Input property that sets the value of the `indeterminate` attribute. If not provided it will be automatically set to false.
     * ```html
     * <igx-circular-bar [indeterminate]="true"></igx-circular-bar>
     * ```
     * @type {?}
     */
    IgxCircularProgressBarComponent.prototype.indeterminate;
    /**
     * Sets the text visibility. By default it is set to true.
     * ```html
     * <igx-circular-bar [textVisibility]="false"></igx-circular-bar>
     * ```
     * @type {?}
     */
    IgxCircularProgressBarComponent.prototype.textVisibility;
    /**
     * Sets/gets the text to be displayed inside the `igxCircularBar`.
     * ```html
     * <igx-circular-bar text="Progress"></igx-circular-bar>
     * ```
     * ```typescript
     * let text = this.circularBar.text;
     * ```
     * @type {?}
     */
    IgxCircularProgressBarComponent.prototype.text;
    /** @type {?} */
    IgxCircularProgressBarComponent.prototype.textTemplate;
    /**
     * @type {?}
     * @private
     */
    IgxCircularProgressBarComponent.prototype._circleRadius;
    /**
     * @type {?}
     * @private
     */
    IgxCircularProgressBarComponent.prototype._circumference;
    /**
     * @type {?}
     * @private
     */
    IgxCircularProgressBarComponent.prototype._svgCircle;
    /**
     * @type {?}
     * @private
     */
    IgxCircularProgressBarComponent.prototype.renderer;
}
/**
 * @param {?} value
 * @param {?} max
 * @param {?=} min
 * @return {?}
 */
export function getValueInProperRange(value, max, min = 0) {
    return Math.max(Math.min(value, max), min);
}
/**
 * @param {?} value
 * @param {?} max
 * @return {?}
 */
export function convertInPercentage(value, max) {
    return Math.floor(100 * value / max);
}
/**
 * @hidden
 */
export class IgxProgressBarModule {
}
IgxProgressBarModule.decorators = [
    { type: NgModule, args: [{
                declarations: [IgxLinearProgressBarComponent, IgxCircularProgressBarComponent, IgxProcessBarTextTemplateDirective],
                exports: [IgxLinearProgressBarComponent, IgxCircularProgressBarComponent, IgxProcessBarTextTemplateDirective],
                imports: [CommonModule]
            },] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvZ3Jlc3NiYXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vaWduaXRldWktYW5ndWxhci8iLCJzb3VyY2VzIjpbImxpYi9wcm9ncmVzc2Jhci9wcm9ncmVzc2Jhci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMvQyxPQUFPLEVBQ0gsU0FBUyxFQUNULFVBQVUsRUFDVixZQUFZLEVBQ1osV0FBVyxFQUNYLEtBQUssRUFDTCxRQUFRLEVBQ1IsTUFBTSxFQUNOLFNBQVMsRUFDVCxTQUFTLEVBQ1QsWUFBWSxFQUNmLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxrQ0FBa0MsRUFBRSxNQUFNLHNCQUFzQixDQUFDOztNQUdwRSxXQUFXLEdBQUcsSUFBSTs7TUFDbEIsU0FBUyxHQUFHLENBQUM7OztJQUdmLE9BQVEsT0FBTztJQUNmLFFBQVMsUUFBUTtJQUNqQixLQUFNLEtBQUs7Ozs7O0lBSVgsUUFBUyxRQUFRO0lBQ2pCLE1BQU8sTUFBTTtJQUNiLFNBQVUsU0FBUztJQUNuQixTQUFVLFNBQVM7Ozs7OztBQUd2Qiw4Q0FHQzs7O0lBRkcsaURBQXNCOztJQUN0QixnREFBcUI7Ozs7O0FBR3pCLE1BQU0sT0FBZ0IsWUFBWTtJQUFsQzs7OztRQUlZLHVCQUFrQixHQUFXLFNBQVMsQ0FBQzs7OztRQUtyQyxvQkFBZSxHQUFHLFNBQVMsQ0FBQzs7OztRQUk1QixTQUFJLEdBQUcsR0FBRyxDQUFDOzs7O1FBSVgsV0FBTSxHQUFHLFNBQVMsQ0FBQzs7OztRQUluQixhQUFRLEdBQUcsSUFBSSxDQUFDO0lBNEg5QixDQUFDOzs7Ozs7Ozs7Ozs7O0lBMUdHLElBQVcsY0FBYztRQUNyQixPQUFPLElBQUksQ0FBQyxlQUFlLENBQUM7SUFDaEMsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFnQkQsSUFBVyxjQUFjLENBQUMsS0FBYTtRQUNuQyxJQUFJ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QUFFLElBQUksRUFBRTs7Ozs7OztJQXROckMsZ0VBQTZDOzs7OztJQUM3QyxrRUFBOEM7Ozs7O0lBRzlDLG1EQUNxQzs7Ozs7Ozs7Ozs7Ozs7SUFjckMsNERBQ3dFOzs7Ozs7OztJQVF4RSw2Q0FFcUQ7Ozs7Ozs7O0lBUXJELHdEQUU2Qjs7Ozs7Ozs7SUFRN0IseURBQzZCOzs7Ozs7Ozs7OztJQVc3QiwrQ0FDb0I7O0lBRXBCLHVEQUN3RDs7Ozs7SUFtSnhELHdEQUEyQjs7Ozs7SUFDM0IseURBQTBEOzs7OztJQUUxRCxxREFBc0U7Ozs7O0lBRTFELG1EQUEyQjs7Ozs7Ozs7QUFzRDNDLE1BQU0sVUFBVSxxQkFBcUIsQ0FBQyxLQUFhLEVBQUUsR0FBVyxFQUFFLEdBQUcsR0FBRyxDQUFDO0lBQ3JFLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUMsRUFBRSxHQUFHLENBQUMsQ0FBQztBQUMvQyxDQUFDOzs7Ozs7QUFFRCxNQUFNLFVBQVUsbUJBQW1CLENBQUMsS0FBYSxFQUFFLEdBQVc7SUFDMUQsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBRyxLQUFLLEdBQUcsR0FBRyxDQUFDLENBQUM7QUFDekMsQ0FBQzs7OztBQVVELE1BQU0sT0FBTyxvQkFBb0I7OztZQUxoQyxRQUFRLFNBQUM7Z0JBQ04sWUFBWSxFQUFFLENBQUMsNkJBQTZCLEVBQUUsK0JBQStCLEVBQUUsa0NBQWtDLENBQUM7Z0JBQ2xILE9BQU8sRUFBRSxDQUFDLDZCQUE2QixFQUFFLCtCQUErQixFQUFFLGtDQUFrQyxDQUFDO2dCQUM3RyxPQUFPLEVBQUUsQ0FBQyxZQUFZLENBQUM7YUFDMUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtcbiAgICBDb21wb25lbnQsXG4gICAgRWxlbWVudFJlZixcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgSG9zdEJpbmRpbmcsXG4gICAgSW5wdXQsXG4gICAgTmdNb2R1bGUsXG4gICAgT3V0cHV0LFxuICAgIFJlbmRlcmVyMixcbiAgICBWaWV3Q2hpbGQsXG4gICAgQ29udGVudENoaWxkXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSWd4UHJvY2Vzc0JhclRleHRUZW1wbGF0ZURpcmVjdGl2ZSB9IGZyb20gJy4vcHJvZ3Jlc3NiYXIuY29tbW9uJztcbmltcG9ydCB7IElCYXNlRXZlbnRBcmdzIH0gZnJvbSAnLi4vY29yZS91dGlscyc7XG5cbmNvbnN0IE9ORV9QRVJDRU5UID0gMC4wMTtcbmNvbnN0IE1JTl9WQUxVRSA9IDA7XG5cbmV4cG9ydCBlbnVtIElneFRleHRBbGlnbiB7XG4gICAgU1RBUlQgPSAnc3RhcnQnLFxuICAgIENFTlRFUiA9ICdjZW50ZXInLFxuICAgIEVORCA9ICdlbmQnXG59XG5cbmV4cG9ydCBlbnVtIElneFByb2dyZXNzVHlwZSB7XG4gICAgREFOR0VSID0gJ2RhbmdlcicsXG4gICAgSU5GTyA9ICdpbmZvJyxcbiAgICBXQVJOSU5HID0gJ3dhcm5pbmcnLFxuICAgIFNVQ0NFU1MgPSAnc3VjY2Vzcydcbn1cblxuZXhwb3J0IGludGVyZmFjZSBJQ2hhbmdlUHJvZ3Jlc3NFdmVudEFyZ3MgZXh0ZW5kcyBJQmFzZUV2ZW50QXJncyB7XG4gICAgcHJldmlvdXNWYWx1ZTogbnVtYmVyO1xuICAgIGN1cnJlbnRWYWx1ZTogbnVtYmVyO1xufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZVByb2dyZXNzIHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJpdmF0ZSByZXF1ZXN0QW5pbWF0aW9uSWQ6IG51bWJlciA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX3ZhbHVlSW5QZXJjZW50ID0gTUlOX1ZBTFVFO1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX21heCA9IDEwMDtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF92YWx1ZSA9IE1JTl9WQUxVRTtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIF9hbmltYXRlID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgX3N0ZXA7XG5cbiAgICAvKipcbiAgICAgKlJldHVybnMgdGhlIGBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudGAvYElneENpcmN1bGFyUHJvZ3Jlc3NCYXJDb21wb25lbnRgIHZhbHVlIGluIHBlcmNlbnRhZ2UuXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICpAVmlld0NoaWxkKFwiTXlQcm9ncmVzc0JhclwiKVxuICAgICAqcHVibGljIHByb2dyZXNzQmFyOiBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudDsgLy8gSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudFxuICAgICAqcHVibGljIHZhbHVlUGVyY2VudChldmVudCl7XG4gICAgICogICAgbGV0IHBlcmNlbnRWYWx1ZSA9IHRoaXMucHJvZ3Jlc3NCYXIudmFsdWVJblBlcmNlbnQ7XG4gICAgICogICAgYWxlcnQocGVyY2VudFZhbHVlKTtcbiAgICAgKn1cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgdmFsdWVJblBlcmNlbnQoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlSW5QZXJjZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqU2V0cyB0aGUgYElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50YC9gSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudGAgdmFsdWUgaW4gcGVyY2VudGFnZS5cbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKkBWaWV3Q2hpbGQoXCJNeVByb2dyZXNzQmFyXCIpXG4gICAgICpwdWJsaWMgcHJvZ3Jlc3NCYXI6IElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50OyAvLyBJZ3hDaXJjdWxhclByb2dyZXNzQmFyQ29tcG9uZW50XG4gICAgICogICAgcHVibGljIHNldFZhbHVlKGV2ZW50KXtcbiAgICAgKiAgICB0aGlzLnByb2dyZXNzQmFyLnZhbHVlSW5QZXJjZW50ID0gNTY7XG4gICAgICp9XG4gICAgICogLy8uLi5cbiAgICAgKmBgYFxuICAgICAqYGBgaHRtbFxuICAgICAqPGJ1dHRvbiBpZ3hCdXR0b249XCJmYWJcIiBpZ3hSaXBwbGU9XCJcIiAoY2xpY2spPVwic2V0VmFsdWUoKVwiPnNldFZhbHVlPC9idXR0b24+XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgc2V0IHZhbHVlSW5QZXJjZW50KHZhbHVlOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fdmFsdWVJblBlcmNlbnQgPSB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHJ1bkFuaW1hdGlvbih2YWw6IG51bWJlciwgc3RlcDogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKFxuICAgICAgICAgICAgKCkgPT4gdGhpcy51cGRhdGVQcm9ncmVzc1Ntb290aGx5LmNhbGwodGhpcywgdmFsLCBzdGVwKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCB1cGRhdGVQcm9ncmVzc1Ntb290aGx5KHZhbDogbnVtYmVyLCBzdGVwOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgKz0gc3RlcDtcbiAgICAgICAgY29uc3QgcGFzc2VkVmFsdWUgPSBjb252ZXJ0SW5QZXJjZW50YWdlKHZhbCwgdGhpcy5fbWF4KTtcbiAgICAgICAgY29uc3QgcHJvZ3Jlc3NWYWx1ZSA9IGNvbnZlcnRJblBlcmNlbnRhZ2UodGhpcy5fdmFsdWUsIHRoaXMuX21heCk7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlSW5QZXJjZW50ID09PSBwYXNzZWRWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVQcm9ncmVzcyh2YWwpO1xuICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yZXF1ZXN0QW5pbWF0aW9uSWQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNJbkxpbWl0UmFuZ2UocHJvZ3Jlc3NWYWx1ZSwgcGFzc2VkVmFsdWUsIHN0ZXApKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVByb2dyZXNzKHZhbCk7XG4gICAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJlcXVlc3RBbmltYXRpb25JZCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlSW5QZXJjZW50ID0gcHJvZ3Jlc3NWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHRoaXMudXBkYXRlUHJvZ3Jlc3NTbW9vdGhseS5jYWxsKHRoaXMsIHZhbCwgc3RlcCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCB1cGRhdGVQcm9ncmVzc0RpcmVjdGx5KHZhbDogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsO1xuICAgICAgICB0aGlzLnZhbHVlSW5QZXJjZW50ID0gY29udmVydEluUGVyY2VudGFnZSh0aGlzLl92YWx1ZSwgdGhpcy5fbWF4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJvdGVjdGVkIGRpcmVjdGlvbkZsb3coY3VycmVudFZhbHVlOiBudW1iZXIsIHByZXZWYWx1ZTogbnVtYmVyLCBzdGVwOiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICBpZiAoY3VycmVudFZhbHVlIDwgcHJldlZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RlcDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAtc3RlcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHJpdmF0ZSBpc0luTGltaXRSYW5nZSh2YWw6IG51bWJlciwgY29tcGFyYXRvcjogbnVtYmVyLCBzdGVwOiBudW1iZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNFeGNlZWRpbmdVcHBlckxpbWl0KHZhbCwgY29tcGFyYXRvciwgc3RlcCkgfHwgdGhpcy5pc0V4Y2VlZGluZ0xvd2VyTGltaXQodmFsLCBjb21wYXJhdG9yLCBzdGVwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWxcbiAgICAgKiBAcGFyYW0gY29tcGFyYXRvclxuICAgICAqIEBwYXJhbSBzdGVwXG4gICAgICovXG4gICAgcHJpdmF0ZSBpc0V4Y2VlZGluZ1VwcGVyTGltaXQodmFsOiBudW1iZXIsIGNvbXBhcmF0b3I6IG51bWJlciwgc3RlcDogbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB2YWwgPiBjb21wYXJhdG9yICYmIHN0ZXAgPiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWxcbiAgICAgKiBAcGFyYW0gY29tcGFyYXRvclxuICAgICAqIEBwYXJhbSBzdGVwXG4gICAgICovXG4gICAgcHJpdmF0ZSBpc0V4Y2VlZGluZ0xvd2VyTGltaXQodmFsOiBudW1iZXIsIGNvbXBhcmF0b3I6IG51bWJlciwgc3RlcDogbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB2YWwgPCBjb21wYXJhdG9yICYmIHN0ZXAgPCAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAcGFyYW0gc3RlcFxuICAgICAqL1xuICAgIHByaXZhdGUgdXBkYXRlUHJvZ3Jlc3ModmFsOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWw7XG4gICAgICAgIHRoaXMudmFsdWVJblBlcmNlbnQgPSBjb252ZXJ0SW5QZXJjZW50YWdlKHRoaXMuX3ZhbHVlLCB0aGlzLl9tYXgpO1xuICAgIH1cbn1cbmxldCBORVhUX0xJTkVBUl9JRCA9IDA7XG5sZXQgTkVYVF9DSVJDVUxBUl9JRCA9IDA7XG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2lneC1saW5lYXItYmFyJyxcbiAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlcy9saW5lYXItYmFyLmNvbXBvbmVudC5odG1sJ1xufSlcbmV4cG9ydCBjbGFzcyBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudCBleHRlbmRzIEJhc2VQcm9ncmVzcyB7XG5cbiAgICAvKipcbiAgICAgKkFuaW1hdGlvbiBvbiBwcm9ncmVzcyBgSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnRgLiBCeSBkZWZhdWx0IGl0IGlzIHNldCB0byB0cnVlLlxuICAgICAqYGBgaHRtbFxuICAgICAqPGlneC1saW5lYXItYmFyIFthbmltYXRlXT1cImZhbHNlXCIgW3N0cmlwZWRdPVwidHJ1ZVwiIFttYXhdPVwiMjAwXCIgW3ZhbHVlXT1cIjUwXCI+PC9pZ3gtbGluZWFyLWJhcj5cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgc2V0IGFuaW1hdGUoYW5pbWF0ZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl9hbmltYXRlID0gYW5pbWF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlJldHVybnMgd2hldGhlciB0aGUgYElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50YCBoYXMgYW5pbWF0aW9uIHRydWUvZmFsc2UuXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICpAVmlld0NoaWxkKFwiTXlQcm9ncmVzc0JhclwiKVxuICAgICAqcHVibGljIHByb2dyZXNzQmFyOiBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudDtcbiAgICAgKnB1YmxpYyBhbmltYXRpb25TdGF0dXMoZXZlbnQpIHtcbiAgICAgKiAgICBsZXQgYW5pbWF0aW9uU3RhdHVzID0gdGhpcy5wcm9ncmVzc0Jhci5hbmltYXRlO1xuICAgICAqICAgIGFsZXJ0KGFuaW1hdGlvblN0YXR1cyk7XG4gICAgICp9XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBnZXQgYW5pbWF0ZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FuaW1hdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpTZXQgbWF4aW11bSB2YWx1ZSB0aGF0IGNhbiBiZSBwYXNzZWQuIEJ5IGRlZmF1bHQgaXQgaXMgc2V0IHRvIDEwMC5cbiAgICAgKmBgYGh0bWxcbiAgICAgKjxpZ3gtbGluZWFyLWJhciBbc3RyaXBlZF09XCJmYWxzZVwiIFttYXhdPVwiMjAwXCIgW3ZhbHVlXT1cIjBcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtdmFsdWVtYXgnKVxuICAgIEBJbnB1dCgpXG4gICAgc2V0IG1heChtYXhOdW06IG51bWJlcikge1xuICAgICAgICB0aGlzLl9tYXggPSBtYXhOdW07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpSZXR1cm5zIHRoZSB0aGUgbWF4aW11bSBwcm9ncmVzcyB2YWx1ZSBvZiB0aGUgYElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50YC5cbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKkBWaWV3Q2hpbGQoXCJNeVByb2dyZXNzQmFyXCIpXG4gICAgICpwdWJsaWMgcHJvZ3Jlc3NCYXI6IElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50O1xuICAgICAqcHVibGljIG1heFZhbHVlKGV2ZW50KSB7XG4gICAgICogICAgbGV0IG1heCA9IHRoaXMucHJvZ3Jlc3NCYXIubWF4O1xuICAgICAqICAgIGFsZXJ0KG1heCk7XG4gICAgICp9XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBnZXQgbWF4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWF4O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqUmV0dXJucyB0aGUgdmFsdWUgd2hpY2ggdXBkYXRlIHRoZSBwcm9ncmVzcyBpbmRpY2F0b3Igb2YgdGhlIGBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudGAuXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICpAVmlld0NoaWxkKFwiTXlQcm9ncmVzc0JhclwiKVxuICAgICAqcHVibGljIHByb2dyZXNzQmFyOiBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudDtcbiAgICAgKnB1YmxpYyBzdGVwVmFsdWUoZXZlbnQpIHtcbiAgICAgKiAgICBsZXQgc3RlcCA9IHRoaXMucHJvZ3Jlc3NCYXIuc3RlcDtcbiAgICAgKiAgICBhbGVydChzdGVwKTtcbiAgICAgKn1cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZ2V0IHN0ZXAoKTogbnVtYmVyIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0ZXApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGVwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX21heCAqIE9ORV9QRVJDRU5UO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqU2V0cyB0aGUgdmFsdWUgYnkgd2hpY2ggcHJvZ3Jlc3MgaW5kaWNhdG9yIGlzIHVwZGF0ZWQuIEJ5IGRlZmF1bHQgaXQgaXMgMSUgb2YgdGhlIG1heGltdW0gdmFsdWUuXG4gICAgICpgYGBodG1sXG4gICAgICo8aWd4LWxpbmVhci1iYXIgW3N0cmlwZWRdPVwiZmFsc2VcIiBbbWF4XT1cIjIwMFwiIFt2YWx1ZV09XCIwXCIgW3N0ZXBdPVwiMVwiPjwvaWd4LWxpbmVhci1iYXI+XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBzZXQgc3RlcCh2YWw6IG51bWJlcikge1xuICAgICAgICB0aGlzLl9zdGVwID0gTnVtYmVyKHZhbCk7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmFyaWEtdmFsdWVtaW4nKVxuICAgIHB1YmxpYyB2YWx1ZU1pbiA9IDA7XG5cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1saW5lYXItYmFyJylcbiAgICBwdWJsaWMgY3NzQ2xhc3MgPSAnaWd4LWxpbmVhci1iYXInO1xuXG4gICAgLyoqXG4gICAgICpTZXQgYElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50YCB0byBoYXZlIHN0cmlwZWQgc3R5bGUuIEJ5IGRlZmF1bHQgaXQgaXMgc2V0IHRvIGZhbHNlLlxuICAgICAqYGBgaHRtbFxuICAgICAqPGlneC1saW5lYXItYmFyIFtzdHJpcGVkXT1cInRydWVcIiBbbWF4XT1cIjIwMFwiIFt2YWx1ZV09XCI1MFwiPjwvaWd4LWxpbmVhci1iYXI+XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1saW5lYXItYmFyLS1zdHJpcGVkJylcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzdHJpcGVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKlNldCBgSWd4TGluZWFyUHJvZ3Jlc3NCYXJDb21wb25lbnRgIHRvIGhhdmUgaW5kZXRlcm1pbmF0ZS4gQnkgZGVmYXVsdCBpdCBpcyBzZXQgdG8gZmFsc2UuXG4gICAgICpgYGBodG1sXG4gICAgICo8aWd4LWxpbmVhci1iYXIgW2luZGV0ZXJtaW5hdGVdPVwidHJ1ZVwiPjwvaWd4LWxpbmVhci1iYXI+XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1saW5lYXItYmFyLS1pbmRldGVybWluYXRlJylcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBpbmRldGVybWluYXRlID0gZmFsc2U7XG5cbiAgICAvKipBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHRoZSB2YWx1ZSBvZiB0aGUgYHJvbGVgIGF0dHJpYnV0ZS4gSWYgbm90IHByb3ZpZGVkIGl0IHdpbGwgYmUgYXV0b21hdGljYWxseSBzZXQgdG8gYHByb2dyZXNzYmFyYC5cbiAgICAgKiBgYGBodG1sXG4gICAgICo8aWd4LWxpbmVhci1iYXIgcm9sZT1cInByb2dyZXNzYmFyXCI+PC9pZ3gtbGluZWFyLWJhcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIucm9sZScpXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgcm9sZSA9ICdwcm9ncmVzc2Jhcic7XG5cbiAgICAvKipBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHRoZSB2YWx1ZSBvZiBgaWRgIGF0dHJpYnV0ZS4gSWYgbm90IHByb3ZpZGVkIGl0IHdpbGwgYmUgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQuXG4gICAgICogYGBgaHRtbFxuICAgICAqPGlneC1saW5lYXItYmFyIFtpZF09XCInaWd4LWxpbmVhci1iYXItNTUnXCIgW3N0cmlwZWRdPVwidHJ1ZVwiIFttYXhdPVwiMjAwXCIgW3ZhbHVlXT1cIjUwXCI+PC9pZ3gtbGluZWFyLWJhcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuaWQnKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGlkID0gYGlneC1saW5lYXItYmFyLSR7TkVYVF9MSU5FQVJfSUQrK31gO1xuXG4gICAgLyoqXG4gICAgICpTZXQgdGhlIHBvc2l0aW9uIHRoYXQgZGVmaW5lcyB3aGVyZSB0aGUgdGV4dCBpcyBhbGlnbmVkLlxuICAgICBQb3NzaWJsZSBvcHRpb25zIC0gYElneFRleHRBbGlnbi5TVEFSVGAgKGRlZmF1bHQpLCBgSWd4VGV4dEFsaWduLkNFTlRFUmAsIGBJZ3hUZXh0QWxpZ24uRU5EYC5cbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKnB1YmxpYyBwb3NpdGlvbkNlbnRlcjogSWd4VGV4dEFsaWduO1xuICAgICAqcHVibGljIG5nT25Jbml0KCkge1xuICAgICAqICAgIHRoaXMucG9zaXRpb25DZW50ZXIgPSBJZ3hUZXh0QWxpZ24uQ0VOVEVSO1xuICAgICAqfVxuICAgICAqIC8vLi4uXG4gICAgICpgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICo8aWd4LWxpbmVhci1iYXIgdHlwZT1cIndhcm5pbmdcIiBbdGV4dF09XCInQ3VzdG9tIHRleHQnXCIgW3RleHRBbGlnbl09XCJwb3NpdGlvbkNlbnRlclwiIFtzdHJpcGVkXT1cInRydWVcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgdGV4dEFsaWduOiBJZ3hUZXh0QWxpZ24gPSBJZ3hUZXh0QWxpZ24uU1RBUlQ7XG5cbiAgICAvKipcbiAgICAgKlNldCB0aGUgdGV4dCB0byBiZSB2aXNpYmxlLiBCeSBkZWZhdWx0IGl0IGlzIHNldCB0byB0cnVlLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKjxpZ3gtbGluZWFyLWJhciB0eXBlPVwiZGVmYXVsdFwiIFt0ZXh0VmlzaWJpbGl0eV09XCJmYWxzZVwiPjwvaWd4LWxpbmVhci1iYXI+XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyB0ZXh0VmlzaWJpbGl0eSA9IHRydWU7XG5cbiAgICAvKipcbiAgICAgKlNldCB0aGUgcG9zaXRpb24gdGhhdCBkZWZpbmVzIGlmIHRoZSB0ZXh0IHNob3VsZCBiZSBhbGlnbmVkIGFib3ZlIHRoZSBwcm9ncmVzcyBsaW5lLiBCeSBkZWZhdWx0IGlzIHNldCB0byBmYWxzZS5cbiAgICAgKmBgYGh0bWxcbiAgICAgKjxpZ3gtbGluZWFyLWJhciB0eXBlPVwiZGFuZ2VyXCIgW3RleHRUb3BdPVwidHJ1ZVwiPjwvaWd4LWxpbmVhci1iYXI+XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyB0ZXh0VG9wID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKlNldCBhIGN1c3RvbSB0ZXh0IHRoYXQgaXMgZGlzcGxheWVkIGFjY29yZGluZyB0byB0aGUgZGVmaW5lZCBwb3NpdGlvbi5cbiAgICAgKiBgYGBodG1sXG4gICAgICo8aWd4LWxpbmVhci1iYXIgdHlwZT1cIndhcm5pbmdcIiBbdGV4dF09XCInQ3VzdG9tIHRleHQnXCIgW3RleHRBbGlnbl09XCJwb3NpdGlvbkNlbnRlclwiIFtzdHJpcGVkXT1cInRydWVcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgdGV4dDogc3RyaW5nO1xuXG4gICAgLyoqXG4gICAgICpTZXQgdHlwZSBvZiB0aGUgYElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50YC4gUG9zc2libGUgb3B0aW9ucyAtIGBkZWZhdWx0YCwgYHN1Y2Nlc3NgLCBgaW5mb2AsIGB3YXJuaW5nYCwgYW5kIGBkYW5nZXJgLlxuICAgICAqYGBgaHRtbFxuICAgICAqPGlneC1saW5lYXItYmFyIFtzdHJpcGVkXT1cImZhbHNlXCIgW21heF09XCIxMDBcIiBbdmFsdWVdPVwiMFwiIHR5cGU9XCJkYW5nZXJcIj48L2lneC1saW5lYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG5cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyB0eXBlID0gJ2RlZmF1bHQnO1xuXG4gICAgLyoqXG4gICAgKlJldHVybnMgdmFsdWUgdGhhdCBpbmRpY2F0ZXMgdGhlIGN1cnJlbnQgYElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50YCBwb3NpdGlvbi5cbiAgICAqYGBgdHlwZXNjcmlwdFxuICAgICpAVmlld0NoaWxkKFwiTXlQcm9ncmVzc0JhclwiKVxuICAgICpwdWJsaWMgcHJvZ3Jlc3NCYXI6IElneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50O1xuICAgICpwdWJsaWMgZ2V0VmFsdWUoZXZlbnQpIHtcbiAgICAqICAgIGxldCB2YWx1ZSA9IHRoaXMucHJvZ3Jlc3NCYXIudmFsdWU7XG4gICAgKiAgICBhbGVydCh2YWx1ZSk7XG4gICAgKn1cbiAgICAqYGBgXG4gICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuYXJpYS12YWx1ZW5vdycpXG4gICAgQElucHV0KClcbiAgICBnZXQgdmFsdWUoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqU2V0IHZhbHVlIHRoYXQgaW5kaWNhdGVzIHRoZSBjdXJyZW50IGBJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudGAgcG9zaXRpb24uXG4gICAgICpgYGBodG1sXG4gICAgICo8aWd4LWxpbmVhci1iYXIgW3N0cmlwZWRdPVwiZmFsc2VcIiBbbWF4XT1cIjIwMFwiIFt2YWx1ZV09XCI1MFwiPjwvaWd4LWxpbmVhci1iYXI+XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBzZXQgdmFsdWUodmFsKSB7XG4gICAgICAgIHZhbCA9IE51bWJlcih2YWwpO1xuICAgICAgICBpZiAodGhpcy5fdmFsdWUgPT09IHZhbCB8fCB0aGlzLmluZGV0ZXJtaW5hdGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHZhbHVlSW5SYW5nZSA9IGdldFZhbHVlSW5Qcm9wZXJSYW5nZSh2YWwsIHRoaXMubWF4KTtcbiAgICAgICAgaWYgKGlzTmFOKHZhbHVlSW5SYW5nZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGFuZ2VkVmFsdWVzID0ge1xuICAgICAgICAgICAgY3VycmVudFZhbHVlOiB2YWx1ZUluUmFuZ2UsXG4gICAgICAgICAgICBwcmV2aW91c1ZhbHVlOiB0aGlzLl92YWx1ZVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHVwZGF0ZVZhbHVlID0gc3VwZXIuZGlyZWN0aW9uRmxvdyh0aGlzLl92YWx1ZSwgdmFsLCB0aGlzLnN0ZXApO1xuICAgICAgICBpZiAodGhpcy5fYW5pbWF0ZSAmJiB2YWwgPj0gdGhpcy5zdGVwKSB7XG4gICAgICAgICAgICBzdXBlci5ydW5BbmltYXRpb24odmFsdWVJblJhbmdlLCB1cGRhdGVWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdXBlci51cGRhdGVQcm9ncmVzc0RpcmVjdGx5KHZhbHVlSW5SYW5nZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9uUHJvZ3Jlc3NDaGFuZ2VkLmVtaXQoY2hhbmdlZFZhbHVlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpBbiBldmVudCwgd2hpY2ggaXMgdHJpZ2dlcmVkIGFmdGVyIGEgcHJvZ3Jlc3MgaXMgY2hhbmdlZC5cbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKnB1YmxpYyBwcm9ncmVzc0NoYW5nZShldmVudCkge1xuICAgICAqICAgIGFsZXJ0KFwiUHJvZ3Jlc3MgbWFkZSFcIik7XG4gICAgICp9XG4gICAgICogLy8uLi5cbiAgICAgKmBgYFxuICAgICAqYGBgaHRtbFxuICAgICAqPGlneC1saW5lYXItYmFyIChvblByb2dyZXNzQ2hhbmdlZCk9XCJwcm9ncmVzc0NoYW5nZSgkZXZlbnQpXCIgdHlwZT1cInN1Y2Nlc3NcIj5cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKSBwdWJsaWMgb25Qcm9ncmVzc0NoYW5nZWQgPSBuZXcgRXZlbnRFbWl0dGVyPElDaGFuZ2VQcm9ncmVzc0V2ZW50QXJncz4oKTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1saW5lYXItYmFyLS1kYW5nZXInKVxuICAgIHB1YmxpYyBnZXQgZGFuZ2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSBJZ3hQcm9ncmVzc1R5cGUuREFOR0VSO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1saW5lYXItYmFyLS1pbmZvJylcbiAgICBwdWJsaWMgZ2V0IGluZm8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IElneFByb2dyZXNzVHlwZS5JTkZPO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1saW5lYXItYmFyLS13YXJuaW5nJylcbiAgICBwdWJsaWMgZ2V0IHdhcm5pbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IElneFByb2dyZXNzVHlwZS5XQVJOSU5HO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1saW5lYXItYmFyLS1zdWNjZXNzJylcbiAgICBwdWJsaWMgZ2V0IHN1Y2Nlc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IElneFByb2dyZXNzVHlwZS5TVUNDRVNTO1xuICAgIH1cbn1cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdpZ3gtY2lyY3VsYXItYmFyJyxcbiAgICB0ZW1wbGF0ZVVybDogJ3RlbXBsYXRlcy9jaXJjdWxhci1iYXIuY29tcG9uZW50Lmh0bWwnXG59KVxuZXhwb3J0IGNsYXNzIElneENpcmN1bGFyUHJvZ3Jlc3NCYXJDb21wb25lbnQgZXh0ZW5kcyBCYXNlUHJvZ3Jlc3Mge1xuXG4gICAgcHJpdmF0ZSByZWFkb25seSBTVFJPS0VfT1BBQ0lUWV9EVklERVIgPSAxMDA7XG4gICAgcHJpdmF0ZSByZWFkb25seSBTVFJPS0VfT1BBQ0lUWV9BRERJVElPTiA9IC4yO1xuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1jaXJjdWxhci1iYXInKVxuICAgIHB1YmxpYyBjc3NDbGFzcyA9ICdpZ3gtY2lyY3VsYXItYmFyJztcblxuICAgIC8qKlxuICAgICAqQW4gZXZlbnQsIHdoaWNoIGlzIHRyaWdnZXJlZCBhZnRlciBhIHByb2dyZXNzIGlzIGNoYW5nZWQuXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICpwdWJsaWMgcHJvZ3Jlc3NDaGFuZ2UoZXZlbnQpIHtcbiAgICAgKiAgICBhbGVydChcIlByb2dyZXNzIG1hZGUhXCIpO1xuICAgICAqfVxuICAgICAqIC8vLi4uXG4gICAgICpgYGBcbiAgICAgKmBgYGh0bWxcbiAgICAgKjxpZ3gtY2lyY3VsYXItYmFyIFt2YWx1ZV09XCJjdXJyZW50VmFsdWVcIiAob25Qcm9ncmVzc0NoYW5nZWQpPVwicHJvZ3Jlc3NDaGFuZ2UoJGV2ZW50KVwiPjwvaWd4LWNpcmN1bGFyLWJhcj5cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHB1YmxpYyBvblByb2dyZXNzQ2hhbmdlZCA9IG5ldyBFdmVudEVtaXR0ZXI8SUNoYW5nZVByb2dyZXNzRXZlbnRBcmdzPigpO1xuXG4gICAgLyoqXG4gICAgICpBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHRoZSB2YWx1ZSBvZiBgaWRgIGF0dHJpYnV0ZS4gSWYgbm90IHByb3ZpZGVkIGl0IHdpbGwgYmUgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQuXG4gICAgICpgYGBodG1sXG4gICAgICo8aWd4LWNpcmN1bGFyLWJhciBbaWRdPVwiJ2lneC1jaXJjdWxhci1iYXItNTUnXCIgW3ZhbHVlXT1cIjUwXCI+PC9pZ3gtY2lyY3VsYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmlkJylcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBpZCA9IGBpZ3gtY2lyY3VsYXItYmFyLSR7TkVYVF9DSVJDVUxBUl9JRCsrfWA7XG5cbiAgICAvKipcbiAgICAgKkFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIHZhbHVlIG9mIHRoZSBgaW5kZXRlcm1pbmF0ZWAgYXR0cmlidXRlLiBJZiBub3QgcHJvdmlkZWQgaXQgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IHNldCB0byBmYWxzZS5cbiAgICAgKmBgYGh0bWxcbiAgICAgKjxpZ3gtY2lyY3VsYXItYmFyIFtpbmRldGVybWluYXRlXT1cInRydWVcIj48L2lneC1jaXJjdWxhci1iYXI+XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1jaXJjdWxhci1iYXItLWluZGV0ZXJtaW5hdGUnKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGluZGV0ZXJtaW5hdGUgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqU2V0cyB0aGUgdGV4dCB2aXNpYmlsaXR5LiBCeSBkZWZhdWx0IGl0IGlzIHNldCB0byB0cnVlLlxuICAgICAqYGBgaHRtbFxuICAgICAqPGlneC1jaXJjdWxhci1iYXIgW3RleHRWaXNpYmlsaXR5XT1cImZhbHNlXCI+PC9pZ3gtY2lyY3VsYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgdGV4dFZpc2liaWxpdHkgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHRoZSB0ZXh0IHRvIGJlIGRpc3BsYXllZCBpbnNpZGUgdGhlIGBpZ3hDaXJjdWxhckJhcmAuXG4gICAgICpgYGBodG1sXG4gICAgICo8aWd4LWNpcmN1bGFyLWJhciB0ZXh0PVwiUHJvZ3Jlc3NcIj48L2lneC1jaXJjdWxhci1iYXI+XG4gICAgICpgYGBcbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKmxldCB0ZXh0ID0gdGhpcy5jaXJjdWxhckJhci50ZXh0O1xuICAgICAqYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgdGV4dDogc3RyaW5nO1xuXG4gICAgQENvbnRlbnRDaGlsZChJZ3hQcm9jZXNzQmFyVGV4dFRlbXBsYXRlRGlyZWN0aXZlLCB7IHJlYWQ6IElneFByb2Nlc3NCYXJUZXh0VGVtcGxhdGVEaXJlY3RpdmUsIHN0YXRpYzogZmFsc2UgfSlcbiAgICBwdWJsaWMgdGV4dFRlbXBsYXRlOiBJZ3hQcm9jZXNzQmFyVGV4dFRlbXBsYXRlRGlyZWN0aXZlO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICovXG4gICAgcHVibGljIGdldCBjb250ZXh0KCk6IGFueSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAkaW1wbGljaXQ6IHsgdmFsdWU6IHRoaXMudmFsdWUsIHZhbHVlSW5QZXJjZW50OiB0aGlzLnZhbHVlSW5QZXJjZW50LCBtYXg6IHRoaXMubWF4IH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqQW5pbWF0aW9uIG9uIHByb2dyZXNzIGBJZ3hDaXJjdWxhclByb2dyZXNzQmFyQ29tcG9uZW50YC4gQnkgZGVmYXVsdCBpdCBpcyBzZXQgdG8gdHJ1ZS5cbiAgICAgKmBgYGh0bWxcbiAgICAgKjxpZ3gtY2lyY3VsYXItYmFyIFthbmltYXRlXT1cImZhbHNlXCIgW3ZhbHVlXT1cIjUwXCI+PC9pZ3gtY2lyY3VsYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBzZXQgYW5pbWF0ZShhbmltYXRlOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX2FuaW1hdGUgPSBhbmltYXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqUmV0dXJucyB3aGV0aGVyIHRoZSBgSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudGAgaGFzIGFuaW1hdGlvbiB0cnVlL2ZhbHNlLlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqQFZpZXdDaGlsZChcIk15UHJvZ3Jlc3NCYXJcIilcbiAgICAgKnB1YmxpYyBwcm9ncmVzc0JhcjogSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudDtcbiAgICAgKnB1YmxpYyBhbmltYXRpb25TdGF0dXMoZXZlbnQpIHtcbiAgICAgKiAgICBsZXQgYW5pbWF0aW9uU3RhdHVzID0gdGhpcy5wcm9ncmVzc0Jhci5hbmltYXRlO1xuICAgICAqICAgIGFsZXJ0KGFuaW1hdGlvblN0YXR1cyk7XG4gICAgICp9XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBnZXQgYW5pbWF0ZSgpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FuaW1hdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpTZXQgbWF4aW11bSB2YWx1ZSB0aGF0IGNhbiBiZSBwYXNzZWQuIEJ5IGRlZmF1bHQgaXQgaXMgc2V0IHRvIDEwMC5cbiAgICAgKmBgYGh0bWxcbiAgICAgKjxpZ3gtY2lyY3VsYXItYmFyIFttYXhdPVwiMjAwXCIgW3ZhbHVlXT1cIjBcIj48L2lneC1jaXJjdWxhci1iYXI+XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHNldCBtYXgobWF4TnVtOiBudW1iZXIpIHtcbiAgICAgICAgdGhpcy5fbWF4ID0gbWF4TnVtO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqUmV0dXJucyB0aGUgdGhlIG1heGltdW0gcHJvZ3Jlc3MgdmFsdWUgb2YgdGhlIGBJZ3hDaXJjdWxhclByb2dyZXNzQmFyQ29tcG9uZW50YC5cbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKkBWaWV3Q2hpbGQoXCJNeVByb2dyZXNzQmFyXCIpXG4gICAgICpwdWJsaWMgcHJvZ3Jlc3NCYXI6IElneENpcmN1bGFyUHJvZ3Jlc3NCYXJDb21wb25lbnQ7XG4gICAgICpwdWJsaWMgbWF4VmFsdWUoZXZlbnQpIHtcbiAgICAgKiAgICBsZXQgbWF4ID0gdGhpcy5wcm9ncmVzc0Jhci5tYXg7XG4gICAgICogICAgYWxlcnQobWF4KTtcbiAgICAgKn1cbiAgICAgKmBgYFxuICAgICAqYGBgaHRtbFxuICAgICAqPGlneC1jaXJjdWxhci1iYXIgW21heF09XCIyNDVcIiBbYW5pbWF0ZV09XCJmYWxzZVwiIFt2YWx1ZV09XCJjdXJyZW50VmFsdWVcIj48L2lneC1jaXJjdWxhci1iYXI+XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBnZXQgbWF4KCk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpSZXR1cm5zIHRoZSB2YWx1ZSB3aGljaCB1cGRhdGUgdGhlIHByb2dyZXNzIGluZGljYXRvciBvZiB0aGUgYElneENpcmN1bGFyUHJvZ3Jlc3NCYXJDb21wb25lbnRgLlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqQFZpZXdDaGlsZChcIk15UHJvZ3Jlc3NCYXJcIilcbiAgICAgKnB1YmxpYyBwcm9ncmVzc0JhcjogSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudDtcbiAgICAgKnB1YmxpYyBzdGVwVmFsdWUoZXZlbnQpIHtcbiAgICAgKiAgICBsZXQgc3RlcCA9IHRoaXMucHJvZ3Jlc3NCYXIuc3RlcDtcbiAgICAgKiAgICBhbGVydChzdGVwKTtcbiAgICAgKn1cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgZ2V0IHN0ZXAoKTogbnVtYmVyIHtcbiAgICAgICAgaWYgKHRoaXMuX3N0ZXApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGVwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX21heCAqIE9ORV9QRVJDRU5UO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqU2V0cyB0aGUgdmFsdWUgYnkgd2hpY2ggcHJvZ3Jlc3MgaW5kaWNhdG9yIGlzIHVwZGF0ZWQuIEJ5IGRlZmF1bHQgaXQgaXMgMSUgb2YgdGhlIG1heGltdW0gdmFsdWUuXG4gICAgICpgYGBodG1sXG4gICAgICo8aWd4LWNpcmN1bGFyLWJhciBbc3RyaXBlZF09XCJmYWxzZVwiIFttYXhdPVwiMjAwXCIgW3ZhbHVlXT1cIjBcIiBbc3RlcF09XCIxXCI+PC9pZ3gtY2lyY3VsYXItYmFyPlxuICAgICAqYGBgXG4gICAgKi9cbiAgICBzZXQgc3RlcCh2YWw6IG51bWJlcikge1xuICAgICAgICB0aGlzLl9zdGVwID0gTnVtYmVyKHZhbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpSZXR1cm5zIHZhbHVlIHRoYXQgaW5kaWNhdGVzIHRoZSBjdXJyZW50IGBJZ3hDaXJjdWxhclByb2dyZXNzQmFyQ29tcG9uZW50YCBwb3NpdGlvbi5cbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKkBWaWV3Q2hpbGQoXCJNeVByb2dyZXNzQmFyXCIpXG4gICAgICpwdWJsaWMgcHJvZ3Jlc3NCYXI6IElneENpcmN1bGFyUHJvZ3Jlc3NCYXJDb21wb25lbnQ7XG4gICAgICpwdWJsaWMgZ2V0VmFsdWUoZXZlbnQpIHtcbiAgICAgKiAgICBsZXQgdmFsdWUgPSB0aGlzLnByb2dyZXNzQmFyLnZhbHVlO1xuICAgICAqICAgIGFsZXJ0KHZhbHVlKTtcbiAgICAgKn1cbiAgICAgKmBgYFxuICAgICAqYGBgaHRtbFxuICAgICAqPGJ1dHRvbiBpZ3hCdXR0b249XCJmYWJcIiBpZ3hSaXBwbGU9XCJcIiAoY2xpY2spPVwiZ2V0VmFsdWUoKVwiPkNsaWNrPC9idXR0b24+XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGdldCB2YWx1ZSgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpTZXQgdmFsdWUgdGhhdCBpbmRpY2F0ZXMgdGhlIGN1cnJlbnQgYElneENpcmN1bGFyUHJvZ3Jlc3NCYXJDb21wb25lbnRgIHBvc2l0aW9uLlxuICAgICAqYGBgaHRtbFxuICAgICAqPGlneC1jaXJjdWxhci1iYXIgW3ZhbHVlXT1cIjUwXCI+PC9pZ3gtY2lyY3VsYXItYmFyPlxuICAgICAqYGBgXG4gICAgICovXG4gICAgc2V0IHZhbHVlKHZhbDogbnVtYmVyKSB7XG4gICAgICAgIHZhbCA9IE51bWJlcih2YWwpO1xuICAgICAgICBpZiAodGhpcy5fdmFsdWUgPT09IHZhbCB8fCB0aGlzLmluZGV0ZXJtaW5hdGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHZhbHVlSW5Qcm9wZXJSYW5nZSA9IGdldFZhbHVlSW5Qcm9wZXJSYW5nZSh2YWwsIHRoaXMubWF4KTtcbiAgICAgICAgaWYgKGlzTmFOKHZhbHVlSW5Qcm9wZXJSYW5nZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNoYW5nZWRWYWx1ZXMgPSB7XG4gICAgICAgICAgICBjdXJyZW50VmFsdWU6IHZhbHVlSW5Qcm9wZXJSYW5nZSxcbiAgICAgICAgICAgIHByZXZpb3VzVmFsdWU6IHRoaXMuX3ZhbHVlXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgdXBkYXRlVmFsdWUgPSBzdXBlci5kaXJlY3Rpb25GbG93KHRoaXMuX3ZhbHVlLCB2YWwsIHRoaXMuc3RlcCk7XG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGUgJiYgdmFsID49IHRoaXMuc3RlcCkge1xuICAgICAgICAgICAgc3VwZXIucnVuQW5pbWF0aW9uKHZhbHVlSW5Qcm9wZXJSYW5nZSwgdXBkYXRlVmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVQcm9ncmVzc0RpcmVjdGx5KHZhbHVlSW5Qcm9wZXJSYW5nZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9uUHJvZ3Jlc3NDaGFuZ2VkLmVtaXQoY2hhbmdlZFZhbHVlcyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfY2lyY2xlUmFkaXVzID0gNDY7XG4gICAgcHJpdmF0ZSBfY2lyY3VtZmVyZW5jZSA9IDIgKiBNYXRoLlBJICogdGhpcy5fY2lyY2xlUmFkaXVzO1xuXG4gICAgQFZpZXdDaGlsZCgnY2lyY2xlJywgeyBzdGF0aWM6IHRydWUgfSkgcHJpdmF0ZSBfc3ZnQ2lyY2xlOiBFbGVtZW50UmVmO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyB1cGRhdGVQcm9ncmVzc1Ntb290aGx5KHZhbDogbnVtYmVyLCBzdGVwOiBudW1iZXIpIHtcbiAgICAgICAgLy8gU2V0IGZyYW1lcyBmb3IgdGhlIGFuaW1hdGlvblxuICAgICAgICBjb25zdCBGUkFNRVMgPSBbe1xuICAgICAgICAgICAgc3Ryb2tlRGFzaG9mZnNldDogdGhpcy5nZXRQcm9ncmVzcyh0aGlzLl92YWx1ZSksXG4gICAgICAgICAgICBzdHJva2VPcGFjaXR5OiAodGhpcy5fdmFsdWUgLyB0aGlzLlNUUk9LRV9PUEFDSVRZX0RWSURFUikgKyB0aGlzLlNUUk9LRV9PUEFDSVRZX0FERElUSU9OXG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIHN0cm9rZURhc2hvZmZzZXQ6IHRoaXMuZ2V0UHJvZ3Jlc3ModGhpcy52YWx1ZUluUGVyY2VudCksXG4gICAgICAgICAgICBzdHJva2VPcGFjaXR5OiAodGhpcy52YWx1ZUluUGVyY2VudCAvIHRoaXMuU1RST0tFX09QQUNJVFlfRFZJREVSKSArIHRoaXMuU1RST0tFX09QQUNJVFlfQURESVRJT05cbiAgICAgICAgfV07XG4gICAgICAgIHRoaXMuX3N2Z0NpcmNsZS5uYXRpdmVFbGVtZW50LmFuaW1hdGUoRlJBTUVTLCB7XG4gICAgICAgICAgICBlYXNpbmc6ICdlYXNlLW91dCcsXG4gICAgICAgICAgICBmaWxsOiAnZm9yd2FyZHMnXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHN1cGVyLnVwZGF0ZVByb2dyZXNzU21vb3RobHkodmFsLCBzdGVwKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgKi9cbiAgICBwdWJsaWMgZ2V0IHRleHRDb250ZW50KCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLnRleHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICovXG4gICAgcHVibGljIHVwZGF0ZVByb2dyZXNzRGlyZWN0bHkodmFsOiBudW1iZXIpIHtcbiAgICAgICAgc3VwZXIudXBkYXRlUHJvZ3Jlc3NEaXJlY3RseSh2YWwpO1xuXG4gICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUoXG4gICAgICAgICAgICB0aGlzLl9zdmdDaXJjbGUubmF0aXZlRWxlbWVudCxcbiAgICAgICAgICAgICdzdHJva2UtZGFzaG9mZnNldCcsXG4gICAgICAgICAgICB0aGlzLmdldFByb2dyZXNzKHRoaXMudmFsdWVJblBlcmNlbnQpKTtcblxuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKFxuICAgICAgICAgICAgdGhpcy5fc3ZnQ2lyY2xlLm5hdGl2ZUVsZW1lbnQsXG4gICAgICAgICAgICAnc3Ryb2tlLW9wYWNpdHknLFxuICAgICAgICAgICAgKHRoaXMudmFsdWVJblBlcmNlbnQgLyB0aGlzLlNUUk9LRV9PUEFDSVRZX0RWSURFUikgKyB0aGlzLlNUUk9LRV9PUEFDSVRZX0FERElUSU9OKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldFByb2dyZXNzKHBlcmNlbnRhZ2U6IG51bWJlcikge1xuICAgICAgICAvLyBSZXZlcnNlIHRoZSBzaWduIGhlcmU6ICctJyBzaG91bGQgYmVjb21lICcrJyBpbiBSVEwgbW9kZVxuICAgICAgICByZXR1cm4gdGhpcy5fY2lyY3VtZmVyZW5jZSAtIChwZXJjZW50YWdlICogdGhpcy5fY2lyY3VtZmVyZW5jZSAvIDEwMCk7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmFsdWVJblByb3BlclJhbmdlKHZhbHVlOiBudW1iZXIsIG1heDogbnVtYmVyLCBtaW4gPSAwKTogbnVtYmVyIHtcbiAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4odmFsdWUsIG1heCksIG1pbik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0SW5QZXJjZW50YWdlKHZhbHVlOiBudW1iZXIsIG1heDogbnVtYmVyKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoMTAwICogdmFsdWUgLyBtYXgpO1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtJZ3hMaW5lYXJQcm9ncmVzc0JhckNvbXBvbmVudCwgSWd4Q2lyY3VsYXJQcm9ncmVzc0JhckNvbXBvbmVudCwgSWd4UHJvY2Vzc0JhclRleHRUZW1wbGF0ZURpcmVjdGl2ZV0sXG4gICAgZXhwb3J0czogW0lneExpbmVhclByb2dyZXNzQmFyQ29tcG9uZW50LCBJZ3hDaXJjdWxhclByb2dyZXNzQmFyQ29tcG9uZW50LCBJZ3hQcm9jZXNzQmFyVGV4dFRlbXBsYXRlRGlyZWN0aXZlXSxcbiAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hQcm9ncmVzc0Jhck1vZHVsZSB7XG59XG4iXX0=