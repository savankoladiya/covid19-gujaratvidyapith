/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable, PLATFORM_ID, Inject } from '@angular/core';
import { isPlatformBrowser } from '@angular/common';
import * as i0 from "@angular/core";
/**
 * @hidden
 * @param {?} array
 * @param {?=} deep
 * @return {?}
 */
export function cloneArray(array, deep) {
    /** @type {?} */
    const arr = [];
    if (!array) {
        return arr;
    }
    /** @type {?} */
    let i = array.length;
    while (i--) {
        arr[i] = deep ? cloneValue(array[i]) : array[i];
    }
    return arr;
}
/**
 * Doesn't clone leaf items
 * @hidden
 * @param {?} array
 * @param {?} childDataKey
 * @return {?}
 */
export function cloneHierarchicalArray(array, childDataKey) {
    /** @type {?} */
    const result = [];
    if (!array) {
        return result;
    }
    for (const item of array) {
        /** @type {?} */
        const clonedItem = cloneValue(item);
        if (Array.isArray(item[childDataKey])) {
            clonedItem[childDataKey] = cloneHierarchicalArray(clonedItem[childDataKey], childDataKey);
        }
        result.push(clonedItem);
    }
    return result;
}
/**
 * Deep clones all first level keys of Obj2 and merges them to Obj1
 * @hidden
 * @param {?} obj1 Object to merge into
 * @param {?} obj2 Object to merge from
 * @return {?} Obj1 with merged cloned keys from Obj2
 */
export function mergeObjects(obj1, obj2) {
    if (!isObject(obj1)) {
        throw new Error(`Cannot merge into ${obj1}. First param must be an object.`);
    }
    if (!isObject(obj2)) {
        return obj1;
    }
    for (const key of Object.keys(obj2)) {
        obj1[key] = cloneValue(obj2[key]);
    }
    return obj1;
}
/**
 * Creates deep clone of provided value.
 * Supports primitive values, dates and objects.
 * If passed value is array returns shallow copy of the array.
 * @hidden
 * @param {?} value value to clone
 * @return {?} Deep copy of provided value
 */
export function cloneValue(value) {
    if (isDate(value)) {
        return new Date(value.getTime());
    }
    if (Array.isArray(value)) {
        return [...value];
    }
    if (value instanceof Map || value instanceof Set) {
        return value;
    }
    if (isObject(value)) {
        /** @type {?} */
        const result = {};
        for (const key of Object.keys(value)) {
            result[key] = cloneValue(value[key]);
        }
        return result;
    }
    return value;
}
/**
 * Checks if provided variable is Object
 * @hidden
 * @param {?} value Value to check
 * @return {?} true if provided variable is Object
 */
export function isObject(value) {
    return value && value.toString() === '[object Object]';
}
/**
 * Checks if provided variable is Date
 * @hidden
 * @param {?} value Value to check
 * @return {?} true if provided variable is Date
 */
export function isDate(value) {
    return Object.prototype.toString.call(value) === '[object Date]';
}
/**
 * Checks if the two passed arguments are equal
 * Currently supports date objects
 * \@returns: `boolean`
 * @hidden
 * @param {?} obj1
 * @param {?} obj2
 * @return {?}
 */
export function isEqual(obj1, obj2) {
    if (isDate(obj1) && isDate(obj2)) {
        return obj1.getTime() === obj2.getTime();
    }
    return obj1 === obj2;
}
/** @enum {number} */
const KEYCODES = {
    ENTER: 13,
    SPACE: 32,
    ESCAPE: 27,
    LEFT_ARROW: 37,
    UP_ARROW: 38,
    RIGHT_ARROW: 39,
    DOWN_ARROW: 40,
    F2: 113,
    TAB: 9,
};
export { KEYCODES };
/** @enum {string} */
const KEYS = {
    ENTER: 'Enter',
    SPACE: ' ',
    SPACE_IE: 'Spacebar',
    ESCAPE: 'Escape',
    ESCAPE_IE: 'Esc',
    LEFT_ARROW: 'ArrowLeft',
    LEFT_ARROW_IE: 'Left',
    UP_ARROW: 'ArrowUp',
    UP_ARROW_IE: 'Up',
    RIGHT_ARROW: 'ArrowRight',
    RIGHT_ARROW_IE: 'Right',
    DOWN_ARROW: 'ArrowDown',
    DOWN_ARROW_IE: 'Down',
    F2: 'F2',
    TAB: 'Tab',
};
export { KEYS };
/**
 * @hidden
 * Returns the actual size of the node content, using Range
 * ```typescript
 * let range = document.createRange();
 * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
 *
 * let size = getNodeSizeViaRange(range, column.cells[0].nativeElement);
 * ```
 * @param {?} range
 * @param {?} node
 * @return {?}
 */
export function getNodeSizeViaRange(range, node) {
    /** @type {?} */
    let overflow = null;
    if (!isFirefox()) {
        overflow = node.style.overflow;
        // we need that hack - otherwise content won't be measured correctly in IE/Edge
        node.style.overflow = 'visible';
    }
    range.selectNodeContents(node);
    /** @type {?} */
    const width = range.getBoundingClientRect().width;
    if (!isFirefox()) {
        // we need that hack - otherwise content won't be measured correctly in IE/Edge
        node.style.overflow = overflow;
    }
    return width;
}
/**
 * @hidden
 * Returns the actual size of the node content, using Canvas
 * ```typescript
 * let ctx = document.createElement('canvas').getContext('2d');
 * let column = this.grid.columnList.filter(c => c.field === 'ID')[0];
 *
 * let size = valToPxlsUsingCanvas(ctx, column.cells[0].nativeElement);
 * ```
 * @param {?} canvas2dCtx
 * @param {?} node
 * @return {?}
 */
export function getNodeSizeViaCanvas(canvas2dCtx, node) {
    /** @type {?} */
    const s = this.grid.document.defaultView.getComputedStyle(node);
    // need to set the font to get correct width
    canvas2dCtx.font = s.fontSize + ' ' + s.fontFamily;
    return canvas2dCtx.measureText(node.textContent).width;
}
/**
 * @hidden
 * @return {?}
 */
export function isIE() {
    return navigator.appVersion.indexOf('Trident/') > 0;
}
/**
 * @hidden
 * @return {?}
 */
export function isEdge() {
    /** @type {?} */
    const edgeBrowser = /Edge[\/\s](\d+\.\d+)/.test(navigator.userAgent);
    return edgeBrowser;
}
/**
 * @hidden
 * @return {?}
 */
export function isFirefox() {
    /** @type {?} */
    const firefoxBrowser = /Firefox[\/\s](\d+\.\d+)/.test(navigator.userAgent);
    return firefoxBrowser;
}
/**
 * @hidden
 */
export class PlatformUtil {
    /**
     * @param {?} platformId
     */
    constructor(platformId) {
        this.platformId = platformId;
        this.isBrowser = isPlatformBrowser(this.platformId);
        this.isIOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !('MSStream' in window);
    }
}
PlatformUtil.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
PlatformUtil.ctorParameters = () => [
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
/** @nocollapse */ PlatformUtil.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function PlatformUtil_Factory() { return new PlatformUtil(i0.ɵɵinject(i0.PLATFORM_ID)); }, token: PlatformUtil, providedIn: "root" });
if (false) {
    /** @type {?} */
    PlatformUtil.prototype.isBrowser;
    /** @type {?} */
    PlatformUtil.prototype.isIOS;
    /**
     * @type {?}
     * @private
     */
    PlatformUtil.prototype.platformId;
}
/**
 * @hidden
 * @param {?} event
 * @return {?}
 */
export function isLeftClick(event) {
    return event.button === 0;
}
/**
 * @hidden
 * @param {?} key
 * @return {?}
 */
export function isNavigationKey(key) {
    return [
        'down',
        'up',
        'left',
        'right',
        'arrowdown',
        'arrowup',
        'arrowleft',
        'arrowright',
        'home',
        'end',
        'space',
        'spacebar',
        ' '
    ].indexOf(key) !== -1;
}
/**
 * @hidden
 * @param {?} arr
 * @return {?}
 */
export function flatten(arr) {
    /** @type {?} */
    let result = [];
    arr.forEach(el => {
        result.push(el);
        if (el.children) {
            /** @type {?} */
            const children = Array.isArray(el.children) ? el.children : el.children.toArray();
            result = result.concat(flatten(children));
        }
    });
    return result;
}
/**
 * @record
 */
export function CancelableEventArgs() { }
if (false) {
    /**
     * Provides the ability to cancel the event.
     * @type {?}
     */
    CancelableEventArgs.prototype.cancel;
}
/**
 * @record
 */
export function IBaseEventArgs() { }
if (false) {
    /**
     * Provides reference to the owner component.
     * @type {?|undefined}
     */
    IBaseEventArgs.prototype.owner;
}
/**
 * @record
 */
export function CancelableBrowserEventArgs() { }
if (false) {
    /**
     * Browser event
     * @type {?|undefined}
     */
    CancelableBrowserEventArgs.prototype.event;
}
/** @type {?} */
export const NAVIGATION_KEYS = new Set([
    'down',
    'up',
    'left',
    'right',
    'arrowdown',
    'arrowup',
    'arrowleft',
    'arrowright',
    'home',
    'end',
    'space',
    'spacebar',
    ' '
]);
/** @type {?} */
export const ROW_EXPAND_KEYS = new Set('right down arrowright arrowdown'.split(' '));
/** @type {?} */
export const ROW_COLLAPSE_KEYS = new Set('left up arrowleft arrowup'.split(' '));
/** @type {?} */
export const SUPPORTED_KEYS = new Set([...Array.from(NAVIGATION_KEYS), 'tab', 'enter', 'f2', 'escape', 'esc']);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9pZ25pdGV1aS1hbmd1bGFyLyIsInNvdXJjZXMiOlsibGliL2NvcmUvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsV0FBVyxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNoRSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQzs7Ozs7Ozs7QUFLcEQsTUFBTSxVQUFVLFVBQVUsQ0FBQyxLQUFZLEVBQUUsSUFBYzs7VUFDN0MsR0FBRyxHQUFHLEVBQUU7SUFDZCxJQUFJLENBQUMsS0FBSyxFQUFFO1FBQ1IsT0FBTyxHQUFHLENBQUM7S0FDZDs7UUFDRyxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU07SUFDcEIsT0FBTyxDQUFDLEVBQUUsRUFBRTtRQUNSLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ25EO0lBQ0QsT0FBTyxHQUFHLENBQUM7QUFDZixDQUFDOzs7Ozs7OztBQU1ELE1BQU0sVUFBVSxzQkFBc0IsQ0FBQyxLQUFZLEVBQUUsWUFBaUI7O1VBQzVELE1BQU0sR0FBVSxFQUFFO0lBQ3hCLElBQUksQ0FBQyxLQUFLLEVBQUU7UUFDUixPQUFPLE1BQU0sQ0FBQztLQUNqQjtJQUVELEtBQUssTUFBTSxJQUFJLElBQUksS0FBSyxFQUFFOztjQUNoQixVQUFVLEdBQUcsVUFBVSxDQUFDLElBQUksQ0FBQztRQUNuQyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLEVBQUU7WUFDbkMsVUFBVSxDQUFDLFlBQVksQ0FBQyxHQUFHLHNCQUFzQixDQUFDLFVBQVUsQ0FBQyxZQUFZLENBQUMsRUFBRSxZQUFZ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LENBQUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsSUFBSSxFQUFFLFFBQVEsRUFBRSxLQUFLLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIFBMQVRGT1JNX0lELCBJbmplY3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGlzUGxhdGZvcm1Ccm93c2VyIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcblxuLyoqXG4gKkBoaWRkZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lQXJyYXkoYXJyYXk6IGFueVtdLCBkZWVwPzogYm9vbGVhbikge1xuICAgIGNvbnN0IGFyciA9IFtdO1xuICAgIGlmICghYXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG4gICAgbGV0IGkgPSBhcnJheS5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICBhcnJbaV0gPSBkZWVwID8gY2xvbmVWYWx1ZShhcnJheVtpXSkgOiBhcnJheVtpXTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cblxuLyoqXG4gKiBEb2Vzbid0IGNsb25lIGxlYWYgaXRlbXNcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lSGllcmFyY2hpY2FsQXJyYXkoYXJyYXk6IGFueVtdLCBjaGlsZERhdGFLZXk6IGFueSk6IGFueVtdIHtcbiAgICBjb25zdCByZXN1bHQ6IGFueVtdID0gW107XG4gICAgaWYgKCFhcnJheSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnJheSkge1xuICAgICAgICBjb25zdCBjbG9uZWRJdGVtID0gY2xvbmVWYWx1ZShpdGVtKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbVtjaGlsZERhdGFLZXldKSkge1xuICAgICAgICAgICAgY2xvbmVkSXRlbVtjaGlsZERhdGFLZXldID0gY2xvbmVIaWVyYXJjaGljYWxBcnJheShjbG9uZWRJdGVtW2NoaWxkRGF0YUtleV0sIGNoaWxkRGF0YUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2goY2xvbmVkSXRlbSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRGVlcCBjbG9uZXMgYWxsIGZpcnN0IGxldmVsIGtleXMgb2YgT2JqMiBhbmQgbWVyZ2VzIHRoZW0gdG8gT2JqMVxuICogQHBhcmFtIG9iajEgT2JqZWN0IHRvIG1lcmdlIGludG9cbiAqIEBwYXJhbSBvYmoyIE9iamVjdCB0byBtZXJnZSBmcm9tXG4gKiBAcmV0dXJucyBPYmoxIHdpdGggbWVyZ2VkIGNsb25lZCBrZXlzIGZyb20gT2JqMlxuICogQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VPYmplY3RzKG9iajE6IHt9LCBvYmoyOiB7fSk6IGFueSB7XG4gICAgaWYgKCFpc09iamVjdChvYmoxKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBtZXJnZSBpbnRvICR7b2JqMX0uIEZpcnN0IHBhcmFtIG11c3QgYmUgYW4gb2JqZWN0LmApO1xuICAgIH1cblxuICAgIGlmICghaXNPYmplY3Qob2JqMikpIHtcbiAgICAgICAgcmV0dXJuIG9iajE7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob2JqMikpIHtcbiAgICAgICAgb2JqMVtrZXldID0gY2xvbmVWYWx1ZShvYmoyW2tleV0pO1xuICAgIH1cblxuICAgIHJldHVybiBvYmoxO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgZGVlcCBjbG9uZSBvZiBwcm92aWRlZCB2YWx1ZS5cbiAqIFN1cHBvcnRzIHByaW1pdGl2ZSB2YWx1ZXMsIGRhdGVzIGFuZCBvYmplY3RzLlxuICogSWYgcGFzc2VkIHZhbHVlIGlzIGFycmF5IHJldHVybnMgc2hhbGxvdyBjb3B5IG9mIHRoZSBhcnJheS5cbiAqIEBwYXJhbSB2YWx1ZSB2YWx1ZSB0byBjbG9uZVxuICogQHJldHVybnMgRGVlcCBjb3B5IG9mIHByb3ZpZGVkIHZhbHVlXG4gKkBoaWRkZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lVmFsdWUodmFsdWU6IGFueSk6IGFueSB7XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbHVlLmdldFRpbWUoKSk7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gWy4uLnZhbHVlXTtcbiAgICB9XG5cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXAgfHwgdmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXModmFsdWUpKSB7XG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IGNsb25lVmFsdWUodmFsdWVba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBwcm92aWRlZCB2YXJpYWJsZSBpcyBPYmplY3RcbiAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSB0byBjaGVja1xuICogQHJldHVybnMgdHJ1ZSBpZiBwcm92aWRlZCB2YXJpYWJsZSBpcyBPYmplY3RcbiAqQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3QodmFsdWU6IGFueSk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB2YWx1ZSAmJiB2YWx1ZS50b1N0cmluZygpID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgcHJvdmlkZWQgdmFyaWFibGUgaXMgRGF0ZVxuICogQHBhcmFtIHZhbHVlIFZhbHVlIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB0cnVlIGlmIHByb3ZpZGVkIHZhcmlhYmxlIGlzIERhdGVcbiAqQGhpZGRlblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNEYXRlKHZhbHVlOiBhbnkpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgdHdvIHBhc3NlZCBhcmd1bWVudHMgYXJlIGVxdWFsXG4gKiBDdXJyZW50bHkgc3VwcG9ydHMgZGF0ZSBvYmplY3RzXG4gKiBAcGFyYW0gb2JqMVxuICogQHBhcmFtIG9iajJcbiAqIEByZXR1cm5zOiBgYm9vbGVhbmBcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRXF1YWwob2JqMSwgb2JqMik6IGJvb2xlYW4ge1xuICAgIGlmIChpc0RhdGUob2JqMSkgJiYgaXNEYXRlKG9iajIpKSB7XG4gICAgICAgIHJldHVybiBvYmoxLmdldFRpbWUoKSA9PT0gb2JqMi5nZXRUaW1lKCk7XG4gICAgfVxuICAgIHJldHVybiBvYmoxID09PSBvYmoyO1xufVxuXG4vKipcbiAqQGhpZGRlblxuICovXG5leHBvcnQgY29uc3QgZW51bSBLRVlDT0RFUyB7XG4gICAgRU5URVIgPSAxMyxcbiAgICBTUEFDRSA9IDMyLFxuICAgIEVTQ0FQRSA9IDI3LFxuICAgIExFRlRfQVJST1cgPSAzNyxcbiAgICBVUF9BUlJPVyA9IDM4LFxuICAgIFJJR0hUX0FSUk9XID0gMzksXG4gICAgRE9XTl9BUlJPVyA9IDQwLFxuICAgIEYyID0gMTEzLFxuICAgIFRBQiA9IDlcbn1cblxuLyoqXG4gKkBoaWRkZW5cbiAqL1xuZXhwb3J0IGNvbnN0IGVudW0gS0VZUyB7XG4gICAgRU5URVIgPSAnRW50ZXInLFxuICAgIFNQQUNFID0gJyAnLFxuICAgIFNQQUNFX0lFID0gJ1NwYWNlYmFyJyxcbiAgICBFU0NBUEUgPSAnRXNjYXBlJyxcbiAgICBFU0NBUEVfSUUgPSAnRXNjJyxcbiAgICBMRUZUX0FSUk9XID0gJ0Fycm93TGVmdCcsXG4gICAgTEVGVF9BUlJPV19JRSA9ICdMZWZ0JyxcbiAgICBVUF9BUlJPVyA9ICdBcnJvd1VwJyxcbiAgICBVUF9BUlJPV19JRSA9ICdVcCcsXG4gICAgUklHSFRfQVJST1cgPSAnQXJyb3dSaWdodCcsXG4gICAgUklHSFRfQVJST1dfSUUgPSAnUmlnaHQnLFxuICAgIERPV05fQVJST1cgPSAnQXJyb3dEb3duJyxcbiAgICBET1dOX0FSUk9XX0lFID0gJ0Rvd24nLFxuICAgIEYyID0gJ0YyJyxcbiAgICBUQUIgPSAnVGFiJ1xufVxuXG4vKipcbiAqQGhpZGRlblxuKiBSZXR1cm5zIHRoZSBhY3R1YWwgc2l6ZSBvZiB0aGUgbm9kZSBjb250ZW50LCB1c2luZyBSYW5nZVxuKiBgYGB0eXBlc2NyaXB0XG4qIGxldCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4qIGxldCBjb2x1bW4gPSB0aGlzLmdyaWQuY29sdW1uTGlzdC5maWx0ZXIoYyA9PiBjLmZpZWxkID09PSAnSUQnKVswXTtcbipcbiogbGV0IHNpemUgPSBnZXROb2RlU2l6ZVZpYVJhbmdlKHJhbmdlLCBjb2x1bW4uY2VsbHNbMF0ubmF0aXZlRWxlbWVudCk7XG4qIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Tm9kZVNpemVWaWFSYW5nZShyYW5nZTogUmFuZ2UsIG5vZGU6IGFueSk6IG51bWJlciB7XG4gICAgbGV0IG92ZXJmbG93ID0gbnVsbDtcbiAgICBpZiAoIWlzRmlyZWZveCgpKSB7XG4gICAgICAgIG92ZXJmbG93ID0gbm9kZS5zdHlsZS5vdmVyZmxvdztcbiAgICAgICAgLy8gd2UgbmVlZCB0aGF0IGhhY2sgLSBvdGhlcndpc2UgY29udGVudCB3b24ndCBiZSBtZWFzdXJlZCBjb3JyZWN0bHkgaW4gSUUvRWRnZVxuICAgICAgICBub2RlLnN0eWxlLm92ZXJmbG93ID0gJ3Zpc2libGUnO1xuICAgIH1cblxuICAgIHJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyhub2RlKTtcbiAgICBjb25zdCB3aWR0aCA9IHJhbmdlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuXG4gICAgaWYgKCFpc0ZpcmVmb3goKSkge1xuICAgICAgICAvLyB3ZSBuZWVkIHRoYXQgaGFjayAtIG90aGVyd2lzZSBjb250ZW50IHdvbid0IGJlIG1lYXN1cmVkIGNvcnJlY3RseSBpbiBJRS9FZGdlXG4gICAgICAgIG5vZGUuc3R5bGUub3ZlcmZsb3cgPSBvdmVyZmxvdztcbiAgICB9XG5cbiAgICByZXR1cm4gd2lkdGg7XG59XG4vKipcbiAqQGhpZGRlblxuKiBSZXR1cm5zIHRoZSBhY3R1YWwgc2l6ZSBvZiB0aGUgbm9kZSBjb250ZW50LCB1c2luZyBDYW52YXNcbiogYGBgdHlwZXNjcmlwdFxuKiBsZXQgY3R4ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJykuZ2V0Q29udGV4dCgnMmQnKTtcbiogbGV0IGNvbHVtbiA9IHRoaXMuZ3JpZC5jb2x1bW5MaXN0LmZpbHRlcihjID0+IGMuZmllbGQgPT09ICdJRCcpWzBdO1xuKlxuKiBsZXQgc2l6ZSA9IHZhbFRvUHhsc1VzaW5nQ2FudmFzKGN0eCwgY29sdW1uLmNlbGxzWzBdLm5hdGl2ZUVsZW1lbnQpO1xuKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldE5vZGVTaXplVmlhQ2FudmFzKGNhbnZhczJkQ3R4OiBhbnksIG5vZGU6IGFueSk6IG51bWJlciB7XG4gICAgY29uc3QgcyA9IHRoaXMuZ3JpZC5kb2N1bWVudC5kZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuXG4gICAgLy8gbmVlZCB0byBzZXQgdGhlIGZvbnQgdG8gZ2V0IGNvcnJlY3Qgd2lkdGhcbiAgICBjYW52YXMyZEN0eC5mb250ID0gcy5mb250U2l6ZSArICcgJyArIHMuZm9udEZhbWlseTtcblxuICAgIHJldHVybiBjYW52YXMyZEN0eC5tZWFzdXJlVGV4dChub2RlLnRleHRDb250ZW50KS53aWR0aDtcbn1cbi8qKlxuICpAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0lFKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBuYXZpZ2F0b3IuYXBwVmVyc2lvbi5pbmRleE9mKCdUcmlkZW50LycpID4gMDtcbn1cbi8qKlxuICpAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0VkZ2UoKTogYm9vbGVhbiB7XG4gICAgY29uc3QgZWRnZUJyb3dzZXIgPSAvRWRnZVtcXC9cXHNdKFxcZCtcXC5cXGQrKS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICByZXR1cm4gZWRnZUJyb3dzZXI7XG59XG5cbi8qKlxuICpAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0ZpcmVmb3goKTogYm9vbGVhbiB7XG4gICAgY29uc3QgZmlyZWZveEJyb3dzZXIgPSAvRmlyZWZveFtcXC9cXHNdKFxcZCtcXC5cXGQrKS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICByZXR1cm4gZmlyZWZveEJyb3dzZXI7XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5ASW5qZWN0YWJsZSh7IHByb3ZpZGVkSW46ICdyb290JyB9KVxuZXhwb3J0IGNsYXNzIFBsYXRmb3JtVXRpbCB7XG4gICAgcHVibGljIGlzQnJvd3NlcjogYm9vbGVhbiA9IGlzUGxhdGZvcm1Ccm93c2VyKHRoaXMucGxhdGZvcm1JZCk7XG5cbiAgICBwdWJsaWMgaXNJT1MgPSB0aGlzLmlzQnJvd3NlciAmJiAvaVBhZHxpUGhvbmV8aVBvZC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhKCdNU1N0cmVhbScgaW4gd2luZG93KTtcblxuICAgIGNvbnN0cnVjdG9yKEBJbmplY3QoUExBVEZPUk1fSUQpIHByaXZhdGUgcGxhdGZvcm1JZDogT2JqZWN0KSB7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTGVmdENsaWNrKGV2ZW50OiBQb2ludGVyRXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQuYnV0dG9uID09PSAwO1xufVxuXG4vKiogQGhpZGRlbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzTmF2aWdhdGlvbktleShrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBbXG4gICAgICAgICdkb3duJyxcbiAgICAgICAgJ3VwJyxcbiAgICAgICAgJ2xlZnQnLFxuICAgICAgICAncmlnaHQnLFxuICAgICAgICAnYXJyb3dkb3duJyxcbiAgICAgICAgJ2Fycm93dXAnLFxuICAgICAgICAnYXJyb3dsZWZ0JyxcbiAgICAgICAgJ2Fycm93cmlnaHQnLFxuICAgICAgICAnaG9tZScsXG4gICAgICAgICdlbmQnLFxuICAgICAgICAnc3BhY2UnLFxuICAgICAgICAnc3BhY2ViYXInLFxuICAgICAgICAnICdcbiAgICBdLmluZGV4T2Yoa2V5KSAhPT0gLTE7XG59XG5cbi8qKlxuICpAaGlkZGVuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbGF0dGVuKGFycjogYW55W10pIHtcbiAgICBsZXQgcmVzdWx0ID0gW107XG5cbiAgICBhcnIuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGVsKTtcbiAgICAgICAgaWYgKGVsLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IEFycmF5LmlzQXJyYXkoZWwuY2hpbGRyZW4pID8gZWwuY2hpbGRyZW4gOiBlbC5jaGlsZHJlbi50b0FycmF5KCk7XG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KGZsYXR0ZW4oY2hpbGRyZW4pKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2FuY2VsYWJsZUV2ZW50QXJncyB7XG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgdGhlIGFiaWxpdHkgdG8gY2FuY2VsIHRoZSBldmVudC5cbiAgICAgKi9cbiAgICBjYW5jZWw6IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUJhc2VFdmVudEFyZ3Mge1xuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIHJlZmVyZW5jZSB0byB0aGUgb3duZXIgY29tcG9uZW50LlxuICAgICAqL1xuICAgIG93bmVyPzogYW55O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENhbmNlbGFibGVCcm93c2VyRXZlbnRBcmdzIGV4dGVuZHMgQ2FuY2VsYWJsZUV2ZW50QXJncyB7XG4gICAgLyoqIEJyb3dzZXIgZXZlbnQgKi9cbiAgICBldmVudD86IEV2ZW50O1xufVxuXG5leHBvcnQgY29uc3QgTkFWSUdBVElPTl9LRVlTID0gbmV3IFNldChbXG4gICAgJ2Rvd24nLFxuICAgICd1cCcsXG4gICAgJ2xlZnQnLFxuICAgICdyaWdodCcsXG4gICAgJ2Fycm93ZG93bicsXG4gICAgJ2Fycm93dXAnLFxuICAgICdhcnJvd2xlZnQnLFxuICAgICdhcnJvd3JpZ2h0JyxcbiAgICAnaG9tZScsXG4gICAgJ2VuZCcsXG4gICAgJ3NwYWNlJyxcbiAgICAnc3BhY2ViYXInLFxuICAgICcgJ1xuXSk7XG5leHBvcnQgY29uc3QgUk9XX0VYUEFORF9LRVlTID0gbmV3IFNldCgncmlnaHQgZG93biBhcnJvd3JpZ2h0IGFycm93ZG93bicuc3BsaXQoJyAnKSk7XG5leHBvcnQgY29uc3QgUk9XX0NPTExBUFNFX0tFWVMgPSBuZXcgU2V0KCdsZWZ0IHVwIGFycm93bGVmdCBhcnJvd3VwJy5zcGxpdCgnICcpKTtcbmV4cG9ydCBjb25zdCBTVVBQT1JURURfS0VZUyA9IG5ldyBTZXQoWy4uLkFycmF5LmZyb20oTkFWSUdBVElPTl9LRVlTKSwgJ3RhYicsICdlbnRlcicsICdmMicsICdlc2NhcGUnLCAnZXNjJ10pO1xuIl19