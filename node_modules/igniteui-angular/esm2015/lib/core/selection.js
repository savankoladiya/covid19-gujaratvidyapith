/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Injectable } from '@angular/core';
import * as i0 from "@angular/core";
/**
 * @hidden
 */
export class IgxSelectionAPIService {
    constructor() {
        /**
         * If primaryKey is defined, then multiple selection is based on the primaryKey, and it is array of numbers, strings, etc.
         * If the primaryKey is omitted, then selection is based on the item data
         */
        this.selection = new Map();
    }
    /**
     * Get current component selection.
     * @param {?} componentID ID of the component.
     * @return {?}
     */
    get(componentID) {
        return this.selection.get(componentID);
    }
    /**
     * Set new component selection.
     * @param {?} componentID ID of the component.
     * @param {?} newSelection The new component selection to be set.
     * @return {?}
     */
    set(componentID, newSelection) {
        if (!componentID) {
            throw Error('Invalid value for component id!');
        }
        this.selection.set(componentID, newSelection);
    }
    /**
     * Clears selection for component.
     * @param {?} componentID ID of the component.
     * @return {?}
     */
    clear(componentID) {
        this.selection.set(componentID, this.get_empty());
    }
    /**
     * Get current component selection length.
     * @param {?} componentID ID of the component.
     * @return {?}
     */
    size(componentID) {
        /** @type {?} */
        const sel = this.get(componentID);
        return sel ? sel.size : 0;
    }
    /**
     * Creates new selection that consist of the new item added to the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the select_item() one.
     * @param {?} componentID ID of the component, which we add new item to.
     * @param {?} itemID ID of the item to add to component selection.
     * @param {?=} sel Used internally only by the selection (add_items method) to accumulate selection for multiple items.
     *
     * @return {?} Selection after the new item is added.
     */
    add_item(componentID, itemID, sel) {
        if (!sel) {
            sel = new Set(this.get(componentID));
        }
        if (sel === undefined) {
            sel = this.get_empty();
        }
        if (!itemID && itemID !== 0) {
            throw Error('Invalid value for item id!');
        }
        sel.add(itemID);
        return sel;
    }
    /**
     * Creates new selection that consist of the new items added to the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the select_items() one.
     * @param {?} componentID ID of the component, which we add new items to.
     * @param {?} itemIDs Array of IDs of the items to add to component selection.
     * @param {?=} clearSelection If true it will clear previous selection.
     *
     * @return {?} Selection after the new items are added.
     */
    add_items(componentID, itemIDs, clearSelection) {
        /** @type {?} */
        let selection;
        if (clearSelection) {
            selection = this.get_empty();
        }
        else if (itemIDs && itemIDs.length === 0) {
            selection = new Set(this.get(componentID));
        }
        itemIDs.forEach((item) => selection = this.add_item(componentID, item, selection));
        return selection;
    }
    /**
     * Add item to the current component selection.
     * @param {?} componentID ID of the component, which we add new item to.
     * @param {?} itemID ID of the item to add to component selection.
     * @param {?=} sel Used internally only by the selection (select_items method) to accumulate selection for multiple items.
     * @return {?}
     */
    select_item(componentID, itemID, sel) {
        this.set(componentID, this.add_item(componentID, itemID, sel));
    }
    /**
     * Add items to the current component selection.
     * @param {?} componentID ID of the component, which we add new items to.
     * @param {?} itemID
     * @param {?=} clearSelection If true it will clear previous selection.
     * @return {?}
     */
    select_items(componentID, itemID, clearSelection) {
        this.set(componentID, this.add_items(componentID, itemID, clearSelection));
    }
    /**
     * Creates new selection that consist of the new items excluded from the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the deselect_item() one.
     * @param {?} componentID ID of the component, which we remove items from.
     * @param {?} itemID ID of the item to remove from component selection.
     * @param {?=} sel Used internally only by the selection (delete_items method) to accumulate deselected items.
     *
     * @return {?} Selection after the item is removed.
     */
    delete_item(componentID, itemID, sel) {
        if (!sel) {
            sel = new Set(this.get(componentID));
        }
        if (sel === undefined) {
            return;
        }
        sel.delete(itemID);
        return sel;
    }
    /**
     * Creates new selection that consist of the new items removed to the current component selection.
     * The returned collection is new Set,
     * therefore if you want to update component selection you need to call in addition the set_selection() method
     * or instead use the deselect_items() one.
     * @param {?} componentID ID of the component, which we remove items from.
     * @param {?} itemIDs
     * @return {?} Selection after the items are removed.
     */
    delete_items(componentID, itemIDs) {
        /** @type {?} */
        let selection;
        itemIDs.forEach((deselectedItem) => selection = this.delete_item(componentID, deselectedItem, selection));
        return selection;
    }
    /**
     * Remove item from the current component selection.
     * @param {?} componentID ID of the component, which we remove item from.
     * @param {?} itemID ID of the item to remove from component selection.
     * @param {?=} sel Used internally only by the selection (deselect_items method) to accumulate selection for multiple items.
     * @return {?}
     */
    deselect_item(componentID, itemID, sel) {
        this.set(componentID, this.delete_item(componentID, itemID, sel));
    }
    /**
     * Remove items to the current component selection.
     * @param {?} componentID ID of the component, which we add new items to.
     * @param {?} itemID
     * @param {?=} clearSelection
     * @return {?}
     */
    deselect_items(componentID, itemID, clearSelection) {
        this.set(componentID, this.delete_items(componentID, itemID));
    }
    /**
     * Check if the item is selected in the component selection.
     * @param {?} componentID ID of the component.
     * @param {?} itemID ID of the item to search.
     *
     * @return {?} If item is selected.
     */
    is_item_selected(componentID, itemID) {
        /** @type {?} */
        const sel = this.get(componentID);
        if (!sel) {
            return false;
        }
        return sel.has(itemID);
    }
    /**
     * Get first element in the selection.
     * This is correct when we have only one item in the collection (for single selection purposes)
     * and the method returns that item.
     * @param {?} componentID ID of the component.
     *
     * @return {?} First element in the set.
     */
    first_item(componentID) {
        /** @type {?} */
        const sel = this.get(componentID);
        if (sel && sel.size > 0) {
            return sel.values().next().value;
        }
    }
    /**
     * Returns whether all items are selected.
     * @param {?} componentID ID of the component.
     * @param {?} dataCount
     * @return {?} If all items are selected.
     */
    are_all_selected(componentID, dataCount) {
        return dataCount > 0 && dataCount === this.size(componentID);
    }
    /**
     * Returns whether any of the items is selected.
     * @param {?} componentID ID of the component.
     * @return {?} If there is any item selected.
     */
    are_none_selected(componentID) {
        return this.size(componentID) === 0;
    }
    /**
     * Get all primary key values from a data array. If there isn't a primary key defined that the entire data is returned instead.
     * @param {?} data Entire data array.
     * @param {?=} primaryKey Data primary key.
     *
     * @return {?} Array of identifiers, either primary key values or the entire data array.
     */
    get_all_ids(data, primaryKey) {
        // If primaryKey is 0, this should still map to the property
        return primaryKey !== undefined && primaryKey !== null ? data.map((x) => x[primaryKey]) : data;
    }
    /**
     * Returns empty selection collection.
     * @return {?} empty set.
     */
    get_empty() {
        return new Set();
    }
}
IgxSelectionAPIService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */ IgxSelectionAPIService.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function IgxSelectionAPIService_Factory() { return new IgxSelectionAPIService(); }, token: IgxSelectionAPIService, providedIn: "root" });
if (false) {
    /**
     * If primaryKey is defined, then multiple selection is based on the primaryKey, and it is array of numbers, strings, etc.
     * If the primaryKey is omitted, then selection is based on the item data
     * @type {?}
     * @protected
     */
    IgxSelectionAPIService.prototype.selection;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsZWN0aW9uLmpzIiwic291cmNlUm9vdCI6Im5nOi8vaWduaXRldWktYW5ndWxhci8iLCJzb3VyY2VzIjpbImxpYi9jb3JlL3NlbGVjdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQzs7Ozs7QUFNM0MsTUFBTSxPQUFPLHNCQUFzQjtJQUhuQzs7Ozs7UUFRYyxjQUFTLEdBQTJCLElBQUksR0FBRyxFQUFvQixDQUFDO0tBME83RTs7Ozs7O0lBcE9VLEdBQUcsQ0FBQyxXQUFtQjtRQUMxQixPQUFPLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDO0lBQzNDLENBQUM7Ozs7Ozs7SUFPTSxHQUFHLENBQUMsV0FBbUIsRUFBRSxZQUFzQjtRQUNsRCxJQUFJLENBQUMsV0FBVyxFQUFFO1lBQ2QsTUFBTSxLQUFLLENBQUMsaUNBQWlDLENBQUMsQ0FBQztTQUNsRDtRQUNELElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLFdBQVcsRUFBRSxZQUFZLENBQUMsQ0FBQztJQUNsRCxDQUFDOzs7Ozs7SUFNTSxLQUFLLENBQUMsV0FBbUI7UUFDNUIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDO0lBQ3RELENBQUM7Ozs7OztJQU1NLElBQUksQ0FBQyxXQUFtQjs7Y0FDckIsR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDO1FBQ2pDLE9BQU8sR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDOUIsQ0FBQzs7Ozs7Ozs7Ozs7O0lBYU0sUUFBUSxDQUFDLFdBQW1CLEVBQUUsTUFBTSxFQUFFLEdBQWM7UUFDdkQsSUFBSSxDQUFDLEdBQUcsRUFBRTtZQUNOLEdBQUcsR0FBRyxJQUFJLEdBQUcs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O2dCQUNSLFVBQVUsRUFBRSxNQUFNO2FBQ3JCOzs7Ozs7Ozs7O0lBTUcsMkNBQTBFIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuXG4vKiogQGhpZGRlbiAqL1xuQEluamVjdGFibGUoe1xuICAgIHByb3ZpZGVkSW46ICdyb290Jyxcbn0pXG5leHBvcnQgY2xhc3MgSWd4U2VsZWN0aW9uQVBJU2VydmljZSB7XG4gICAgLyoqXG4gICAgICogSWYgcHJpbWFyeUtleSBpcyBkZWZpbmVkLCB0aGVuIG11bHRpcGxlIHNlbGVjdGlvbiBpcyBiYXNlZCBvbiB0aGUgcHJpbWFyeUtleSwgYW5kIGl0IGlzIGFycmF5IG9mIG51bWJlcnMsIHN0cmluZ3MsIGV0Yy5cbiAgICAgKiBJZiB0aGUgcHJpbWFyeUtleSBpcyBvbWl0dGVkLCB0aGVuIHNlbGVjdGlvbiBpcyBiYXNlZCBvbiB0aGUgaXRlbSBkYXRhXG4gICAgICovXG4gICAgcHJvdGVjdGVkIHNlbGVjdGlvbjogTWFwPHN0cmluZywgIFNldDxhbnk+PiA9IG5ldyBNYXA8c3RyaW5nLCBTZXQ8YW55Pj4oKTtcblxuICAgIC8qKlxuICAgICAqIEdldCBjdXJyZW50IGNvbXBvbmVudCBzZWxlY3Rpb24uXG4gICAgICogQHBhcmFtIGNvbXBvbmVudElEIElEIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICovXG4gICAgcHVibGljIGdldChjb21wb25lbnRJRDogc3RyaW5nKTogU2V0PGFueT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24uZ2V0KGNvbXBvbmVudElEKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgbmV3IGNvbXBvbmVudCBzZWxlY3Rpb24uXG4gICAgICogQHBhcmFtIGNvbXBvbmVudElEIElEIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIG5ld1NlbGVjdGlvbiBUaGUgbmV3IGNvbXBvbmVudCBzZWxlY3Rpb24gdG8gYmUgc2V0LlxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQoY29tcG9uZW50SUQ6IHN0cmluZywgbmV3U2VsZWN0aW9uOiBTZXQ8YW55Pikge1xuICAgICAgICBpZiAoIWNvbXBvbmVudElEKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCB2YWx1ZSBmb3IgY29tcG9uZW50IGlkIScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uLnNldChjb21wb25lbnRJRCwgbmV3U2VsZWN0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgc2VsZWN0aW9uIGZvciBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIGNvbXBvbmVudElEIElEIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICovXG4gICAgcHVibGljIGNsZWFyKGNvbXBvbmVudElEOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb24uc2V0KGNvbXBvbmVudElELCB0aGlzLmdldF9lbXB0eSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY3VycmVudCBjb21wb25lbnQgc2VsZWN0aW9uIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0gY29tcG9uZW50SUQgSUQgb2YgdGhlIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICBwdWJsaWMgc2l6ZShjb21wb25lbnRJRDogc3RyaW5nKTogbnVtYmVyIHtcbiAgICAgICAgY29uc3Qgc2VsID0gdGhpcy5nZXQoY29tcG9uZW50SUQpO1xuICAgICAgICByZXR1cm4gc2VsID8gc2VsLnNpemUgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgbmV3IHNlbGVjdGlvbiB0aGF0IGNvbnNpc3Qgb2YgdGhlIG5ldyBpdGVtIGFkZGVkIHRvIHRoZSBjdXJyZW50IGNvbXBvbmVudCBzZWxlY3Rpb24uXG4gICAgICogVGhlIHJldHVybmVkIGNvbGxlY3Rpb24gaXMgbmV3IFNldCxcbiAgICAgKiB0aGVyZWZvcmUgaWYgeW91IHdhbnQgdG8gdXBkYXRlIGNvbXBvbmVudCBzZWxlY3Rpb24geW91IG5lZWQgdG8gY2FsbCBpbiBhZGRpdGlvbiB0aGUgc2V0X3NlbGVjdGlvbigpIG1ldGhvZFxuICAgICAqIG9yIGluc3RlYWQgdXNlIHRoZSBzZWxlY3RfaXRlbSgpIG9uZS5cbiAgICAgKiBAcGFyYW0gY29tcG9uZW50SUQgSUQgb2YgdGhlIGNvbXBvbmVudCwgd2hpY2ggd2UgYWRkIG5ldyBpdGVtIHRvLlxuICAgICAqIEBwYXJhbSBpdGVtSUQgSUQgb2YgdGhlIGl0ZW0gdG8gYWRkIHRvIGNvbXBvbmVudCBzZWxlY3Rpb24uXG4gICAgICogQHBhcmFtIHNlbCBVc2VkIGludGVybmFsbHkgb25seSBieSB0aGUgc2VsZWN0aW9uIChhZGRfaXRlbXMgbWV0aG9kKSB0byBhY2N1bXVsYXRlIHNlbGVjdGlvbiBmb3IgbXVsdGlwbGUgaXRlbXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBTZWxlY3Rpb24gYWZ0ZXIgdGhlIG5ldyBpdGVtIGlzIGFkZGVkLlxuICAgICAqL1xuICAgIHB1YmxpYyBhZGRfaXRlbShjb21wb25lbnRJRDogc3RyaW5nLCBpdGVtSUQsIHNlbD86IFNldDxhbnk+KTogU2V0PGFueT4ge1xuICAgICAgICBpZiAoIXNlbCkge1xuICAgICAgICAgICAgc2VsID0gbmV3IFNldCh0aGlzLmdldChjb21wb25lbnRJRCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc2VsID0gdGhpcy5nZXRfZW1wdHkoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWl0ZW1JRCAmJiBpdGVtSUQgIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIHZhbHVlIGZvciBpdGVtIGlkIScpO1xuICAgICAgICB9XG4gICAgICAgIHNlbC5hZGQoaXRlbUlEKTtcbiAgICAgICAgcmV0dXJuIHNlbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG5ldyBzZWxlY3Rpb24gdGhhdCBjb25zaXN0IG9mIHRoZSBuZXcgaXRlbXMgYWRkZWQgdG8gdGhlIGN1cnJlbnQgY29tcG9uZW50IHNlbGVjdGlvbi5cbiAgICAgKiBUaGUgcmV0dXJuZWQgY29sbGVjdGlvbiBpcyBuZXcgU2V0LFxuICAgICAqIHRoZXJlZm9yZSBpZiB5b3Ugd2FudCB0byB1cGRhdGUgY29tcG9uZW50IHNlbGVjdGlvbiB5b3UgbmVlZCB0byBjYWxsIGluIGFkZGl0aW9uIHRoZSBzZXRfc2VsZWN0aW9uKCkgbWV0aG9kXG4gICAgICogb3IgaW5zdGVhZCB1c2UgdGhlIHNlbGVjdF9pdGVtcygpIG9uZS5cbiAgICAgKiBAcGFyYW0gY29tcG9uZW50SUQgSUQgb2YgdGhlIGNvbXBvbmVudCwgd2hpY2ggd2UgYWRkIG5ldyBpdGVtcyB0by5cbiAgICAgKiBAcGFyYW0gaXRlbUlEcyBBcnJheSBvZiBJRHMgb2YgdGhlIGl0ZW1zIHRvIGFkZCB0byBjb21wb25lbnQgc2VsZWN0aW9uLlxuICAgICAqIEBwYXJhbSBjbGVhclNlbGVjdGlvbiBJZiB0cnVlIGl0IHdpbGwgY2xlYXIgcHJldmlvdXMgc2VsZWN0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMgU2VsZWN0aW9uIGFmdGVyIHRoZSBuZXcgaXRlbXMgYXJlIGFkZGVkLlxuICAgICAqL1xuICAgIHB1YmxpYyBhZGRfaXRlbXMoY29tcG9uZW50SUQ6IHN0cmluZywgaXRlbUlEczogYW55W10sIGNsZWFyU2VsZWN0aW9uPzogYm9vbGVhbik6IFNldDxhbnk+IHtcbiAgICAgICAgbGV0IHNlbGVjdGlvbjogU2V0PGFueT47XG4gICAgICAgIGlmIChjbGVhclNlbGVjdGlvbikge1xuICAgICAgICAgICAgc2VsZWN0aW9uID0gdGhpcy5nZXRfZW1wdHkoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpdGVtSURzICYmIGl0ZW1JRHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb24gPSBuZXcgU2V0KHRoaXMuZ2V0KGNvbXBvbmVudElEKSk7XG4gICAgICAgIH1cbiAgICAgICAgaXRlbUlEcy5mb3JFYWNoKChpdGVtKSA9PiBzZWxlY3Rpb24gPSB0aGlzLmFkZF9pdGVtKGNvbXBvbmVudElELCBpdGVtLCBzZWxlY3Rpb24pKTtcbiAgICAgICAgcmV0dXJuIHNlbGVjdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgaXRlbSB0byB0aGUgY3VycmVudCBjb21wb25lbnQgc2VsZWN0aW9uLlxuICAgICAqIEBwYXJhbSBjb21wb25lbnRJRCBJRCBvZiB0aGUgY29tcG9uZW50LCB3aGljaCB3ZSBhZGQgbmV3IGl0ZW0gdG8uXG4gICAgICogQHBhcmFtIGl0ZW1JRCBJRCBvZiB0aGUgaXRlbSB0byBhZGQgdG8gY29tcG9uZW50IHNlbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0gc2VsIFVzZWQgaW50ZXJuYWxseSBvbmx5IGJ5IHRoZSBzZWxlY3Rpb24gKHNlbGVjdF9pdGVtcyBtZXRob2QpIHRvIGFjY3VtdWxhdGUgc2VsZWN0aW9uIGZvciBtdWx0aXBsZSBpdGVtcy5cbiAgICAgKi9cbiAgICBwdWJsaWMgc2VsZWN0X2l0ZW0oY29tcG9uZW50SUQ6IHN0cmluZywgaXRlbUlELCBzZWw/OiBTZXQ8YW55Pikge1xuICAgICAgICB0aGlzLnNldChjb21wb25lbnRJRCwgdGhpcy5hZGRfaXRlbShjb21wb25lbnRJRCwgaXRlbUlELCBzZWwpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgaXRlbXMgdG8gdGhlIGN1cnJlbnQgY29tcG9uZW50IHNlbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0gY29tcG9uZW50SUQgSUQgb2YgdGhlIGNvbXBvbmVudCwgd2hpY2ggd2UgYWRkIG5ldyBpdGVtcyB0by5cbiAgICAgKiBAcGFyYW0gaXRlbUlEcyBBcnJheSBvZiBJRHMgb2YgdGhlIGl0ZW1zIHRvIGFkZCB0byBjb21wb25lbnQgc2VsZWN0aW9uLlxuICAgICAqIEBwYXJhbSBjbGVhclNlbGVjdGlvbiBJZiB0cnVlIGl0IHdpbGwgY2xlYXIgcHJldmlvdXMgc2VsZWN0aW9uLlxuICAgICAqL1xuICAgIHB1YmxpYyBzZWxlY3RfaXRlbXMoY29tcG9uZW50SUQ6IHN0cmluZywgaXRlbUlEOiBhbnlbXSwgY2xlYXJTZWxlY3Rpb24/OiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuc2V0KGNvbXBvbmVudElELCB0aGlzLmFkZF9pdGVtcyhjb21wb25lbnRJRCwgaXRlbUlELCBjbGVhclNlbGVjdGlvbikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgbmV3IHNlbGVjdGlvbiB0aGF0IGNvbnNpc3Qgb2YgdGhlIG5ldyBpdGVtcyBleGNsdWRlZCBmcm9tIHRoZSBjdXJyZW50IGNvbXBvbmVudCBzZWxlY3Rpb24uXG4gICAgICogVGhlIHJldHVybmVkIGNvbGxlY3Rpb24gaXMgbmV3IFNldCxcbiAgICAgKiB0aGVyZWZvcmUgaWYgeW91IHdhbnQgdG8gdXBkYXRlIGNvbXBvbmVudCBzZWxlY3Rpb24geW91IG5lZWQgdG8gY2FsbCBpbiBhZGRpdGlvbiB0aGUgc2V0X3NlbGVjdGlvbigpIG1ldGhvZFxuICAgICAqIG9yIGluc3RlYWQgdXNlIHRoZSBkZXNlbGVjdF9pdGVtKCkgb25lLlxuICAgICAqIEBwYXJhbSBjb21wb25lbnRJRCBJRCBvZiB0aGUgY29tcG9uZW50LCB3aGljaCB3ZSByZW1vdmUgaXRlbXMgZnJvbS5cbiAgICAgKiBAcGFyYW0gaXRlbUlEIElEIG9mIHRoZSBpdGVtIHRvIHJlbW92ZSBmcm9tIGNvbXBvbmVudCBzZWxlY3Rpb24uXG4gICAgICogQHBhcmFtIHNlbCBVc2VkIGludGVybmFsbHkgb25seSBieSB0aGUgc2VsZWN0aW9uIChkZWxldGVfaXRlbXMgbWV0aG9kKSB0byBhY2N1bXVsYXRlIGRlc2VsZWN0ZWQgaXRlbXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBTZWxlY3Rpb24gYWZ0ZXIgdGhlIGl0ZW0gaXMgcmVtb3ZlZC5cbiAgICAgKi9cbiAgICBwdWJsaWMgZGVsZXRlX2l0ZW0oY29tcG9uZW50SUQ6IHN0cmluZywgaXRlbUlELCBzZWw/OiBTZXQ8YW55Pikge1xuICAgICAgICBpZiAoIXNlbCkge1xuICAgICAgICAgICAgc2VsID0gbmV3IFNldCh0aGlzLmdldChjb21wb25lbnRJRCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNlbC5kZWxldGUoaXRlbUlEKTtcbiAgICAgICAgcmV0dXJuIHNlbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIG5ldyBzZWxlY3Rpb24gdGhhdCBjb25zaXN0IG9mIHRoZSBuZXcgaXRlbXMgcmVtb3ZlZCB0byB0aGUgY3VycmVudCBjb21wb25lbnQgc2VsZWN0aW9uLlxuICAgICAqIFRoZSByZXR1cm5lZCBjb2xsZWN0aW9uIGlzIG5ldyBTZXQsXG4gICAgICogdGhlcmVmb3JlIGlmIHlvdSB3YW50IHRvIHVwZGF0ZSBjb21wb25lbnQgc2VsZWN0aW9uIHlvdSBuZWVkIHRvIGNhbGwgaW4gYWRkaXRpb24gdGhlIHNldF9zZWxlY3Rpb24oKSBtZXRob2RcbiAgICAgKiBvciBpbnN0ZWFkIHVzZSB0aGUgZGVzZWxlY3RfaXRlbXMoKSBvbmUuXG4gICAgICogQHBhcmFtIGNvbXBvbmVudElEIElEIG9mIHRoZSBjb21wb25lbnQsIHdoaWNoIHdlIHJlbW92ZSBpdGVtcyBmcm9tLlxuICAgICAqIEBwYXJhbSBpdGVtSUQgSUQgb2YgdGhlIGl0ZW1zIHRvIHJlbW92ZSBmcm9tIGNvbXBvbmVudCBzZWxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBTZWxlY3Rpb24gYWZ0ZXIgdGhlIGl0ZW1zIGFyZSByZW1vdmVkLlxuICAgICAqL1xuICAgIHB1YmxpYyBkZWxldGVfaXRlbXMoY29tcG9uZW50SUQ6IHN0cmluZywgaXRlbUlEczogYW55W10pOiBTZXQ8YW55PiB7XG4gICAgICAgIGxldCBzZWxlY3Rpb246IFNldDxhbnk+O1xuICAgICAgICBpdGVtSURzLmZvckVhY2goKGRlc2VsZWN0ZWRJdGVtKSA9PiBzZWxlY3Rpb24gPSB0aGlzLmRlbGV0ZV9pdGVtKGNvbXBvbmVudElELCBkZXNlbGVjdGVkSXRlbSwgc2VsZWN0aW9uKSk7XG4gICAgICAgIHJldHVybiBzZWxlY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGl0ZW0gZnJvbSB0aGUgY3VycmVudCBjb21wb25lbnQgc2VsZWN0aW9uLlxuICAgICAqIEBwYXJhbSBjb21wb25lbnRJRCBJRCBvZiB0aGUgY29tcG9uZW50LCB3aGljaCB3ZSByZW1vdmUgaXRlbSBmcm9tLlxuICAgICAqIEBwYXJhbSBpdGVtSUQgSUQgb2YgdGhlIGl0ZW0gdG8gcmVtb3ZlIGZyb20gY29tcG9uZW50IHNlbGVjdGlvbi5cbiAgICAgKiBAcGFyYW0gc2VsIFVzZWQgaW50ZXJuYWxseSBvbmx5IGJ5IHRoZSBzZWxlY3Rpb24gKGRlc2VsZWN0X2l0ZW1zIG1ldGhvZCkgdG8gYWNjdW11bGF0ZSBzZWxlY3Rpb24gZm9yIG11bHRpcGxlIGl0ZW1zLlxuICAgICAqL1xuICAgIHB1YmxpYyBkZXNlbGVjdF9pdGVtKGNvbXBvbmVudElEOiBzdHJpbmcsIGl0ZW1JRCwgc2VsPzogU2V0PGFueT4pIHtcbiAgICAgICAgdGhpcy5zZXQoY29tcG9uZW50SUQsIHRoaXMuZGVsZXRlX2l0ZW0oY29tcG9uZW50SUQsIGl0ZW1JRCwgc2VsKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGl0ZW1zIHRvIHRoZSBjdXJyZW50IGNvbXBvbmVudCBzZWxlY3Rpb24uXG4gICAgICogQHBhcmFtIGNvbXBvbmVudElEIElEIG9mIHRoZSBjb21wb25lbnQsIHdoaWNoIHdlIGFkZCBuZXcgaXRlbXMgdG8uXG4gICAgICogQHBhcmFtIGl0ZW1JRHMgQXJyYXkgb2YgSURzIG9mIHRoZSBpdGVtcyB0byBhZGQgdG8gY29tcG9uZW50IHNlbGVjdGlvbi5cbiAgICAgKi9cbiAgICBwdWJsaWMgZGVzZWxlY3RfaXRlbXMoY29tcG9uZW50SUQ6IHN0cmluZywgaXRlbUlEOiBhbnlbXSwgY2xlYXJTZWxlY3Rpb24/OiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuc2V0KGNvbXBvbmVudElELCB0aGlzLmRlbGV0ZV9pdGVtcyhjb21wb25lbnRJRCwgaXRlbUlEKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIGl0ZW0gaXMgc2VsZWN0ZWQgaW4gdGhlIGNvbXBvbmVudCBzZWxlY3Rpb24uXG4gICAgICogQHBhcmFtIGNvbXBvbmVudElEIElEIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIGl0ZW1JRCBJRCBvZiB0aGUgaXRlbSB0byBzZWFyY2guXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBJZiBpdGVtIGlzIHNlbGVjdGVkLlxuICAgICAqL1xuICAgIHB1YmxpYyBpc19pdGVtX3NlbGVjdGVkKGNvbXBvbmVudElEOiBzdHJpbmcsIGl0ZW1JRCk6IGJvb2xlYW4ge1xuICAgICAgICBjb25zdCBzZWwgPSB0aGlzLmdldChjb21wb25lbnRJRCk7XG4gICAgICAgIGlmICghc2VsKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbC5oYXMoaXRlbUlEKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgZmlyc3QgZWxlbWVudCBpbiB0aGUgc2VsZWN0aW9uLlxuICAgICAqIFRoaXMgaXMgY29ycmVjdCB3aGVuIHdlIGhhdmUgb25seSBvbmUgaXRlbSBpbiB0aGUgY29sbGVjdGlvbiAoZm9yIHNpbmdsZSBzZWxlY3Rpb24gcHVycG9zZXMpXG4gICAgICogYW5kIHRoZSBtZXRob2QgcmV0dXJucyB0aGF0IGl0ZW0uXG4gICAgICogQHBhcmFtIGNvbXBvbmVudElEIElEIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBGaXJzdCBlbGVtZW50IGluIHRoZSBzZXQuXG4gICAgICovXG4gICAgcHVibGljIGZpcnN0X2l0ZW0oY29tcG9uZW50SUQ6IHN0cmluZykge1xuICAgICAgICBjb25zdCBzZWwgPSB0aGlzLmdldChjb21wb25lbnRJRCk7XG4gICAgICAgIGlmIChzZWwgJiYgc2VsLnNpemUgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcbiAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIGFsbCBpdGVtcyBhcmUgc2VsZWN0ZWQuXG4gICAgICogQHBhcmFtIGNvbXBvbmVudElEIElEIG9mIHRoZSBjb21wb25lbnQuXG4gICAgICogQHBhcmFtIGRhdGFDb3VudDogbnVtYmVyIE51bWJlciBvZiBpdGVtcyBpbiB0aGUgZGF0YS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIElmIGFsbCBpdGVtcyBhcmUgc2VsZWN0ZWQuXG4gICAgICovXG4gICAgcHVibGljIGFyZV9hbGxfc2VsZWN0ZWQoY29tcG9uZW50SUQ6IHN0cmluZywgZGF0YUNvdW50OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGRhdGFDb3VudCA+IDAgJiYgZGF0YUNvdW50ID09PSB0aGlzLnNpemUoY29tcG9uZW50SUQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBhbnkgb2YgdGhlIGl0ZW1zIGlzIHNlbGVjdGVkLlxuICAgICAqIEBwYXJhbSBjb21wb25lbnRJRCBJRCBvZiB0aGUgY29tcG9uZW50LlxuICAgICAqIEBwYXJhbSBkYXRhIEVudGlyZSBkYXRhIGFycmF5LlxuICAgICAqXG4gICAgICogQHJldHVybnMgSWYgdGhlcmUgaXMgYW55IGl0ZW0gc2VsZWN0ZWQuXG4gICAgICovXG4gICAgcHVibGljIGFyZV9ub25lX3NlbGVjdGVkKGNvbXBvbmVudElEOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZShjb21wb25lbnRJRCkgPT09IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBwcmltYXJ5IGtleSB2YWx1ZXMgZnJvbSBhIGRhdGEgYXJyYXkuIElmIHRoZXJlIGlzbid0IGEgcHJpbWFyeSBrZXkgZGVmaW5lZCB0aGF0IHRoZSBlbnRpcmUgZGF0YSBpcyByZXR1cm5lZCBpbnN0ZWFkLlxuICAgICAqIEBwYXJhbSBkYXRhIEVudGlyZSBkYXRhIGFycmF5LlxuICAgICAqIEBwYXJhbSBwcmltYXJ5S2V5IERhdGEgcHJpbWFyeSBrZXkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBcnJheSBvZiBpZGVudGlmaWVycywgZWl0aGVyIHByaW1hcnkga2V5IHZhbHVlcyBvciB0aGUgZW50aXJlIGRhdGEgYXJyYXkuXG4gICAgICovXG4gICAgcHVibGljIGdldF9hbGxfaWRzKGRhdGEsIHByaW1hcnlLZXk/KSB7XG4gICAgICAgIC8vIElmIHByaW1hcnlLZXkgaXMgMCwgdGhpcyBzaG91bGQgc3RpbGwgbWFwIHRvIHRoZSBwcm9wZXJ0eVxuICAgICAgICByZXR1cm4gcHJpbWFyeUtleSAhPT0gdW5kZWZpbmVkICYmIHByaW1hcnlLZXkgIT09IG51bGwgPyBkYXRhLm1hcCgoeCkgPT4geFtwcmltYXJ5S2V5XSkgOiBkYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZW1wdHkgc2VsZWN0aW9uIGNvbGxlY3Rpb24uXG4gICAgICogQHJldHVybnMgZW1wdHkgc2V0LlxuICAgICovXG4gICAgcHVibGljIGdldF9lbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXQoKTtcbiAgICB9XG59XG4iXX0=