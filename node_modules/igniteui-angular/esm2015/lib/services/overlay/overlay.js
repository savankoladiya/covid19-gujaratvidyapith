/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { DOCUMENT } from '@angular/common';
import { GlobalPositionStrategy } from './position/global-position-strategy';
import { NoOpScrollStrategy } from './scroll/NoOpScrollStrategy';
import { ApplicationRef, ComponentFactoryResolver, ElementRef, EventEmitter, Inject, Injectable, Injector, NgZone } from '@angular/core';
import { AnimationBuilder } from '@angular/animations';
import { fromEvent, Subject } from 'rxjs';
import { filter, takeUntil } from 'rxjs/operators';
import { showMessage } from '../../core/deprecateDecorators';
import * as i0 from "@angular/core";
import * as i1 from "@angular/animations";
import * as i2 from "@angular/common";
/** @type {?} */
let warningShown = false;
/**
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/overlay_main.html)
 * The overlay service allows users to show components on overlay div above all other elements in the page.
 */
export class IgxOverlayService {
    /**
     * @param {?} _factoryResolver
     * @param {?} _appRef
     * @param {?} _injector
     * @param {?} builder
     * @param {?} document
     * @param {?} _zone
     */
    constructor(_factoryResolver, _appRef, _injector, builder, document, _zone) {
        this._factoryResolver = _factoryResolver;
        this._appRef = _appRef;
        this._injector = _injector;
        this.builder = builder;
        this.document = document;
        this._zone = _zone;
        this._componentId = 0;
        this._overlayInfos = [];
        this.destroy$ = new Subject();
        this._defaultSettings = {
            positionStrategy: new GlobalPositionStrategy(),
            scrollStrategy: new NoOpScrollStrategy(),
            modal: true,
            closeOnOutsideClick: true
        };
        /**
         * Emitted before the component is opened.
         * ```typescript
         * onOpening(event: OverlayCancelableEventArgs){
         *     const onOpening = event;
         * }
         * ```
         */
        this.onOpening = new EventEmitter();
        /**
         * Emitted after the component is opened and all animations are finished.
         * ```typescript
         * onOpened(event: OverlayEventArgs){
         *     const onOpened = event;
         * }
         * ```
         */
        this.onOpened = new EventEmitter();
        /**
         * Emitted before the component is closed.
         * ```typescript
         * onClosing(event: OverlayCancelableEventArgs){
         *     const onClosing = event;
         * }
         * ```
         */
        this.onClosing = new EventEmitter();
        /**
         * Emitted after the component is closed and all animations are finished.
         * ```typescript
         * onClosed(event: OverlayEventArgs){
         *     const onClosed = event;
         * }
         * ```
         */
        this.onClosed = new EventEmitter();
        /**
         * Emitted before animation is started
         * ```typescript
         * onAnimation(event: OverlayAnimationEventArgs){
         *     const onAnimation = event;
         * }
         * ```
         */
        this.onAnimation = new EventEmitter();
        this.documentClicked = (ev) => {
            //  if we get to modal overlay just return - we should not close anything under it
            //  if we get to non-modal overlay do the next:
            //   1. Check it has close on outside click. If not go on to next overlay;
            //   2. If true check if click is on the element. If it is on the element we have closed
            //  already all previous non-modal with close on outside click elements, so we return. If
            //  not close the overlay and check next
            for (let i = this._overlayInfos.length; i--;) {
                /** @type {?} */
                const info = this._overlayInfos[i];
                if (info.settings.modal) {
                    return;
                }
                if (info.settings.closeOnOutsideClick) {
                    /** @type {?} */
                    const target = (/** @type {?} */ (ev.target));
                    //  if the click is on the element do not close this overlay
                    if (!info.elementRef.nativeElement.contains(target)) {
                        // if we should exclude position target check if the click is over it. If so do not close overlay
                        /** @type {?} */
                        const positionTarget = (/** @type {?} */ (info.settings.positionStrategy.settings.target));
                        /** @type {?} */
                        let clickOnPositionTarget = false;
                        if (positionTarget) {
                            clickOnPositionTarget = positionTarget.contains(target);
                        }
                        if (!(info.settings.excludePositionTarget && clickOnPositionTarget)) {
                            //  if the click is outside click, but close animation has started do nothing
                            if (!(info.closeAnimationPlayer && info.closeAnimationPlayer.hasStarted())) {
                                this._hide(info.id, ev);
                            }
                        }
                    }
                    else {
                        //  TODO: should we return here, or continue with next overlays
                        return;
                    }
                }
            }
        };
        /**
         * @hidden
         */
        this.repositionAll = () => {
            for (let i = this._overlayInfos.length; i--;) {
                this.reposition(this._overlayInfos[i].id);
            }
        };
        this._document = (/** @type {?} */ (this.document));
    }
    /**
     * @param {?} component
     * @param {?=} settings
     * @param {?=} moduleRef
     * @return {?}
     */
    attach(component, settings, moduleRef) {
        /** @type {?} */
        let info;
        info = this.getOverlayInfo(component, moduleRef);
        //  if there is no info most probably wrong type component was provided and we just go out
        if (!info) {
            return null;
        }
        info.id = (this._componentId++).toString();
        settings = Object.assign({}, this._defaultSettings, settings);
        info.settings = settings;
        this._overlayInfos.push(info);
        return info.id;
    }
    /**
     * @param {?} compOrId
     * @param {?=} settings
     * @return {?}
     */
    show(compOrId, settings) {
        /** @type {?} */
        let info;
        /** @type {?} */
        let id;
        if (typeof compOrId === 'string') {
            id = compOrId;
            info = this.getOverlayById(compOrId);
            if (!info) {
                console.warn('igxOverlay.show was called with wrong id: ' + compOrId);
                return null;
            }
        }
        else {
            warningShown = showMessage('`show(component, settings?)` overload is deprecated. Use `attach(component)` to obtain an Id.' +
                'Then `show(id, settings?)` with provided Id.', warningShown);
            id = (this._componentId++).toString();
            info = this.getOverlayInfo(compOrId);
            //  if there is no info most probably wrong type component was provided and we just go out
            if (!info) {
                return;
            }
            info.id = id;
        }
        settings = Object.assign({}, this._defaultSettings, info.settings, settings);
        info.settings = settings;
        this._show(info);
        return id;
    }
    /**
     * Hides the component with the ID provided as a parameter.
     * ```typescript
     * this.overlay.hide(id);
     * ```
     * @param {?} id
     * @return {?}
     */
    hide(id) {
        this._hide(id);
    }
    /**
     * Hides all the components and the overlay.
     * ```typescript
     * this.overlay.hideAll();
     * ```
     * @return {?}
     */
    hideAll() {
        // since overlays are removed on animation done, que all hides
        for (let i = this._overlayInfos.length; i--;) {
            this.hide(this._overlayInfos[i].id);
        }
    }
    /**
     * Repositions the component with ID provided as a parameter.
     * ```typescript
     * this.overlay.reposition(id);
     * ```
     * @param {?} id
     * @return {?}
     */
    reposition(id) {
        /** @type {?} */
        const overlayInfo = this.getOverlayById(id);
        if (!overlayInfo || !overlayInfo.settings) {
            console.error('Wrong id provided in overlay.reposition method. Id: ' + id);
            return;
        }
        /** @type {?} */
        const contentElement = overlayInfo.elementRef.nativeElement.parentElement;
        /** @type {?} */
        const contentElementRect = contentElement.getBoundingClientRect();
        overlayInfo.settings.positionStrategy.position(contentElement, {
            width: contentElementRect.width,
            height: contentElementRect.height
        }, this._document, false);
    }
    /**
     * @private
     * @param {?} info
     * @return {?}
     */
    _show(info) {
        /** @type {?} */
        const eventArgs = { id: info.id, componentRef: info.componentRef, cancel: false };
        this.onOpening.emit(eventArgs);
        if (eventArgs.cancel) {
            if (info.componentRef) {
                this._appRef.detachView(info.componentRef.hostView);
                info.componentRef.destroy();
            }
            return;
        }
        //  if there is no close animation player, or there is one but it is not started yet we are in clear
        //  opening. Otherwise, if there is close animation player playing animation now we should not setup
        //  overlay this is already done
        if (!info.closeAnimationPlayer || (info.closeAnimationPlayer && !info.closeAnimationPlayer.hasStarted())) {
            /** @type {?} */
            const elementRect = info.elementRef.nativeElement.getBoundingClientRect();
            info.initialSize = { width: elementRect.width, height: elementRect.height };
            info.hook = this.placeElementHook(info.elementRef.nativeElement);
            this.moveElementToOverlay(info);
            if (info.componentRef) {
                info.componentRef.changeDetectorRef.detectChanges();
            }
            this.updateSize(info);
            if (this._overlayInfos.indexOf(info) === -1) {
                this._overlayInfos.push(info);
            }
            info.settings.positionStrategy.position(info.elementRef.nativeElement.parentElement, { width: info.initialSize.width, height: info.initialSize.height }, document, true);
            info.settings.scrollStrategy.initialize(this._document, this, info.id);
            info.settings.scrollStrategy.attach();
        }
        this.addOutsideClickListener(info);
        this.addResizeHandler(info.id);
        if (info.settings.modal) {
            this.setupModalWrapper(info);
        }
        if (info.settings.positionStrategy.settings.openAnimation) {
            this.playOpenAnimation(info);
        }
        else {
            //  to eliminate flickering show the element just before onOpened fire
            info.elementRef.nativeElement.parentElement.style.visibility = '';
            this.onOpened.emit({ id: info.id, componentRef: info.componentRef });
        }
    }
    /**
     * @private
     * @param {?} id
     * @param {?=} event
     * @return {?}
     */
    _hide(id, event) {
        /** @type {?} */
        const info = this.getOverlayById(id);
        if (!info) {
            console.warn('igxOverlay.hide was called with wrong id: ' + id);
            return;
        }
        /** @type {?} */
        const eventArgs = { id, componentRef: info.componentRef, cancel: false, event };
        this.onClosing.emit(eventArgs);
        if (eventArgs.cancel) {
            return;
        }
        //  TODO: synchronize where these are added/attached and where removed/detached
        info.settings.scrollStrategy.detach();
        this.removeOutsideClickListener(info);
        this.removeResizeHandler(info.id);
        /** @type {?} */
        const child = info.elementRef.nativeElement;
        if (info.settings.modal) {
            /** @type {?} */
            const parent = (/** @type {?} */ (child.parentNode.parentNode));
            this.applyAnimationParams(parent, info.settings.positionStrategy.settings.closeAnimation);
            parent.classList.remove('igx-overlay__wrapper--modal');
            parent.classList.add('igx-overlay__wrapper');
        }
        if (info.settings.positionStrategy.settings.closeAnimation) {
            this.playCloseAnimation(info);
        }
        else {
            this.onCloseDone(info);
        }
    }
    /**
     * @private
     * @param {?} component
     * @param {?=} moduleRef
     * @return {?}
     */
    getOverlayInfo(component, moduleRef) {
        /** @type {?} */
        const info = { ngZone: this._zone };
        if (component instanceof ElementRef) {
            info.elementRef = (/** @type {?} */ (component));
        }
        else {
            /** @type {?} */
            let dynamicFactory;
            /** @type {?} */
            const factoryResolver = moduleRef ? moduleRef.componentFactoryResolver : this._factoryResolver;
            try {
                dynamicFactory = factoryResolver.resolveComponentFactory(component);
            }
            catch (error) {
                console.error(error);
                return null;
            }
            /** @type {?} */
            const injector = moduleRef ? moduleRef.injector : this._injector;
            /** @type {?} */
            const dynamicComponent = dynamicFactory.create(injector);
            this._appRef.attachView(dynamicComponent.hostView);
            // If the element is newly created from a Component, it is wrapped in 'ng-component' tag - we do not want that.
            /** @type {?} */
            const element = dynamicComponent.location.nativeElement;
            info.elementRef = (/** @type {?} */ ({ nativeElement: element }));
            info.componentRef = dynamicComponent;
        }
        return info;
    }
    /**
     * @private
     * @param {?} element
     * @return {?}
     */
    placeElementHook(element) {
        if (!element.parentElement) {
            return null;
        }
        /** @type {?} */
        const hook = this._document.createElement('div');
        element.parentElement.insertBefore(hook, element);
        return hook;
    }
    /**
     * @private
     * @param {?} info
     * @return {?}
     */
    moveElementToOverlay(info) {
        /** @type {?} */
        const wrapperElement = this.getWrapperElement();
        /** @type {?} */
        const contentElement = this.getContentElement(wrapperElement, info.settings.modal);
        this.getOverlayElement(info).appendChild(wrapperElement);
        /** @type {?} */
        const elementScrollTop = info.elementRef.nativeElement.scrollTop;
        contentElement.appendChild(info.elementRef.nativeElement);
        if (elementScrollTop) {
            info.elementRef.nativeElement.scrollTop = elementScrollTop;
        }
    }
    /**
     * @private
     * @return {?}
     */
    getWrapperElement() {
        /** @type {?} */
        const wrapper = this._document.createElement('div');
        wrapper.classList.add('igx-overlay__wrapper');
        return wrapper;
    }
    /**
     * @private
     * @param {?} wrapperElement
     * @param {?} modal
     * @return {?}
     */
    getContentElement(wrapperElement, modal) {
        /** @type {?} */
        const content = this._document.createElement('div');
        if (modal) {
            content.classList.add('igx-overlay__content--modal');
            content.addEventListener('click', (ev) => {
                ev.stopPropagation();
            });
        }
        else {
            content.classList.add('igx-overlay__content');
        }
        content.addEventListener('scroll', (ev) => {
            ev.stopPropagation();
        });
        //  hide element to eliminate flickering. Show the element exactly before animation starts
        content.style.visibility = 'hidden';
        wrapperElement.appendChild(content);
        return content;
    }
    /**
     * @private
     * @param {?} info
     * @return {?}
     */
    getOverlayElement(info) {
        if (info.settings.outlet) {
            return info.settings.outlet.nativeElement;
        }
        if (!this._overlayElement) {
            this._overlayElement = this._document.createElement('div');
            this._overlayElement.classList.add('igx-overlay');
            this._document.body.appendChild(this._overlayElement);
        }
        return this._overlayElement;
    }
    /**
     * @private
     * @param {?} info
     * @return {?}
     */
    updateSize(info) {
        if (info.componentRef) {
            //  if we are positioning component this is first time it gets visible
            //  and we can finally get its size
            info.initialSize = info.elementRef.nativeElement.getBoundingClientRect();
        }
        // set content div width only if element to show has width
        if (info.initialSize.width !== 0) {
            info.elementRef.nativeElement.parentElement.style.width = info.initialSize.width + 'px';
        }
    }
    /**
     * @private
     * @param {?} info
     * @return {?}
     */
    setupModalWrapper(info) {
        /** @type {?} */
        const wrapperElement = info.elementRef.nativeElement.parentElement.parentElement;
        fromEvent(wrapperElement, 'keydown').pipe(filter((ev) => ev.key === 'Escape' || ev.key === 'Esc'), takeUntil(this.destroy$)).subscribe(() => this.hide(info.id));
        wrapperElement.classList.remove('igx-overlay__wrapper');
        this.applyAnimationParams(wrapperElement, info.settings.positionStrategy.settings.openAnimation);
        wrapperElement.classList.add('igx-overlay__wrapper--modal');
    }
    /**
     * @private
     * @param {?} info
     * @return {?}
     */
    onCloseDone(info) {
        this.cleanUp(info);
        this.onClosed.emit({ id: info.id, componentRef: info.componentRef });
    }
    /**
     * @private
     * @param {?} info
     * @return {?}
     */
    cleanUp(info) {
        /** @type {?} */
        const child = info.elementRef.nativeElement;
        /** @type {?} */
        const outlet = this.getOverlayElement(info);
        if (!outlet.contains(child)) {
            console.warn('Component with id:' + info.id + ' is already removed!');
            return;
        }
        outlet.removeChild(child.parentNode.parentNode);
        if (info.componentRef) {
            this._appRef.detachView(info.componentRef.hostView);
            info.componentRef.destroy();
        }
        if (info.hook) {
            info.hook.parentElement.insertBefore(info.elementRef.nativeElement, info.hook);
            info.hook.parentElement.removeChild(info.hook);
        }
        /** @type {?} */
        const index = this._overlayInfos.indexOf(info);
        this._overlayInfos.splice(index, 1);
        // this._overlayElement.parentElement check just for tests that manually delete the element
        if (this._overlayInfos.length === 0 && this._overlayElement && this._overlayElement.parentElement) {
            this._overlayElement.parentElement.removeChild(this._overlayElement);
            this._overlayElement = null;
        }
    }
    /**
     * @private
     * @param {?} info
     * @return {?}
     */
    playOpenAnimation(info) {
        if (!info.openAnimationPlayer) {
            /** @type {?} */
            const animationBuilder = this.builder.build(info.settings.positionStrategy.settings.openAnimation);
            info.openAnimationPlayer = animationBuilder.create(info.elementRef.nativeElement);
            //  AnimationPlayer.getPosition returns always 0. To workaround this we are getting inner WebAnimationPlayer
            //  and then getting the positions from it.
            //  This is logged in Angular here - https://github.com/angular/angular/issues/18891
            //  As soon as this is resolved we can remove this hack
            /** @type {?} */
            const innerRenderer = ((/** @type {?} */ (info.openAnimationPlayer)))._renderer;
            info.openAnimationInnerPlayer = innerRenderer.engine.players[innerRenderer.engine.players.length - 1];
            info.openAnimationPlayer.onDone(() => {
                this.onOpened.emit({ id: info.id, componentRef: info.componentRef });
                if (info.openAnimationPlayer) {
                    info.openAnimationPlayer.reset();
                    info.openAnimationPlayer = null;
                }
                if (info.closeAnimationPlayer && info.closeAnimationPlayer.hasStarted()) {
                    info.closeAnimationPlayer.reset();
                }
            });
        }
        //  if there is opening animation already started do nothing
        if (info.openAnimationPlayer.hasStarted()) {
            return;
        }
        //  if there is closing animation already started start open animation from where close one has reached
        //  and remove close animation
        if (info.closeAnimationPlayer && info.closeAnimationPlayer.hasStarted()) {
            //  getPosition() returns what part of the animation is passed, e.g. 0.5 if half the animation
            //  is done, 0.75 if 3/4 of the animation is done. As we need to start next animation from where
            //  the previous has finished we need the amount up to 1, therefore we are subtracting what
            //  getPosition() returns from one
            /** @type {?} */
            const position = 1 - info.closeAnimationInnerPlayer.getPosition();
            info.closeAnimationPlayer.reset();
            info.closeAnimationPlayer = null;
            info.openAnimationPlayer.init();
            info.openAnimationPlayer.setPosition(position);
        }
        this.onAnimation.emit({ id: info.id, animationPlayer: info.openAnimationPlayer, animationType: 'open' });
        //  to eliminate flickering show the element just before animation start
        info.elementRef.nativeElement.parentElement.style.visibility = '';
        info.openAnimationPlayer.play();
    }
    /**
     * @private
     * @param {?} info
     * @return {?}
     */
    playCloseAnimation(info) {
        if (!info.closeAnimationPlayer) {
            /** @type {?} */
            const animationBuilder = this.builder.build(info.settings.positionStrategy.settings.closeAnimation);
            info.closeAnimationPlayer = animationBuilder.create(info.elementRef.nativeElement);
            //  AnimationPlayer.getPosition returns always 0. To workaround this we are getting inner WebAnimationPlayer
            //  and then getting the positions from it.
            //  This is logged in Angular here - https://github.com/angular/angular/issues/18891
            //  As soon as this is resolved we can remove this hack
            /** @type {?} */
            const innerRenderer = ((/** @type {?} */ (info.closeAnimationPlayer)))._renderer;
            info.closeAnimationInnerPlayer = innerRenderer.engine.players[innerRenderer.engine.players.length - 1];
            info.closeAnimationPlayer.onDone(() => {
                if (info.closeAnimationPlayer) {
                    info.closeAnimationPlayer.reset();
                    info.closeAnimationPlayer = null;
                }
                if (info.openAnimationPlayer && info.openAnimationPlayer.hasStarted()) {
                    info.openAnimationPlayer.reset();
                }
                this.onCloseDone(info);
            });
        }
        //  if there is closing animation already started do nothing
        if (info.closeAnimationPlayer.hasStarted()) {
            return;
        }
        //  if there is opening animation already started start close animation from where open one has reached
        //  and remove open animation
        if (info.openAnimationPlayer && info.openAnimationPlayer.hasStarted()) {
            //  getPosition() returns what part of the animation is passed, e.g. 0.5 if half the animation
            //  is done, 0.75 if 3/4 of the animation is done. As we need to start next animation from where
            //  the previous has finished we need the amount up to 1, therefore we are subtracting what
            //  getPosition() returns from one
            /** @type {?} */
            const position = 1 - info.openAnimationInnerPlayer.getPosition();
            info.openAnimationPlayer.reset();
            info.openAnimationPlayer = null;
            info.closeAnimationPlayer.init();
            info.closeAnimationPlayer.setPosition(position);
        }
        this.onAnimation.emit({ id: info.id, animationPlayer: info.closeAnimationPlayer, animationType: 'close' });
        info.closeAnimationPlayer.play();
    }
    //  TODO: check if applyAnimationParams will work with complex animations
    /**
     * @private
     * @param {?} wrapperElement
     * @param {?} animationOptions
     * @return {?}
     */
    applyAnimationParams(wrapperElement, animationOptions) {
        if (!animationOptions) {
            wrapperElement.style.transitionDuration = '0ms';
            return;
        }
        if (animationOptions.type === 10 /* AnimateRef */) {
            animationOptions = ((/** @type {?} */ (animationOptions))).animation;
        }
        if (!animationOptions.options || !animationOptions.options.params) {
            return;
        }
        /** @type {?} */
        const params = (/** @type {?} */ (animationOptions.options.params));
        if (params.duration) {
            wrapperElement.style.transitionDuration = params.duration;
        }
        if (params.easing) {
            wrapperElement.style.transitionTimingFunction = params.easing;
        }
    }
    /**
     * @hidden \@internal
     * @param {?} id
     * @return {?}
     */
    getOverlayById(id) {
        if (!id) {
            return null;
        }
        /** @type {?} */
        const info = this._overlayInfos.find(e => e.id === id);
        return info;
    }
    /**
     * @private
     * @param {?} info
     * @return {?}
     */
    addOutsideClickListener(info) {
        if (info.settings.closeOnOutsideClick) {
            if (info.settings.modal) {
                fromEvent(info.elementRef.nativeElement.parentElement.parentElement, 'click')
                    .pipe(takeUntil(this.destroy$))
                    .subscribe((e) => this._hide(info.id, e));
            }
            else if (
            //  if all overlays minus closing overlays equals one add the handler
            this._overlayInfos.filter(x => x.settings.closeOnOutsideClick && !x.settings.modal).length -
                this._overlayInfos.filter(x => x.settings.closeOnOutsideClick && !x.settings.modal &&
                    x.closeAnimationPlayer &&
                    x.closeAnimationPlayer.hasStarted()).length === 1) {
                this._document.addEventListener('click', this.documentClicked, true);
            }
        }
    }
    /**
     * @private
     * @param {?} info
     * @return {?}
     */
    removeOutsideClickListener(info) {
        if (info.settings.modal === false) {
            /** @type {?} */
            let shouldRemoveClickEventListener = true;
            this._overlayInfos.forEach(o => {
                if (o.settings.modal === false && o.id !== info.id) {
                    shouldRemoveClickEventListener = false;
                }
            });
            if (shouldRemoveClickEventListener) {
                this._document.removeEventListener('click', this.documentClicked, true);
            }
        }
    }
    /**
     * @private
     * @param {?} id
     * @return {?}
     */
    addResizeHandler(id) {
        /** @type {?} */
        const closingOverlaysCount = this._overlayInfos
            .filter(o => o.closeAnimationPlayer && o.closeAnimationPlayer.hasStarted())
            .length;
        if (this._overlayInfos.length - closingOverlaysCount === 1) {
            this._document.defaultView.addEventListener('resize', this.repositionAll);
        }
    }
    /**
     * @private
     * @param {?} id
     * @return {?}
     */
    removeResizeHandler(id) {
        /** @type {?} */
        const closingOverlaysCount = this._overlayInfos
            .filter(o => o.closeAnimationPlayer && o.closeAnimationPlayer.hasStarted())
            .length;
        if (this._overlayInfos.length - closingOverlaysCount === 1) {
            this._document.defaultView.removeEventListener('resize', this.repositionAll);
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
}
IgxOverlayService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
/** @nocollapse */
IgxOverlayService.ctorParameters = () => [
    { type: ComponentFactoryResolver },
    { type: ApplicationRef },
    { type: Injector },
    { type: AnimationBuilder },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: NgZone }
];
/** @nocollapse */ IgxOverlayService.ngInjectableDef = i0.ɵɵdefineInjectable({ factory: function IgxOverlayService_Factory() { return new IgxOverlayService(i0.ɵɵinject(i0.ComponentFactoryResolver), i0.ɵɵinject(i0.ApplicationRef), i0.ɵɵinject(i0.INJECTOR), i0.ɵɵinject(i1.AnimationBuilder), i0.ɵɵinject(i2.DOCUMENT), i0.ɵɵinject(i0.NgZone)); }, token: IgxOverlayService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    IgxOverlayService.prototype._componentId;
    /**
     * @type {?}
     * @private
     */
    IgxOverlayService.prototype._overlayInfos;
    /**
     * @type {?}
     * @private
     */
    IgxOverlayService.prototype._overlayElement;
    /**
     * @type {?}
     * @private
     */
    IgxOverlayService.prototype._document;
    /**
     * @type {?}
     * @private
     */
    IgxOverlayService.prototype.destroy$;
    /**
     * @type {?}
     * @private
     */
    IgxOverlayService.prototype._defaultSettings;
    /**
     * Emitted before the component is opened.
     * ```typescript
     * onOpening(event: OverlayCancelableEventArgs){
     *     const onOpening = event;
     * }
     * ```
     * @type {?}
     */
    IgxOverlayService.prototype.onOpening;
    /**
     * Emitted after the component is opened and all animations are finished.
     * ```typescript
     * onOpened(event: OverlayEventArgs){
     *     const onOpened = event;
     * }
     * ```
     * @type {?}
     */
    IgxOverlayService.prototype.onOpened;
    /**
     * Emitted before the component is closed.
     * ```typescript
     * onClosing(event: OverlayCancelableEventArgs){
     *     const onClosing = event;
     * }
     * ```
     * @type {?}
     */
    IgxOverlayService.prototype.onClosing;
    /**
     * Emitted after the component is closed and all animations are finished.
     * ```typescript
     * onClosed(event: OverlayEventArgs){
     *     const onClosed = event;
     * }
     * ```
     * @type {?}
     */
    IgxOverlayService.prototype.onClosed;
    /**
     * Emitted before animation is started
     * ```typescript
     * onAnimation(event: OverlayAnimationEventArgs){
     *     const onAnimation = event;
     * }
     * ```
     * @type {?}
     */
    IgxOverlayService.prototype.onAnimation;
    /**
     * @type {?}
     * @private
     */
    IgxOverlayService.prototype.documentClicked;
    /**
     * @hidden
     * @type {?}
     */
    IgxOverlayService.prototype.repositionAll;
    /**
     * @type {?}
     * @private
     */
    IgxOverlayService.prototype._factoryResolver;
    /**
     * @type {?}
     * @private
     */
    IgxOverlayService.prototype._appRef;
    /**
     * @type {?}
     * @private
     */
    IgxOverlayService.prototype._injector;
    /**
     * @type {?}
     * @private
     */
    IgxOverlayService.prototype.builder;
    /**
     * @type {?}
     * @private
     */
    IgxOverlayService.prototype.document;
    /**
     * @type {?}
     * @private
     */
    IgxOverlayService.prototype._zone;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3ZlcmxheS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvc2VydmljZXMvb3ZlcmxheS9vdmVybGF5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDM0MsT0FBTyxFQUFFLHNCQUFzQixFQUFFLE1BQU0scUNBQXFDLENBQUM7QUFDN0UsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFVakUsT0FBTyxFQUNILGNBQWMsRUFFZCx3QkFBd0IsRUFFeEIsVUFBVSxFQUNWLFlBQVksRUFDWixNQUFNLEVBQ04sVUFBVSxFQUNWLFFBQVEsRUFJUixNQUFNLEVBQ1QsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLGdCQUFnQixFQUFrRixNQUFNLHFCQUFxQixDQUFDO0FBQ3ZJLE9BQU8sRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQzFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFFbkQsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLGdDQUFnQyxDQUFDOzs7OztJQUV6RCxZQUFZLEdBQUcsS0FBSzs7Ozs7QUFPeEIsTUFBTSxPQUFPLGlCQUFpQjs7Ozs7Ozs7O0lBZ0UxQixZQUNZLGdCQUEwQyxFQUMxQyxPQUF1QixFQUN2QixTQUFtQixFQUNuQixPQUF5QixFQUNQLFFBQWEsRUFDL0IsS0FBYTtRQUxiLHFCQUFnQixHQUFoQixnQkFBZ0IsQ0FBMEI7UUFDMUMsWUFBTyxHQUFQLE9BQU8sQ0FBZ0I7UUFDdkIsY0FBUyxHQUFULFNBQVMsQ0FBVTtRQUNuQixZQUFPLEdBQVAsT0FBTyxDQUFrQjtRQUNQLGFBQVEsR0FBUixRQUFRLENBQUs7UUFDL0IsVUFBSyxHQUFMLEtBQUssQ0FBUTtRQXJFakIsaUJBQVksR0FBRyxD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QUFXO1FBQ2QsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDekIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUM3QixDQUFDOzs7WUFucUJKLFVBQVUsU0FBQyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUU7Ozs7WUF4QjlCLHdCQUF3QjtZQUZ4QixjQUFjO1lBUWQsUUFBUTtZQU1ILGdCQUFnQjs0Q0FrRmhCLE1BQU0sU0FBQyxRQUFRO1lBcEZwQixNQUFNOzs7Ozs7OztJQWdCTix5Q0FBeUI7Ozs7O0lBQ3pCLDBDQUEwQzs7Ozs7SUFDMUMsNENBQXFDOzs7OztJQUNyQyxzQ0FBNEI7Ozs7O0lBQzVCLHFDQUEwQzs7Ozs7SUFFMUMsNkNBS0U7Ozs7Ozs7Ozs7SUFVRixzQ0FBa0U7Ozs7Ozs7Ozs7SUFVbEUscUNBQXVEOzs7Ozs7Ozs7O0lBVXZELHNDQUErRDs7Ozs7Ozs7OztJQVUvRCxxQ0FBdUQ7Ozs7Ozs7Ozs7SUFVdkQsd0NBQW1FOzs7OztJQThmbkUsNENBbUNDOzs7OztJQXVERCwwQ0FJQzs7Ozs7SUF6bEJHLDZDQUFrRDs7Ozs7SUFDbEQsb0NBQStCOzs7OztJQUMvQixzQ0FBMkI7Ozs7O0lBQzNCLG9DQUFpQzs7Ozs7SUFDakMscUNBQXVDOzs7OztJQUN2QyxrQ0FBcUIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQgeyBHbG9iYWxQb3NpdGlvblN0cmF0ZWd5IH0gZnJvbSAnLi9wb3NpdGlvbi9nbG9iYWwtcG9zaXRpb24tc3RyYXRlZ3knO1xuaW1wb3J0IHsgTm9PcFNjcm9sbFN0cmF0ZWd5IH0gZnJvbSAnLi9zY3JvbGwvTm9PcFNjcm9sbFN0cmF0ZWd5JztcbmltcG9ydCB7XG4gICAgT3ZlcmxheVNldHRpbmdzLFxuICAgIE92ZXJsYXlFdmVudEFyZ3MsXG4gICAgT3ZlcmxheUluZm8sXG4gICAgT3ZlcmxheUFuaW1hdGlvbkV2ZW50QXJncyxcbiAgICBPdmVybGF5Q2FuY2VsYWJsZUV2ZW50QXJncyxcbiAgICBPdmVybGF5Q2xvc2luZ0V2ZW50QXJnc1xufSBmcm9tICcuL3V0aWxpdGllcyc7XG5cbmltcG9ydCB7XG4gICAgQXBwbGljYXRpb25SZWYsXG4gICAgQ29tcG9uZW50RmFjdG9yeSxcbiAgICBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gICAgQ29tcG9uZW50UmVmLFxuICAgIEVsZW1lbnRSZWYsXG4gICAgRXZlbnRFbWl0dGVyLFxuICAgIEluamVjdCxcbiAgICBJbmplY3RhYmxlLFxuICAgIEluamVjdG9yLFxuICAgIFR5cGUsXG4gICAgT25EZXN0cm95LFxuICAgIE5nTW9kdWxlUmVmLFxuICAgIE5nWm9uZVxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFuaW1hdGlvbkJ1aWxkZXIsIEFuaW1hdGlvblJlZmVyZW5jZU1ldGFkYXRhLCBBbmltYXRpb25NZXRhZGF0YVR5cGUsIEFuaW1hdGlvbkFuaW1hdGVSZWZNZXRhZGF0YSB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHsgZnJvbUV2ZW50LCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBmaWx0ZXIsIHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IElBbmltYXRpb25QYXJhbXMgfSBmcm9tICcuLi8uLi9hbmltYXRpb25zL21haW4nO1xuaW1wb3J0IHsgc2hvd01lc3NhZ2UgfSBmcm9tICcuLi8uLi9jb3JlL2RlcHJlY2F0ZURlY29yYXRvcnMnO1xuXG5sZXQgd2FybmluZ1Nob3duID0gZmFsc2U7XG5cbi8qKlxuICogW0RvY3VtZW50YXRpb25dKGh0dHBzOi8vd3d3LmluZnJhZ2lzdGljcy5jb20vcHJvZHVjdHMvaWduaXRlLXVpLWFuZ3VsYXIvYW5ndWxhci9jb21wb25lbnRzL292ZXJsYXlfbWFpbi5odG1sKVxuICogVGhlIG92ZXJsYXkgc2VydmljZSBhbGxvd3MgdXNlcnMgdG8gc2hvdyBjb21wb25lbnRzIG9uIG92ZXJsYXkgZGl2IGFib3ZlIGFsbCBvdGhlciBlbGVtZW50cyBpbiB0aGUgcGFnZS5cbiAqL1xuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmV4cG9ydCBjbGFzcyBJZ3hPdmVybGF5U2VydmljZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XG4gICAgcHJpdmF0ZSBfY29tcG9uZW50SWQgPSAwO1xuICAgIHByaXZhdGUgX292ZXJsYXlJbmZvczogT3ZlcmxheUluZm9bXSA9IFtdO1xuICAgIHByaXZhdGUgX292ZXJsYXlFbGVtZW50OiBIVE1MRWxlbWVudDtcbiAgICBwcml2YXRlIF9kb2N1bWVudDogRG9jdW1lbnQ7XG4gICAgcHJpdmF0ZSBkZXN0cm95JCA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG5cbiAgICBwcml2YXRlIF9kZWZhdWx0U2V0dGluZ3M6IE92ZXJsYXlTZXR0aW5ncyA9IHtcbiAgICAgICAgcG9zaXRpb25TdHJhdGVneTogbmV3IEdsb2JhbFBvc2l0aW9uU3RyYXRlZ3koKSxcbiAgICAgICAgc2Nyb2xsU3RyYXRlZ3k6IG5ldyBOb09wU2Nyb2xsU3RyYXRlZ3koKSxcbiAgICAgICAgbW9kYWw6IHRydWUsXG4gICAgICAgIGNsb3NlT25PdXRzaWRlQ2xpY2s6IHRydWVcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBvcGVuZWQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIG9uT3BlbmluZyhldmVudDogT3ZlcmxheUNhbmNlbGFibGVFdmVudEFyZ3Mpe1xuICAgICAqICAgICBjb25zdCBvbk9wZW5pbmcgPSBldmVudDtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIG9uT3BlbmluZyA9IG5ldyBFdmVudEVtaXR0ZXI8T3ZlcmxheUNhbmNlbGFibGVFdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIGFmdGVyIHRoZSBjb21wb25lbnQgaXMgb3BlbmVkIGFuZCBhbGwgYW5pbWF0aW9ucyBhcmUgZmluaXNoZWQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIG9uT3BlbmVkKGV2ZW50OiBPdmVybGF5RXZlbnRBcmdzKXtcbiAgICAgKiAgICAgY29uc3Qgb25PcGVuZWQgPSBldmVudDtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIG9uT3BlbmVkID0gbmV3IEV2ZW50RW1pdHRlcjxPdmVybGF5RXZlbnRBcmdzPigpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyBjbG9zZWQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIG9uQ2xvc2luZyhldmVudDogT3ZlcmxheUNhbmNlbGFibGVFdmVudEFyZ3Mpe1xuICAgICAqICAgICBjb25zdCBvbkNsb3NpbmcgPSBldmVudDtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIG9uQ2xvc2luZyA9IG5ldyBFdmVudEVtaXR0ZXI8T3ZlcmxheUNsb3NpbmdFdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiBFbWl0dGVkIGFmdGVyIHRoZSBjb21wb25lbnQgaXMgY2xvc2VkIGFuZCBhbGwgYW5pbWF0aW9ucyBhcmUgZmluaXNoZWQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIG9uQ2xvc2VkKGV2ZW50OiBPdmVybGF5RXZlbnRBcmdzKXtcbiAgICAgKiAgICAgY29uc3Qgb25DbG9zZWQgPSBldmVudDtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIG9uQ2xvc2VkID0gbmV3IEV2ZW50RW1pdHRlcjxPdmVybGF5RXZlbnRBcmdzPigpO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCBiZWZvcmUgYW5pbWF0aW9uIGlzIHN0YXJ0ZWRcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogb25BbmltYXRpb24oZXZlbnQ6IE92ZXJsYXlBbmltYXRpb25FdmVudEFyZ3Mpe1xuICAgICAqICAgICBjb25zdCBvbkFuaW1hdGlvbiA9IGV2ZW50O1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgb25BbmltYXRpb24gPSBuZXcgRXZlbnRFbWl0dGVyPE92ZXJsYXlBbmltYXRpb25FdmVudEFyZ3M+KCk7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgcHJpdmF0ZSBfZmFjdG9yeVJlc29sdmVyOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gICAgICAgIHByaXZhdGUgX2FwcFJlZjogQXBwbGljYXRpb25SZWYsXG4gICAgICAgIHByaXZhdGUgX2luamVjdG9yOiBJbmplY3RvcixcbiAgICAgICAgcHJpdmF0ZSBidWlsZGVyOiBBbmltYXRpb25CdWlsZGVyLFxuICAgICAgICBASW5qZWN0KERPQ1VNRU5UKSBwcml2YXRlIGRvY3VtZW50OiBhbnksXG4gICAgICAgIHByaXZhdGUgX3pvbmU6IE5nWm9uZSkge1xuICAgICAgICB0aGlzLl9kb2N1bWVudCA9IDxEb2N1bWVudD50aGlzLmRvY3VtZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBJZC4gUHJvdmlkZSB0aGlzIElkIHdoZW4gY2FsbCBgc2hvdyhpZCwgc2V0dGluZ3M/KWAgbWV0aG9kXG4gICAgICogQHBhcmFtIGNvbXBvbmVudCBFbGVtZW50UmVmIHRvIHNob3cgaW4gb3ZlcmxheVxuICAgICAqIEBwYXJhbSBzZXR0aW5ncyBEaXNwbGF5IHNldHRpbmdzIGZvciB0aGUgb3ZlcmxheSwgc3VjaCBhcyBwb3NpdGlvbmluZyBhbmQgc2Nyb2xsL2Nsb3NlIGJlaGF2aW9yLlxuICAgICAqIEByZXR1cm5zIElkIG9mIHRoZSBjcmVhdGVkIG92ZXJsYXkuIFZhbGlkIHVudGlsIGBvbkNsb3NlZGAgaXMgZW1pdHRlZC5cbiAgICAgKi9cbiAgICBhdHRhY2goZWxlbWVudDogRWxlbWVudFJlZiwgc2V0dGluZ3M/OiBPdmVybGF5U2V0dGluZ3MpOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIElkLiBQcm92aWRlIHRoaXMgSWQgd2hlbiBjYWxsIGBzaG93KGlkLCBzZXR0aW5ncz8pYCBtZXRob2RcbiAgICAgKiBAcGFyYW0gY29tcG9uZW50IENvbXBvbmVudCBUeXBlIHRvIHNob3cgaW4gb3ZlcmxheVxuICAgICAqIEBwYXJhbSBzZXR0aW5ncyBEaXNwbGF5IHNldHRpbmdzIGZvciB0aGUgb3ZlcmxheSwgc3VjaCBhcyBwb3NpdGlvbmluZyBhbmQgc2Nyb2xsL2Nsb3NlIGJlaGF2aW9yLlxuICAgICAqIEBwYXJhbSBtb2R1bGVSZWYgT3B0aW9uYWwgcmVmZXJlbmNlIHRvIGFuIG9iamVjdCBjb250YWluaW5nIEluamVjdG9yIGFuZCBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXJcbiAgICAgKiB0aGF0IGNhbiByZXNvbHZlIHRoZSBjb21wb25lbnQncyBmYWN0b3J5XG4gICAgICogQHJldHVybnMgSWQgb2YgdGhlIGNyZWF0ZWQgb3ZlcmxheS4gVmFsaWQgdW50aWwgYG9uQ2xvc2VkYCBpcyBlbWl0dGVkLlxuICAgICAqL1xuICAgIGF0dGFjaChjb21wb25lbnQ6IFR5cGU8YW55Piwgc2V0dGluZ3M/OiBPdmVybGF5U2V0dGluZ3MsXG4gICAgICAgIG1vZHVsZVJlZj86IFBpY2s8TmdNb2R1bGVSZWY8YW55PiwgJ2luamVjdG9yJyB8ICdjb21wb25lbnRGYWN0b3J5UmVzb2x2ZXInPik6IHN0cmluZztcbiAgICBhdHRhY2goY29tcG9uZW50OiBFbGVtZW50UmVmIHwgVHlwZTxhbnk+LCBzZXR0aW5ncz86IE92ZXJsYXlTZXR0aW5ncyxcbiAgICAgICAgbW9kdWxlUmVmPzogUGljazxOZ01vZHVsZVJlZjxhbnk+LCAnaW5qZWN0b3InIHwgJ2NvbXBvbmVudEZhY3RvcnlSZXNvbHZlcic+KTogc3RyaW5nIHtcbiAgICAgICAgbGV0IGluZm86IE92ZXJsYXlJbmZvO1xuICAgICAgICBpbmZvID0gdGhpcy5nZXRPdmVybGF5SW5mbyhjb21wb25lbnQsIG1vZHVsZVJlZik7XG5cbiAgICAgICAgLy8gIGlmIHRoZXJlIGlzIG5vIGluZm8gbW9zdCBwcm9iYWJseSB3cm9uZyB0eXBlIGNvbXBvbmVudCB3YXMgcHJvdmlkZWQgYW5kIHdlIGp1c3QgZ28gb3V0XG4gICAgICAgIGlmICghaW5mbykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpbmZvLmlkID0gKHRoaXMuX2NvbXBvbmVudElkKyspLnRvU3RyaW5nKCk7XG4gICAgICAgIHNldHRpbmdzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fZGVmYXVsdFNldHRpbmdzLCBzZXR0aW5ncyk7XG4gICAgICAgIGluZm8uc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgICAgICAgdGhpcy5fb3ZlcmxheUluZm9zLnB1c2goaW5mbyk7XG4gICAgICAgIHJldHVybiBpbmZvLmlkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNob3dzIHRoZSBvdmVybGF5IGZvciBwcm92aWRlZCBpZC5cbiAgICAgKiBAcGFyYW0gaWQgSWQgdG8gc2hvdyBvdmVybGF5IGZvclxuICAgICAqIEBwYXJhbSBzZXR0aW5ncyBEaXNwbGF5IHNldHRpbmdzIGZvciB0aGUgb3ZlcmxheSwgc3VjaCBhcyBwb3NpdGlvbmluZyBhbmQgc2Nyb2xsL2Nsb3NlIGJlaGF2aW9yLlxuICAgICAqL1xuICAgIHNob3coaWQ6IHN0cmluZywgc2V0dGluZ3M/OiBPdmVybGF5U2V0dGluZ3MpOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogU2hvd3MgdGhlIHByb3ZpZGVkIGNvbXBvbmVudC5cbiAgICAgKiBAcGFyYW0gY29tcG9uZW50IEVsZW1lbnRSZWYgb3IgQ29tcG9uZW50IFR5cGUgdG8gc2hvdyBpbiBvdmVybGF5XG4gICAgICogQHBhcmFtIHNldHRpbmdzIERpc3BsYXkgc2V0dGluZ3MgZm9yIHRoZSBvdmVybGF5LCBzdWNoIGFzIHBvc2l0aW9uaW5nIGFuZCBzY3JvbGwvY2xvc2UgYmVoYXZpb3IuXG4gICAgICogQHJldHVybnMgSWQgb2YgdGhlIGNyZWF0ZWQgb3ZlcmxheS4gVmFsaWQgdW50aWwgYG9uQ2xvc2VkYCBpcyBlbWl0dGVkLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLm92ZXJsYXkuc2hvdyhlbGVtZW50LCBzZXR0aW5ncyk7XG4gICAgICogYGBgXG4gICAgICogQGRlcHJlY2F0ZWQgVXNlIGBhdHRhY2goY29tcG9uZW50KWAgdG8gb2J0YWluIGFuIElkLiBUaGVuIGBzaG93KGlkLCBzZXR0aW5ncz8pYCB3aXRoIHByb3ZpZGVkIElkLlxuICAgICAqL1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp1bmlmaWVkLXNpZ25hdHVyZXNcbiAgICBzaG93KGNvbXBvbmVudDogRWxlbWVudFJlZiB8IFR5cGU8YW55Piwgc2V0dGluZ3M/OiBPdmVybGF5U2V0dGluZ3MpOiBzdHJpbmc7XG4gICAgc2hvdyhjb21wT3JJZDogc3RyaW5nIHwgRWxlbWVudFJlZiB8IFR5cGU8YW55Piwgc2V0dGluZ3M/OiBPdmVybGF5U2V0dGluZ3MpOiBzdHJpbmcge1xuICAgICAgICBsZXQgaW5mbzogT3ZlcmxheUluZm87XG4gICAgICAgIGxldCBpZDogc3RyaW5nO1xuICAgICAgICBpZiAodHlwZW9mIGNvbXBPcklkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWQgPSBjb21wT3JJZDtcbiAgICAgICAgICAgIGluZm8gPSB0aGlzLmdldE92ZXJsYXlCeUlkKGNvbXBPcklkKTtcbiAgICAgICAgICAgIGlmICghaW5mbykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignaWd4T3ZlcmxheS5zaG93IHdhcyBjYWxsZWQgd2l0aCB3cm9uZyBpZDogJyArIGNvbXBPcklkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdhcm5pbmdTaG93biA9IHNob3dNZXNzYWdlKFxuICAgICAgICAgICAgICAgICdgc2hvdyhjb21wb25lbnQsIHNldHRpbmdzPylgIG92ZXJsb2FkIGlzIGRlcHJlY2F0ZWQuIFVzZSBgYXR0YWNoKGNvbXBvbmVudClgIHRvIG9idGFpbiBhbiBJZC4nICtcbiAgICAgICAgICAgICAgICAnVGhlbiBgc2hvdyhpZCwgc2V0dGluZ3M/KWAgd2l0aCBwcm92aWRlZCBJZC4nLFxuICAgICAgICAgICAgICAgIHdhcm5pbmdTaG93bik7XG4gICAgICAgICAgICBpZCA9ICh0aGlzLl9jb21wb25lbnRJZCsrKS50b1N0cmluZygpO1xuICAgICAgICAgICAgaW5mbyA9IHRoaXMuZ2V0T3ZlcmxheUluZm8oY29tcE9ySWQpO1xuXG4gICAgICAgICAgICAvLyAgaWYgdGhlcmUgaXMgbm8gaW5mbyBtb3N0IHByb2JhYmx5IHdyb25nIHR5cGUgY29tcG9uZW50IHdhcyBwcm92aWRlZCBhbmQgd2UganVzdCBnbyBvdXRcbiAgICAgICAgICAgIGlmICghaW5mbykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW5mby5pZCA9IGlkO1xuICAgICAgICB9XG5cbiAgICAgICAgc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLl9kZWZhdWx0U2V0dGluZ3MsIGluZm8uc2V0dGluZ3MsIHNldHRpbmdzKTtcbiAgICAgICAgaW5mby5zZXR0aW5ncyA9IHNldHRpbmdzO1xuXG4gICAgICAgIHRoaXMuX3Nob3coaW5mbyk7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIaWRlcyB0aGUgY29tcG9uZW50IHdpdGggdGhlIElEIHByb3ZpZGVkIGFzIGEgcGFyYW1ldGVyLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLm92ZXJsYXkuaGlkZShpZCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgaGlkZShpZDogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuX2hpZGUoaWQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhpZGVzIGFsbCB0aGUgY29tcG9uZW50cyBhbmQgdGhlIG92ZXJsYXkuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMub3ZlcmxheS5oaWRlQWxsKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgaGlkZUFsbCgpIHtcbiAgICAgICAgLy8gc2luY2Ugb3ZlcmxheXMgYXJlIHJlbW92ZWQgb24gYW5pbWF0aW9uIGRvbmUsIHF1ZSBhbGwgaGlkZXNcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX292ZXJsYXlJbmZvcy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZSh0aGlzLl9vdmVybGF5SW5mb3NbaV0uaWQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVwb3NpdGlvbnMgdGhlIGNvbXBvbmVudCB3aXRoIElEIHByb3ZpZGVkIGFzIGEgcGFyYW1ldGVyLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLm92ZXJsYXkucmVwb3NpdGlvbihpZCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcmVwb3NpdGlvbihpZDogc3RyaW5nKSB7XG4gICAgICAgIGNvbnN0IG92ZXJsYXlJbmZvID0gdGhpcy5nZXRPdmVybGF5QnlJZChpZCk7XG4gICAgICAgIGlmICghb3ZlcmxheUluZm8gfHwgIW92ZXJsYXlJbmZvLnNldHRpbmdzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdXcm9uZyBpZCBwcm92aWRlZCBpbiBvdmVybGF5LnJlcG9zaXRpb24gbWV0aG9kLiBJZDogJyArIGlkKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbnRlbnRFbGVtZW50ID0gb3ZlcmxheUluZm8uZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRFbGVtZW50UmVjdCA9IGNvbnRlbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBvdmVybGF5SW5mby5zZXR0aW5ncy5wb3NpdGlvblN0cmF0ZWd5LnBvc2l0aW9uKFxuICAgICAgICAgICAgY29udGVudEVsZW1lbnQsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgd2lkdGg6IGNvbnRlbnRFbGVtZW50UmVjdC53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IGNvbnRlbnRFbGVtZW50UmVjdC5oZWlnaHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0aGlzLl9kb2N1bWVudCxcbiAgICAgICAgICAgIGZhbHNlKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9zaG93KGluZm86IE92ZXJsYXlJbmZvKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50QXJnczogT3ZlcmxheUNhbmNlbGFibGVFdmVudEFyZ3MgPSB7IGlkOiBpbmZvLmlkLCBjb21wb25lbnRSZWY6IGluZm8uY29tcG9uZW50UmVmLCBjYW5jZWw6IGZhbHNlIH07XG4gICAgICAgIHRoaXMub25PcGVuaW5nLmVtaXQoZXZlbnRBcmdzKTtcbiAgICAgICAgaWYgKGV2ZW50QXJncy5jYW5jZWwpIHtcbiAgICAgICAgICAgIGlmIChpbmZvLmNvbXBvbmVudFJlZikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FwcFJlZi5kZXRhY2hWaWV3KGluZm8uY29tcG9uZW50UmVmLmhvc3RWaWV3KTtcbiAgICAgICAgICAgICAgICBpbmZvLmNvbXBvbmVudFJlZi5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICBpZiB0aGVyZSBpcyBubyBjbG9zZSBhbmltYXRpb24gcGxheWVyLCBvciB0aGVyZSBpcyBvbmUgYnV0IGl0IGlzIG5vdCBzdGFydGVkIHlldCB3ZSBhcmUgaW4gY2xlYXJcbiAgICAgICAgLy8gIG9wZW5pbmcuIE90aGVyd2lzZSwgaWYgdGhlcmUgaXMgY2xvc2UgYW5pbWF0aW9uIHBsYXllciBwbGF5aW5nIGFuaW1hdGlvbiBub3cgd2Ugc2hvdWxkIG5vdCBzZXR1cFxuICAgICAgICAvLyAgb3ZlcmxheSB0aGlzIGlzIGFscmVhZHkgZG9uZVxuICAgICAgICBpZiAoIWluZm8uY2xvc2VBbmltYXRpb25QbGF5ZXIgfHwgKGluZm8uY2xvc2VBbmltYXRpb25QbGF5ZXIgJiYgIWluZm8uY2xvc2VBbmltYXRpb25QbGF5ZXIuaGFzU3RhcnRlZCgpKSkge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudFJlY3QgPSBpbmZvLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGluZm8uaW5pdGlhbFNpemUgPSB7IHdpZHRoOiBlbGVtZW50UmVjdC53aWR0aCwgaGVpZ2h0OiBlbGVtZW50UmVjdC5oZWlnaHQgfTtcbiAgICAgICAgICAgIGluZm8uaG9vayA9IHRoaXMucGxhY2VFbGVtZW50SG9vayhpbmZvLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudCk7XG5cbiAgICAgICAgICAgIHRoaXMubW92ZUVsZW1lbnRUb092ZXJsYXkoaW5mbyk7XG4gICAgICAgICAgICBpZiAoaW5mby5jb21wb25lbnRSZWYpIHtcbiAgICAgICAgICAgICAgICBpbmZvLmNvbXBvbmVudFJlZi5jaGFuZ2VEZXRlY3RvclJlZi5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNpemUoaW5mbyk7XG4gICAgICAgICAgICBpZiAodGhpcy5fb3ZlcmxheUluZm9zLmluZGV4T2YoaW5mbykgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb3ZlcmxheUluZm9zLnB1c2goaW5mbyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGluZm8uc2V0dGluZ3MucG9zaXRpb25TdHJhdGVneS5wb3NpdGlvbihcbiAgICAgICAgICAgICAgICBpbmZvLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5wYXJlbnRFbGVtZW50LFxuICAgICAgICAgICAgICAgIHsgd2lkdGg6IGluZm8uaW5pdGlhbFNpemUud2lkdGgsIGhlaWdodDogaW5mby5pbml0aWFsU2l6ZS5oZWlnaHQgfSxcbiAgICAgICAgICAgICAgICBkb2N1bWVudCxcbiAgICAgICAgICAgICAgICB0cnVlKTtcbiAgICAgICAgICAgIGluZm8uc2V0dGluZ3Muc2Nyb2xsU3RyYXRlZ3kuaW5pdGlhbGl6ZSh0aGlzLl9kb2N1bWVudCwgdGhpcywgaW5mby5pZCk7XG4gICAgICAgICAgICBpbmZvLnNldHRpbmdzLnNjcm9sbFN0cmF0ZWd5LmF0dGFjaCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hZGRPdXRzaWRlQ2xpY2tMaXN0ZW5lcihpbmZvKTtcbiAgICAgICAgdGhpcy5hZGRSZXNpemVIYW5kbGVyKGluZm8uaWQpO1xuXG4gICAgICAgIGlmIChpbmZvLnNldHRpbmdzLm1vZGFsKSB7XG4gICAgICAgICAgICB0aGlzLnNldHVwTW9kYWxXcmFwcGVyKGluZm8pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZm8uc2V0dGluZ3MucG9zaXRpb25TdHJhdGVneS5zZXR0aW5ncy5vcGVuQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnBsYXlPcGVuQW5pbWF0aW9uKGluZm8pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gIHRvIGVsaW1pbmF0ZSBmbGlja2VyaW5nIHNob3cgdGhlIGVsZW1lbnQganVzdCBiZWZvcmUgb25PcGVuZWQgZmlyZVxuICAgICAgICAgICAgaW5mby5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucGFyZW50RWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XG4gICAgICAgICAgICB0aGlzLm9uT3BlbmVkLmVtaXQoeyBpZDogaW5mby5pZCwgY29tcG9uZW50UmVmOiBpbmZvLmNvbXBvbmVudFJlZiB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgX2hpZGUoaWQ6IHN0cmluZywgZXZlbnQ/OiBFdmVudCkge1xuICAgICAgICBjb25zdCBpbmZvOiBPdmVybGF5SW5mbyA9IHRoaXMuZ2V0T3ZlcmxheUJ5SWQoaWQpO1xuXG4gICAgICAgIGlmICghaW5mbykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdpZ3hPdmVybGF5LmhpZGUgd2FzIGNhbGxlZCB3aXRoIHdyb25nIGlkOiAnICsgaWQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZXZlbnRBcmdzID0geyBpZCwgY29tcG9uZW50UmVmOiBpbmZvLmNvbXBvbmVudFJlZiwgY2FuY2VsOiBmYWxzZSwgZXZlbnQgfTtcbiAgICAgICAgdGhpcy5vbkNsb3NpbmcuZW1pdChldmVudEFyZ3MpO1xuICAgICAgICBpZiAoZXZlbnRBcmdzLmNhbmNlbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gIFRPRE86IHN5bmNocm9uaXplIHdoZXJlIHRoZXNlIGFyZSBhZGRlZC9hdHRhY2hlZCBhbmQgd2hlcmUgcmVtb3ZlZC9kZXRhY2hlZFxuICAgICAgICBpbmZvLnNldHRpbmdzLnNjcm9sbFN0cmF0ZWd5LmRldGFjaCgpO1xuICAgICAgICB0aGlzLnJlbW92ZU91dHNpZGVDbGlja0xpc3RlbmVyKGluZm8pO1xuICAgICAgICB0aGlzLnJlbW92ZVJlc2l6ZUhhbmRsZXIoaW5mby5pZCk7XG5cbiAgICAgICAgY29uc3QgY2hpbGQ6IEhUTUxFbGVtZW50ID0gaW5mby5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGlmIChpbmZvLnNldHRpbmdzLm1vZGFsKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBjaGlsZC5wYXJlbnROb2RlLnBhcmVudE5vZGUgYXMgSFRNTEVsZW1lbnQ7XG4gICAgICAgICAgICB0aGlzLmFwcGx5QW5pbWF0aW9uUGFyYW1zKHBhcmVudCwgaW5mby5zZXR0aW5ncy5wb3NpdGlvblN0cmF0ZWd5LnNldHRpbmdzLmNsb3NlQW5pbWF0aW9uKTtcbiAgICAgICAgICAgIHBhcmVudC5jbGFzc0xpc3QucmVtb3ZlKCdpZ3gtb3ZlcmxheV9fd3JhcHBlci0tbW9kYWwnKTtcbiAgICAgICAgICAgIHBhcmVudC5jbGFzc0xpc3QuYWRkKCdpZ3gtb3ZlcmxheV9fd3JhcHBlcicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZm8uc2V0dGluZ3MucG9zaXRpb25TdHJhdGVneS5zZXR0aW5ncy5jbG9zZUFuaW1hdGlvbikge1xuICAgICAgICAgICAgdGhpcy5wbGF5Q2xvc2VBbmltYXRpb24oaW5mbyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9uQ2xvc2VEb25lKGluZm8pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRPdmVybGF5SW5mbyhjb21wb25lbnQ6IGFueSwgbW9kdWxlUmVmPzogUGljazxOZ01vZHVsZVJlZjxhbnk+LCAnaW5qZWN0b3InIHwgJ2NvbXBvbmVudEZhY3RvcnlSZXNvbHZlcic+KTogT3ZlcmxheUluZm8ge1xuICAgICAgICBjb25zdCBpbmZvOiBPdmVybGF5SW5mbyA9IHsgbmdab25lOiB0aGlzLl96b25lIH07XG4gICAgICAgIGlmIChjb21wb25lbnQgaW5zdGFuY2VvZiBFbGVtZW50UmVmKSB7XG4gICAgICAgICAgICBpbmZvLmVsZW1lbnRSZWYgPSA8RWxlbWVudFJlZj5jb21wb25lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgZHluYW1pY0ZhY3Rvcnk6IENvbXBvbmVudEZhY3Rvcnk8e30+O1xuICAgICAgICAgICAgY29uc3QgZmFjdG9yeVJlc29sdmVyID0gbW9kdWxlUmVmID8gbW9kdWxlUmVmLmNvbXBvbmVudEZhY3RvcnlSZXNvbHZlciA6IHRoaXMuX2ZhY3RvcnlSZXNvbHZlcjtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZHluYW1pY0ZhY3RvcnkgPSBmYWN0b3J5UmVzb2x2ZXIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoY29tcG9uZW50KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGluamVjdG9yID0gbW9kdWxlUmVmID8gbW9kdWxlUmVmLmluamVjdG9yIDogdGhpcy5faW5qZWN0b3I7XG4gICAgICAgICAgICBjb25zdCBkeW5hbWljQ29tcG9uZW50OiBDb21wb25lbnRSZWY8e30+ID0gZHluYW1pY0ZhY3RvcnkuY3JlYXRlKGluamVjdG9yKTtcbiAgICAgICAgICAgIHRoaXMuX2FwcFJlZi5hdHRhY2hWaWV3KGR5bmFtaWNDb21wb25lbnQuaG9zdFZpZXcpO1xuXG4gICAgICAgICAgICAvLyBJZiB0aGUgZWxlbWVudCBpcyBuZXdseSBjcmVhdGVkIGZyb20gYSBDb21wb25lbnQsIGl0IGlzIHdyYXBwZWQgaW4gJ25nLWNvbXBvbmVudCcgdGFnIC0gd2UgZG8gbm90IHdhbnQgdGhhdC5cbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBkeW5hbWljQ29tcG9uZW50LmxvY2F0aW9uLm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBpbmZvLmVsZW1lbnRSZWYgPSA8RWxlbWVudFJlZj57IG5hdGl2ZUVsZW1lbnQ6IGVsZW1lbnQgfTtcbiAgICAgICAgICAgIGluZm8uY29tcG9uZW50UmVmID0gZHluYW1pY0NvbXBvbmVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIHByaXZhdGUgcGxhY2VFbGVtZW50SG9vayhlbGVtZW50OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50IHtcbiAgICAgICAgaWYgKCFlbGVtZW50LnBhcmVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaG9vayA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBlbGVtZW50LnBhcmVudEVsZW1lbnQuaW5zZXJ0QmVmb3JlKGhvb2ssIGVsZW1lbnQpO1xuICAgICAgICByZXR1cm4gaG9vaztcbiAgICB9XG5cbiAgICBwcml2YXRlIG1vdmVFbGVtZW50VG9PdmVybGF5KGluZm86IE92ZXJsYXlJbmZvKSB7XG4gICAgICAgIGNvbnN0IHdyYXBwZXJFbGVtZW50ID0gdGhpcy5nZXRXcmFwcGVyRWxlbWVudCgpO1xuICAgICAgICBjb25zdCBjb250ZW50RWxlbWVudCA9IHRoaXMuZ2V0Q29udGVudEVsZW1lbnQod3JhcHBlckVsZW1lbnQsIGluZm8uc2V0dGluZ3MubW9kYWwpO1xuICAgICAgICB0aGlzLmdldE92ZXJsYXlFbGVtZW50KGluZm8pLmFwcGVuZENoaWxkKHdyYXBwZXJFbGVtZW50KTtcbiAgICAgICAgY29uc3QgZWxlbWVudFNjcm9sbFRvcCA9IGluZm8uZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgICAgY29udGVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoaW5mby5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpO1xuXG4gICAgICAgIGlmIChlbGVtZW50U2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICBpbmZvLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5zY3JvbGxUb3AgPSBlbGVtZW50U2Nyb2xsVG9wO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRXcmFwcGVyRWxlbWVudCgpOiBIVE1MRWxlbWVudCB7XG4gICAgICAgIGNvbnN0IHdyYXBwZXI6IEhUTUxFbGVtZW50ID0gdGhpcy5fZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHdyYXBwZXIuY2xhc3NMaXN0LmFkZCgnaWd4LW92ZXJsYXlfX3dyYXBwZXInKTtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXI7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZXRDb250ZW50RWxlbWVudCh3cmFwcGVyRWxlbWVudDogSFRNTEVsZW1lbnQsIG1vZGFsOiBib29sZWFuKTogSFRNTEVsZW1lbnQge1xuICAgICAgICBjb25zdCBjb250ZW50OiBIVE1MRWxlbWVudCA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBpZiAobW9kYWwpIHtcbiAgICAgICAgICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZCgnaWd4LW92ZXJsYXlfX2NvbnRlbnQtLW1vZGFsJyk7XG4gICAgICAgICAgICBjb250ZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2OiBFdmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250ZW50LmNsYXNzTGlzdC5hZGQoJ2lneC1vdmVybGF5X19jb250ZW50Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIChldjogRXZlbnQpID0+IHtcbiAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyAgaGlkZSBlbGVtZW50IHRvIGVsaW1pbmF0ZSBmbGlja2VyaW5nLiBTaG93IHRoZSBlbGVtZW50IGV4YWN0bHkgYmVmb3JlIGFuaW1hdGlvbiBzdGFydHNcbiAgICAgICAgY29udGVudC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG5cbiAgICAgICAgd3JhcHBlckVsZW1lbnQuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgICAgIHJldHVybiBjb250ZW50O1xuICAgIH1cblxuICAgIHByaXZhdGUgZ2V0T3ZlcmxheUVsZW1lbnQoaW5mbzogT3ZlcmxheUluZm8pOiBIVE1MRWxlbWVudCB7XG4gICAgICAgIGlmIChpbmZvLnNldHRpbmdzLm91dGxldCkge1xuICAgICAgICAgICAgcmV0dXJuIGluZm8uc2V0dGluZ3Mub3V0bGV0Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9vdmVybGF5RWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheUVsZW1lbnQgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlFbGVtZW50LmNsYXNzTGlzdC5hZGQoJ2lneC1vdmVybGF5Jyk7XG4gICAgICAgICAgICB0aGlzLl9kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX292ZXJsYXlFbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9vdmVybGF5RWxlbWVudDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZVNpemUoaW5mbzogT3ZlcmxheUluZm8pIHtcbiAgICAgICAgaWYgKGluZm8uY29tcG9uZW50UmVmKSB7XG4gICAgICAgICAgICAvLyAgaWYgd2UgYXJlIHBvc2l0aW9uaW5nIGNvbXBvbmVudCB0aGlzIGlzIGZpcnN0IHRpbWUgaXQgZ2V0cyB2aXNpYmxlXG4gICAgICAgICAgICAvLyAgYW5kIHdlIGNhbiBmaW5hbGx5IGdldCBpdHMgc2l6ZVxuICAgICAgICAgICAgaW5mby5pbml0aWFsU2l6ZSA9IGluZm8uZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gc2V0IGNvbnRlbnQgZGl2IHdpZHRoIG9ubHkgaWYgZWxlbWVudCB0byBzaG93IGhhcyB3aWR0aFxuICAgICAgICBpZiAoaW5mby5pbml0aWFsU2l6ZS53aWR0aCAhPT0gMCkge1xuICAgICAgICAgICAgaW5mby5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQucGFyZW50RWxlbWVudC5zdHlsZS53aWR0aCA9IGluZm8uaW5pdGlhbFNpemUud2lkdGggKyAncHgnO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXR1cE1vZGFsV3JhcHBlcihpbmZvOiBPdmVybGF5SW5mbykge1xuICAgICAgICBjb25zdCB3cmFwcGVyRWxlbWVudCA9IGluZm8uZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgZnJvbUV2ZW50KHdyYXBwZXJFbGVtZW50LCAna2V5ZG93bicpLnBpcGUoXG4gICAgICAgICAgICBmaWx0ZXIoKGV2OiBLZXlib2FyZEV2ZW50KSA9PiBldi5rZXkgPT09ICdFc2NhcGUnIHx8IGV2LmtleSA9PT0gJ0VzYycpLFxuICAgICAgICAgICAgdGFrZVVudGlsKHRoaXMuZGVzdHJveSQpXG4gICAgICAgICkuc3Vic2NyaWJlKCgpID0+IHRoaXMuaGlkZShpbmZvLmlkKSk7XG4gICAgICAgIHdyYXBwZXJFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2lneC1vdmVybGF5X193cmFwcGVyJyk7XG4gICAgICAgIHRoaXMuYXBwbHlBbmltYXRpb25QYXJhbXMod3JhcHBlckVsZW1lbnQsIGluZm8uc2V0dGluZ3MucG9zaXRpb25TdHJhdGVneS5zZXR0aW5ncy5vcGVuQW5pbWF0aW9uKTtcbiAgICAgICAgd3JhcHBlckVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnaWd4LW92ZXJsYXlfX3dyYXBwZXItLW1vZGFsJyk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBvbkNsb3NlRG9uZShpbmZvOiBPdmVybGF5SW5mbykge1xuICAgICAgICB0aGlzLmNsZWFuVXAoaW5mbyk7XG4gICAgICAgIHRoaXMub25DbG9zZWQuZW1pdCh7IGlkOiBpbmZvLmlkLCBjb21wb25lbnRSZWY6IGluZm8uY29tcG9uZW50UmVmIH0pO1xuICAgIH1cblxuICAgIHByaXZhdGUgY2xlYW5VcChpbmZvOiBPdmVybGF5SW5mbykge1xuICAgICAgICBjb25zdCBjaGlsZDogSFRNTEVsZW1lbnQgPSBpbmZvLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudDtcbiAgICAgICAgY29uc3Qgb3V0bGV0ID0gdGhpcy5nZXRPdmVybGF5RWxlbWVudChpbmZvKTtcbiAgICAgICAgaWYgKCFvdXRsZXQuY29udGFpbnMoY2hpbGQpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0NvbXBvbmVudCB3aXRoIGlkOicgKyBpbmZvLmlkICsgJyBpcyBhbHJlYWR5IHJlbW92ZWQhJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBvdXRsZXQucmVtb3ZlQ2hpbGQoY2hpbGQucGFyZW50Tm9kZS5wYXJlbnROb2RlKTtcbiAgICAgICAgaWYgKGluZm8uY29tcG9uZW50UmVmKSB7XG4gICAgICAgICAgICB0aGlzLl9hcHBSZWYuZGV0YWNoVmlldyhpbmZvLmNvbXBvbmVudFJlZi5ob3N0Vmlldyk7XG4gICAgICAgICAgICBpbmZvLmNvbXBvbmVudFJlZi5kZXN0cm95KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5mby5ob29rKSB7XG4gICAgICAgICAgICBpbmZvLmhvb2sucGFyZW50RWxlbWVudC5pbnNlcnRCZWZvcmUoaW5mby5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIGluZm8uaG9vayk7XG4gICAgICAgICAgICBpbmZvLmhvb2sucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChpbmZvLmhvb2spO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl9vdmVybGF5SW5mb3MuaW5kZXhPZihpbmZvKTtcbiAgICAgICAgdGhpcy5fb3ZlcmxheUluZm9zLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAgICAgLy8gdGhpcy5fb3ZlcmxheUVsZW1lbnQucGFyZW50RWxlbWVudCBjaGVjayBqdXN0IGZvciB0ZXN0cyB0aGF0IG1hbnVhbGx5IGRlbGV0ZSB0aGUgZWxlbWVudFxuICAgICAgICBpZiAodGhpcy5fb3ZlcmxheUluZm9zLmxlbmd0aCA9PT0gMCAmJiB0aGlzLl9vdmVybGF5RWxlbWVudCAmJiB0aGlzLl9vdmVybGF5RWxlbWVudC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5RWxlbWVudC5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHRoaXMuX292ZXJsYXlFbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgcGxheU9wZW5BbmltYXRpb24oaW5mbzogT3ZlcmxheUluZm8pIHtcbiAgICAgICAgaWYgKCFpbmZvLm9wZW5BbmltYXRpb25QbGF5ZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGFuaW1hdGlvbkJ1aWxkZXIgPSB0aGlzLmJ1aWxkZXIuYnVpbGQoaW5mby5zZXR0aW5ncy5wb3NpdGlvblN0cmF0ZWd5LnNldHRpbmdzLm9wZW5BbmltYXRpb24pO1xuICAgICAgICAgICAgaW5mby5vcGVuQW5pbWF0aW9uUGxheWVyID0gYW5pbWF0aW9uQnVpbGRlci5jcmVhdGUoaW5mby5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQpO1xuXG4gICAgICAgICAgICAvLyAgQW5pbWF0aW9uUGxheWVyLmdldFBvc2l0aW9uIHJldHVybnMgYWx3YXlzIDAuIFRvIHdvcmthcm91bmQgdGhpcyB3ZSBhcmUgZ2V0dGluZyBpbm5lciBXZWJBbmltYXRpb25QbGF5ZXJcbiAgICAgICAgICAgIC8vICBhbmQgdGhlbiBnZXR0aW5nIHRoZSBwb3NpdGlvbnMgZnJvbSBpdC5cbiAgICAgICAgICAgIC8vICBUaGlzIGlzIGxvZ2dlZCBpbiBBbmd1bGFyIGhlcmUgLSBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2lzc3Vlcy8xODg5MVxuICAgICAgICAgICAgLy8gIEFzIHNvb24gYXMgdGhpcyBpcyByZXNvbHZlZCB3ZSBjYW4gcmVtb3ZlIHRoaXMgaGFja1xuICAgICAgICAgICAgY29uc3QgaW5uZXJSZW5kZXJlciA9ICg8YW55PmluZm8ub3BlbkFuaW1hdGlvblBsYXllcikuX3JlbmRlcmVyO1xuICAgICAgICAgICAgaW5mby5vcGVuQW5pbWF0aW9uSW5uZXJQbGF5ZXIgPSBpbm5lclJlbmRlcmVyLmVuZ2luZS5wbGF5ZXJzW2lubmVyUmVuZGVyZXIuZW5naW5lLnBsYXllcnMubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICBpbmZvLm9wZW5BbmltYXRpb25QbGF5ZXIub25Eb25lKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uT3BlbmVkLmVtaXQoeyBpZDogaW5mby5pZCwgY29tcG9uZW50UmVmOiBpbmZvLmNvbXBvbmVudFJlZiB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5mby5vcGVuQW5pbWF0aW9uUGxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZm8ub3BlbkFuaW1hdGlvblBsYXllci5yZXNldCgpO1xuICAgICAgICAgICAgICAgICAgICBpbmZvLm9wZW5BbmltYXRpb25QbGF5ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpbmZvLmNsb3NlQW5pbWF0aW9uUGxheWVyICYmIGluZm8uY2xvc2VBbmltYXRpb25QbGF5ZXIuaGFzU3RhcnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZm8uY2xvc2VBbmltYXRpb25QbGF5ZXIucmVzZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vICBpZiB0aGVyZSBpcyBvcGVuaW5nIGFuaW1hdGlvbiBhbHJlYWR5IHN0YXJ0ZWQgZG8gbm90aGluZ1xuICAgICAgICBpZiAoaW5mby5vcGVuQW5pbWF0aW9uUGxheWVyLmhhc1N0YXJ0ZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gIGlmIHRoZXJlIGlzIGNsb3NpbmcgYW5pbWF0aW9uIGFscmVhZHkgc3RhcnRlZCBzdGFydCBvcGVuIGFuaW1hdGlvbiBmcm9tIHdoZXJlIGNsb3NlIG9uZSBoYXMgcmVhY2hlZFxuICAgICAgICAvLyAgYW5kIHJlbW92ZSBjbG9zZSBhbmltYXRpb25cbiAgICAgICAgaWYgKGluZm8uY2xvc2VBbmltYXRpb25QbGF5ZXIgJiYgaW5mby5jbG9zZUFuaW1hdGlvblBsYXllci5oYXNTdGFydGVkKCkpIHtcbiAgICAgICAgICAgIC8vICBnZXRQb3NpdGlvbigpIHJldHVybnMgd2hhdCBwYXJ0IG9mIHRoZSBhbmltYXRpb24gaXMgcGFzc2VkLCBlLmcuIDAuNSBpZiBoYWxmIHRoZSBhbmltYXRpb25cbiAgICAgICAgICAgIC8vICBpcyBkb25lLCAwLjc1IGlmIDMvNCBvZiB0aGUgYW5pbWF0aW9uIGlzIGRvbmUuIEFzIHdlIG5lZWQgdG8gc3RhcnQgbmV4dCBhbmltYXRpb24gZnJvbSB3aGVyZVxuICAgICAgICAgICAgLy8gIHRoZSBwcmV2aW91cyBoYXMgZmluaXNoZWQgd2UgbmVlZCB0aGUgYW1vdW50IHVwIHRvIDEsIHRoZXJlZm9yZSB3ZSBhcmUgc3VidHJhY3Rpbmcgd2hhdFxuICAgICAgICAgICAgLy8gIGdldFBvc2l0aW9uKCkgcmV0dXJucyBmcm9tIG9uZVxuICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSAxIC0gaW5mby5jbG9zZUFuaW1hdGlvbklubmVyUGxheWVyLmdldFBvc2l0aW9uKCk7XG4gICAgICAgICAgICBpbmZvLmNsb3NlQW5pbWF0aW9uUGxheWVyLnJlc2V0KCk7XG4gICAgICAgICAgICBpbmZvLmNsb3NlQW5pbWF0aW9uUGxheWVyID0gbnVsbDtcbiAgICAgICAgICAgIGluZm8ub3BlbkFuaW1hdGlvblBsYXllci5pbml0KCk7XG4gICAgICAgICAgICBpbmZvLm9wZW5BbmltYXRpb25QbGF5ZXIuc2V0UG9zaXRpb24ocG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5vbkFuaW1hdGlvbi5lbWl0KHsgaWQ6IGluZm8uaWQsIGFuaW1hdGlvblBsYXllcjogaW5mby5vcGVuQW5pbWF0aW9uUGxheWVyLCBhbmltYXRpb25UeXBlOiAnb3BlbicgfSk7XG5cbiAgICAgICAgLy8gIHRvIGVsaW1pbmF0ZSBmbGlja2VyaW5nIHNob3cgdGhlIGVsZW1lbnQganVzdCBiZWZvcmUgYW5pbWF0aW9uIHN0YXJ0XG4gICAgICAgIGluZm8uZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnBhcmVudEVsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICcnO1xuICAgICAgICBpbmZvLm9wZW5BbmltYXRpb25QbGF5ZXIucGxheSgpO1xuICAgIH1cblxuICAgIHByaXZhdGUgcGxheUNsb3NlQW5pbWF0aW9uKGluZm86IE92ZXJsYXlJbmZvKSB7XG4gICAgICAgIGlmICghaW5mby5jbG9zZUFuaW1hdGlvblBsYXllcikge1xuICAgICAgICAgICAgY29uc3QgYW5pbWF0aW9uQnVpbGRlciA9IHRoaXMuYnVpbGRlci5idWlsZChpbmZvLnNldHRpbmdzLnBvc2l0aW9uU3RyYXRlZ3kuc2V0dGluZ3MuY2xvc2VBbmltYXRpb24pO1xuICAgICAgICAgICAgaW5mby5jbG9zZUFuaW1hdGlvblBsYXllciA9IGFuaW1hdGlvbkJ1aWxkZXIuY3JlYXRlKGluZm8uZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50KTtcblxuICAgICAgICAgICAgLy8gIEFuaW1hdGlvblBsYXllci5nZXRQb3NpdGlvbiByZXR1cm5zIGFsd2F5cyAwLiBUbyB3b3JrYXJvdW5kIHRoaXMgd2UgYXJlIGdldHRpbmcgaW5uZXIgV2ViQW5pbWF0aW9uUGxheWVyXG4gICAgICAgICAgICAvLyAgYW5kIHRoZW4gZ2V0dGluZyB0aGUgcG9zaXRpb25zIGZyb20gaXQuXG4gICAgICAgICAgICAvLyAgVGhpcyBpcyBsb2dnZWQgaW4gQW5ndWxhciBoZXJlIC0gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9pc3N1ZXMvMTg4OTFcbiAgICAgICAgICAgIC8vICBBcyBzb29uIGFzIHRoaXMgaXMgcmVzb2x2ZWQgd2UgY2FuIHJlbW92ZSB0aGlzIGhhY2tcbiAgICAgICAgICAgIGNvbnN0IGlubmVyUmVuZGVyZXIgPSAoPGFueT5pbmZvLmNsb3NlQW5pbWF0aW9uUGxheWVyKS5fcmVuZGVyZXI7XG4gICAgICAgICAgICBpbmZvLmNsb3NlQW5pbWF0aW9uSW5uZXJQbGF5ZXIgPSBpbm5lclJlbmRlcmVyLmVuZ2luZS5wbGF5ZXJzW2lubmVyUmVuZGVyZXIuZW5naW5lLnBsYXllcnMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgICAgIGluZm8uY2xvc2VBbmltYXRpb25QbGF5ZXIub25Eb25lKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaW5mby5jbG9zZUFuaW1hdGlvblBsYXllcikge1xuICAgICAgICAgICAgICAgICAgICBpbmZvLmNsb3NlQW5pbWF0aW9uUGxheWVyLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIGluZm8uY2xvc2VBbmltYXRpb25QbGF5ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpbmZvLm9wZW5BbmltYXRpb25QbGF5ZXIgJiYgaW5mby5vcGVuQW5pbWF0aW9uUGxheWVyLmhhc1N0YXJ0ZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICBpbmZvLm9wZW5BbmltYXRpb25QbGF5ZXIucmVzZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNsb3NlRG9uZShpbmZvKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gIGlmIHRoZXJlIGlzIGNsb3NpbmcgYW5pbWF0aW9uIGFscmVhZHkgc3RhcnRlZCBkbyBub3RoaW5nXG4gICAgICAgIGlmIChpbmZvLmNsb3NlQW5pbWF0aW9uUGxheWVyLmhhc1N0YXJ0ZWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gIGlmIHRoZXJlIGlzIG9wZW5pbmcgYW5pbWF0aW9uIGFscmVhZHkgc3RhcnRlZCBzdGFydCBjbG9zZSBhbmltYXRpb24gZnJvbSB3aGVyZSBvcGVuIG9uZSBoYXMgcmVhY2hlZFxuICAgICAgICAvLyAgYW5kIHJlbW92ZSBvcGVuIGFuaW1hdGlvblxuICAgICAgICBpZiAoaW5mby5vcGVuQW5pbWF0aW9uUGxheWVyICYmIGluZm8ub3BlbkFuaW1hdGlvblBsYXllci5oYXNTdGFydGVkKCkpIHtcbiAgICAgICAgICAgIC8vICBnZXRQb3NpdGlvbigpIHJldHVybnMgd2hhdCBwYXJ0IG9mIHRoZSBhbmltYXRpb24gaXMgcGFzc2VkLCBlLmcuIDAuNSBpZiBoYWxmIHRoZSBhbmltYXRpb25cbiAgICAgICAgICAgIC8vICBpcyBkb25lLCAwLjc1IGlmIDMvNCBvZiB0aGUgYW5pbWF0aW9uIGlzIGRvbmUuIEFzIHdlIG5lZWQgdG8gc3RhcnQgbmV4dCBhbmltYXRpb24gZnJvbSB3aGVyZVxuICAgICAgICAgICAgLy8gIHRoZSBwcmV2aW91cyBoYXMgZmluaXNoZWQgd2UgbmVlZCB0aGUgYW1vdW50IHVwIHRvIDEsIHRoZXJlZm9yZSB3ZSBhcmUgc3VidHJhY3Rpbmcgd2hhdFxuICAgICAgICAgICAgLy8gIGdldFBvc2l0aW9uKCkgcmV0dXJucyBmcm9tIG9uZVxuICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSAxIC0gaW5mby5vcGVuQW5pbWF0aW9uSW5uZXJQbGF5ZXIuZ2V0UG9zaXRpb24oKTtcbiAgICAgICAgICAgIGluZm8ub3BlbkFuaW1hdGlvblBsYXllci5yZXNldCgpO1xuICAgICAgICAgICAgaW5mby5vcGVuQW5pbWF0aW9uUGxheWVyID0gbnVsbDtcbiAgICAgICAgICAgIGluZm8uY2xvc2VBbmltYXRpb25QbGF5ZXIuaW5pdCgpO1xuICAgICAgICAgICAgaW5mby5jbG9zZUFuaW1hdGlvblBsYXllci5zZXRQb3NpdGlvbihwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm9uQW5pbWF0aW9uLmVtaXQoeyBpZDogaW5mby5pZCwgYW5pbWF0aW9uUGxheWVyOiBpbmZvLmNsb3NlQW5pbWF0aW9uUGxheWVyLCBhbmltYXRpb25UeXBlOiAnY2xvc2UnIH0pO1xuICAgICAgICBpbmZvLmNsb3NlQW5pbWF0aW9uUGxheWVyLnBsYXkoKTtcbiAgICB9XG5cbiAgICAvLyAgVE9ETzogY2hlY2sgaWYgYXBwbHlBbmltYXRpb25QYXJhbXMgd2lsbCB3b3JrIHdpdGggY29tcGxleCBhbmltYXRpb25zXG4gICAgcHJpdmF0ZSBhcHBseUFuaW1hdGlvblBhcmFtcyh3cmFwcGVyRWxlbWVudDogSFRNTEVsZW1lbnQsIGFuaW1hdGlvbk9wdGlvbnM6IEFuaW1hdGlvblJlZmVyZW5jZU1ldGFkYXRhKSB7XG4gICAgICAgIGlmICghYW5pbWF0aW9uT3B0aW9ucykge1xuICAgICAgICAgICAgd3JhcHBlckVsZW1lbnQuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gJzBtcyc7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFuaW1hdGlvbk9wdGlvbnMudHlwZSA9PT0gQW5pbWF0aW9uTWV0YWRhdGFUeXBlLkFuaW1hdGVSZWYpIHtcbiAgICAgICAgICAgIGFuaW1hdGlvbk9wdGlvbnMgPSAoYW5pbWF0aW9uT3B0aW9ucyBhcyBBbmltYXRpb25BbmltYXRlUmVmTWV0YWRhdGEpLmFuaW1hdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFuaW1hdGlvbk9wdGlvbnMub3B0aW9ucyB8fCAhYW5pbWF0aW9uT3B0aW9ucy5vcHRpb25zLnBhcmFtcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IGFuaW1hdGlvbk9wdGlvbnMub3B0aW9ucy5wYXJhbXMgYXMgSUFuaW1hdGlvblBhcmFtcztcbiAgICAgICAgaWYgKHBhcmFtcy5kdXJhdGlvbikge1xuICAgICAgICAgICAgd3JhcHBlckVsZW1lbnQuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gcGFyYW1zLmR1cmF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJhbXMuZWFzaW5nKSB7XG4gICAgICAgICAgICB3cmFwcGVyRWxlbWVudC5zdHlsZS50cmFuc2l0aW9uVGltaW5nRnVuY3Rpb24gPSBwYXJhbXMuZWFzaW5nO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgcHVibGljIGdldE92ZXJsYXlCeUlkKGlkOiBzdHJpbmcpOiBPdmVybGF5SW5mbyB7XG4gICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaW5mbyA9IHRoaXMuX292ZXJsYXlJbmZvcy5maW5kKGUgPT4gZS5pZCA9PT0gaWQpO1xuICAgICAgICByZXR1cm4gaW5mbztcbiAgICB9XG5cbiAgICBwcml2YXRlIGRvY3VtZW50Q2xpY2tlZCA9IChldjogTW91c2VFdmVudCkgPT4ge1xuICAgICAgICAvLyAgaWYgd2UgZ2V0IHRvIG1vZGFsIG92ZXJsYXkganVzdCByZXR1cm4gLSB3ZSBzaG91bGQgbm90IGNsb3NlIGFueXRoaW5nIHVuZGVyIGl0XG4gICAgICAgIC8vICBpZiB3ZSBnZXQgdG8gbm9uLW1vZGFsIG92ZXJsYXkgZG8gdGhlIG5leHQ6XG4gICAgICAgIC8vICAgMS4gQ2hlY2sgaXQgaGFzIGNsb3NlIG9uIG91dHNpZGUgY2xpY2suIElmIG5vdCBnbyBvbiB0byBuZXh0IG92ZXJsYXk7XG4gICAgICAgIC8vICAgMi4gSWYgdHJ1ZSBjaGVjayBpZiBjbGljayBpcyBvbiB0aGUgZWxlbWVudC4gSWYgaXQgaXMgb24gdGhlIGVsZW1lbnQgd2UgaGF2ZSBjbG9zZWRcbiAgICAgICAgLy8gIGFscmVhZHkgYWxsIHByZXZpb3VzIG5vbi1tb2RhbCB3aXRoIGNsb3NlIG9uIG91dHNpZGUgY2xpY2sgZWxlbWVudHMsIHNvIHdlIHJldHVybi4gSWZcbiAgICAgICAgLy8gIG5vdCBjbG9zZSB0aGUgb3ZlcmxheSBhbmQgY2hlY2sgbmV4dFxuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5fb3ZlcmxheUluZm9zLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgICAgY29uc3QgaW5mbyA9IHRoaXMuX292ZXJsYXlJbmZvc1tpXTtcbiAgICAgICAgICAgIGlmIChpbmZvLnNldHRpbmdzLm1vZGFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGluZm8uc2V0dGluZ3MuY2xvc2VPbk91dHNpZGVDbGljaykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGV2LnRhcmdldCBhcyBhbnk7XG4gICAgICAgICAgICAgICAgLy8gIGlmIHRoZSBjbGljayBpcyBvbiB0aGUgZWxlbWVudCBkbyBub3QgY2xvc2UgdGhpcyBvdmVybGF5XG4gICAgICAgICAgICAgICAgaWYgKCFpbmZvLmVsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIHNob3VsZCBleGNsdWRlIHBvc2l0aW9uIHRhcmdldCBjaGVjayBpZiB0aGUgY2xpY2sgaXMgb3ZlciBpdC4gSWYgc28gZG8gbm90IGNsb3NlIG92ZXJsYXlcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb25UYXJnZXQgPSBpbmZvLnNldHRpbmdzLnBvc2l0aW9uU3RyYXRlZ3kuc2V0dGluZ3MudGFyZ2V0IGFzIEhUTUxFbGVtZW50O1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2xpY2tPblBvc2l0aW9uVGFyZ2V0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvblRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2tPblBvc2l0aW9uVGFyZ2V0ID0gcG9zaXRpb25UYXJnZXQuY29udGFpbnModGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghKGluZm8uc2V0dGluZ3MuZXhjbHVkZVBvc2l0aW9uVGFyZ2V0ICYmIGNsaWNrT25Qb3NpdGlvblRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICBpZiB0aGUgY2xpY2sgaXMgb3V0c2lkZSBjbGljaywgYnV0IGNsb3NlIGFuaW1hdGlvbiBoYXMgc3RhcnRlZCBkbyBub3RoaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShpbmZvLmNsb3NlQW5pbWF0aW9uUGxheWVyICYmIGluZm8uY2xvc2VBbmltYXRpb25QbGF5ZXIuaGFzU3RhcnRlZCgpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2hpZGUoaW5mby5pZCwgZXYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gIFRPRE86IHNob3VsZCB3ZSByZXR1cm4gaGVyZSwgb3IgY29udGludWUgd2l0aCBuZXh0IG92ZXJsYXlzXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGFkZE91dHNpZGVDbGlja0xpc3RlbmVyKGluZm86IE92ZXJsYXlJbmZvKSB7XG4gICAgICAgIGlmIChpbmZvLnNldHRpbmdzLmNsb3NlT25PdXRzaWRlQ2xpY2spIHtcbiAgICAgICAgICAgIGlmIChpbmZvLnNldHRpbmdzLm1vZGFsKSB7XG4gICAgICAgICAgICAgICAgZnJvbUV2ZW50KGluZm8uZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudCwgJ2NsaWNrJylcbiAgICAgICAgICAgICAgICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMuZGVzdHJveSQpKVxuICAgICAgICAgICAgICAgICAgICAuc3Vic2NyaWJlKChlOiBFdmVudCkgPT4gdGhpcy5faGlkZShpbmZvLmlkLCBlKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIC8vICBpZiBhbGwgb3ZlcmxheXMgbWludXMgY2xvc2luZyBvdmVybGF5cyBlcXVhbHMgb25lIGFkZCB0aGUgaGFuZGxlclxuICAgICAgICAgICAgICAgIHRoaXMuX292ZXJsYXlJbmZvcy5maWx0ZXIoeCA9PiB4LnNldHRpbmdzLmNsb3NlT25PdXRzaWRlQ2xpY2sgJiYgIXguc2V0dGluZ3MubW9kYWwpLmxlbmd0aCAtXG4gICAgICAgICAgICAgICAgdGhpcy5fb3ZlcmxheUluZm9zLmZpbHRlcih4ID0+IHguc2V0dGluZ3MuY2xvc2VPbk91dHNpZGVDbGljayAmJiAheC5zZXR0aW5ncy5tb2RhbCAmJlxuICAgICAgICAgICAgICAgICAgICB4LmNsb3NlQW5pbWF0aW9uUGxheWVyICYmXG4gICAgICAgICAgICAgICAgICAgIHguY2xvc2VBbmltYXRpb25QbGF5ZXIuaGFzU3RhcnRlZCgpKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuZG9jdW1lbnRDbGlja2VkLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgcmVtb3ZlT3V0c2lkZUNsaWNrTGlzdGVuZXIoaW5mbzogT3ZlcmxheUluZm8pIHtcbiAgICAgICAgaWYgKGluZm8uc2V0dGluZ3MubW9kYWwgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBsZXQgc2hvdWxkUmVtb3ZlQ2xpY2tFdmVudExpc3RlbmVyID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlJbmZvcy5mb3JFYWNoKG8gPT4ge1xuICAgICAgICAgICAgICAgIGlmIChvLnNldHRpbmdzLm1vZGFsID09PSBmYWxzZSAmJiBvLmlkICE9PSBpbmZvLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFJlbW92ZUNsaWNrRXZlbnRMaXN0ZW5lciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBpZiAoc2hvdWxkUmVtb3ZlQ2xpY2tFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmRvY3VtZW50Q2xpY2tlZCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIGFkZFJlc2l6ZUhhbmRsZXIoaWQ6IHN0cmluZykge1xuICAgICAgICBjb25zdCBjbG9zaW5nT3ZlcmxheXNDb3VudCA9XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5SW5mb3NcbiAgICAgICAgICAgICAgICAuZmlsdGVyKG8gPT4gby5jbG9zZUFuaW1hdGlvblBsYXllciAmJiBvLmNsb3NlQW5pbWF0aW9uUGxheWVyLmhhc1N0YXJ0ZWQoKSlcbiAgICAgICAgICAgICAgICAubGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5fb3ZlcmxheUluZm9zLmxlbmd0aCAtIGNsb3NpbmdPdmVybGF5c0NvdW50ID09PSAxKSB7XG4gICAgICAgICAgICB0aGlzLl9kb2N1bWVudC5kZWZhdWx0Vmlldy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlcG9zaXRpb25BbGwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSByZW1vdmVSZXNpemVIYW5kbGVyKGlkOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgY2xvc2luZ092ZXJsYXlzQ291bnQgPVxuICAgICAgICAgICAgdGhpcy5fb3ZlcmxheUluZm9zXG4gICAgICAgICAgICAgICAgLmZpbHRlcihvID0+IG8uY2xvc2VBbmltYXRpb25QbGF5ZXIgJiYgby5jbG9zZUFuaW1hdGlvblBsYXllci5oYXNTdGFydGVkKCkpXG4gICAgICAgICAgICAgICAgLmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMuX292ZXJsYXlJbmZvcy5sZW5ndGggLSBjbG9zaW5nT3ZlcmxheXNDb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5fZG9jdW1lbnQuZGVmYXVsdFZpZXcucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5yZXBvc2l0aW9uQWxsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgcHVibGljIHJlcG9zaXRpb25BbGwgPSAoKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLl9vdmVybGF5SW5mb3MubGVuZ3RoOyBpLS07KSB7XG4gICAgICAgICAgICB0aGlzLnJlcG9zaXRpb24odGhpcy5fb3ZlcmxheUluZm9zW2ldLmlkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5kZXN0cm95JC5uZXh0KHRydWUpO1xuICAgICAgICB0aGlzLmRlc3Ryb3kkLmNvbXBsZXRlKCk7XG4gICAgfVxufVxuIl19