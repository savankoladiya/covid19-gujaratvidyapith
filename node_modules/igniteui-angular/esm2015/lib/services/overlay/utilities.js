/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { cloneValue } from '../../core/utils';
/** @enum {number} */
const HorizontalAlignment = {
    Left: -1,
    Center: -0.5,
    Right: 0,
};
export { HorizontalAlignment };
HorizontalAlignment[HorizontalAlignment.Left] = 'Left';
HorizontalAlignment[HorizontalAlignment.Center] = 'Center';
HorizontalAlignment[HorizontalAlignment.Right] = 'Right';
/** @enum {number} */
const VerticalAlignment = {
    Top: -1,
    Middle: -0.5,
    Bottom: 0,
};
export { VerticalAlignment };
VerticalAlignment[VerticalAlignment.Top] = 'Top';
VerticalAlignment[VerticalAlignment.Middle] = 'Middle';
VerticalAlignment[VerticalAlignment.Bottom] = 'Bottom';
export class Point {
    /**
     * @param {?} x
     * @param {?} y
     */
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
}
if (false) {
    /** @type {?} */
    Point.prototype.x;
    /** @type {?} */
    Point.prototype.y;
}
/**
 * @record
 */
export function PositionSettings() { }
if (false) {
    /**
     * Attaching target for the component to show
     * @type {?|undefined}
     */
    PositionSettings.prototype.target;
    /**
     * Direction in which the component should show
     * @type {?|undefined}
     */
    PositionSettings.prototype.horizontalDirection;
    /**
     * Direction in which the component should show
     * @type {?|undefined}
     */
    PositionSettings.prototype.verticalDirection;
    /**
     * Target's starting point
     * @type {?|undefined}
     */
    PositionSettings.prototype.horizontalStartPoint;
    /**
     * Target's starting point
     * @type {?|undefined}
     */
    PositionSettings.prototype.verticalStartPoint;
    /**
     * Animation applied while overlay opens
     * @type {?|undefined}
     */
    PositionSettings.prototype.openAnimation;
    /**
     * Animation applied while overlay closes
     * @type {?|undefined}
     */
    PositionSettings.prototype.closeAnimation;
    /**
     * The size up to which element may shrink when shown in elastic position strategy
     * @type {?|undefined}
     */
    PositionSettings.prototype.minSize;
}
/**
 * @record
 */
export function OverlaySettings() { }
if (false) {
    /**
     * Position strategy to use with this settings
     * @type {?|undefined}
     */
    OverlaySettings.prototype.positionStrategy;
    /**
     * Scroll strategy to use with this settings
     * @type {?|undefined}
     */
    OverlaySettings.prototype.scrollStrategy;
    /**
     * Set if the overlay should be in modal mode
     * @type {?|undefined}
     */
    OverlaySettings.prototype.modal;
    /**
     * Set if the overlay should closed on outside click
     * @type {?|undefined}
     */
    OverlaySettings.prototype.closeOnOutsideClick;
    /**
     * Set the outlet container to attach the overlay to
     * @type {?|undefined}
     */
    OverlaySettings.prototype.outlet;
    /**
     * @hidden \@internal
     * Exclude the position strategy target for outside clicks
     * @type {?|undefined}
     */
    OverlaySettings.prototype.excludePositionTarget;
}
/**
 * @record
 */
export function OverlayEventArgs() { }
if (false) {
    /**
     * Id of the overlay generated with `attach()` method
     * @type {?}
     */
    OverlayEventArgs.prototype.id;
    /**
     * Available when `Type<T>` is provided to the `attach()` method and allows access to the created Component instance
     * @type {?|undefined}
     */
    OverlayEventArgs.prototype.componentRef;
}
/**
 * @record
 */
export function OverlayCancelableEventArgs() { }
/**
 * @record
 */
export function OverlayClosingEventArgs() { }
/**
 * @record
 */
export function OverlayAnimationEventArgs() { }
if (false) {
    /**
     * Id of the overlay generated with `attach()` method
     * @type {?}
     */
    OverlayAnimationEventArgs.prototype.id;
    /**
     * Animation player that will play the animation
     * @type {?}
     */
    OverlayAnimationEventArgs.prototype.animationPlayer;
    /**
     * Type of animation to be played. It should be either 'open' or 'close'
     * @type {?}
     */
    OverlayAnimationEventArgs.prototype.animationType;
}
/**
 * @record
 */
export function Size() { }
if (false) {
    /**
     * Gets or sets the horizontal component of Size
     * @type {?}
     */
    Size.prototype.width;
    /**
     * Gets or sets the vertical component of Size
     * @type {?}
     */
    Size.prototype.height;
}
/**
 * @hidden
 * @record
 */
export function OverlayInfo() { }
if (false) {
    /** @type {?|undefined} */
    OverlayInfo.prototype.id;
    /** @type {?|undefined} */
    OverlayInfo.prototype.elementRef;
    /** @type {?|undefined} */
    OverlayInfo.prototype.componentRef;
    /** @type {?|undefined} */
    OverlayInfo.prototype.settings;
    /** @type {?|undefined} */
    OverlayInfo.prototype.initialSize;
    /** @type {?|undefined} */
    OverlayInfo.prototype.hook;
    /** @type {?|undefined} */
    OverlayInfo.prototype.openAnimationPlayer;
    /** @type {?|undefined} */
    OverlayInfo.prototype.closeAnimationPlayer;
    /** @type {?|undefined} */
    OverlayInfo.prototype.openAnimationInnerPlayer;
    /** @type {?|undefined} */
    OverlayInfo.prototype.closeAnimationInnerPlayer;
    /** @type {?} */
    OverlayInfo.prototype.ngZone;
}
/**
 * @hidden
 */
export class Util {
    /**
     * @hidden
     * Calculates the rectangle of target for provided overlay settings. Defaults to 0,0,0,0,0,0 rectangle
     * if no target is provided
     * @param {?} settings Overlay settings for which to calculate target rectangle
     * @return {?}
     */
    static getTargetRect(settings) {
        /** @type {?} */
        let targetRect = {
            bottom: 0,
            height: 0,
            left: 0,
            right: 0,
            top: 0,
            width: 0
        };
        if (settings.target instanceof HTMLElement) {
            targetRect = ((/** @type {?} */ (settings.target))).getBoundingClientRect();
        }
        else if (settings.target instanceof Point) {
            /** @type {?} */
            const targetPoint = (/** @type {?} */ (settings.target));
            targetRect = {
                bottom: targetPoint.y,
                height: 0,
                left: targetPoint.x,
                right: targetPoint.x,
                top: targetPoint.y,
                width: 0
            };
        }
        return targetRect;
    }
    /**
     * @hidden \@internal
     * @param {?} document
     * @return {?}
     */
    static getViewportRect(document) {
        /** @type {?} */
        const width = document.documentElement.clientWidth;
        /** @type {?} */
        const height = document.documentElement.clientHeight;
        /** @type {?} */
        const scrollPosition = Util.getViewportScrollPosition(document);
        return {
            top: scrollPosition.y,
            left: scrollPosition.x,
            right: scrollPosition.x + width,
            bottom: scrollPosition.y + height,
            width: width,
            height: height,
        };
    }
    /**
     * @hidden \@internal
     * @param {?} document
     * @return {?}
     */
    static getViewportScrollPosition(document) {
        /** @type {?} */
        const documentElement = document.documentElement;
        /** @type {?} */
        const documentRect = documentElement.getBoundingClientRect();
        /** @type {?} */
        const horizontalScrollPosition = -documentRect.left || document.body.scrollLeft || window.scrollX || documentElement.scrollLeft || 0;
        /** @type {?} */
        const verticalScrollPosition = -documentRect.top || document.body.scrollTop || window.scrollY || documentElement.scrollTop || 0;
        return new Point(horizontalScrollPosition, verticalScrollPosition);
    }
    /**
     * @hidden \@internal
     * @param {?} object
     * @return {?}
     */
    static cloneInstance(object) {
        /** @type {?} */
        const clonedObj = Object.assign(Object.create(Object.getPrototypeOf(object)), object);
        clonedObj.settings = cloneValue(clonedObj.settings);
        return clonedObj;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbGl0aWVzLmpzIiwic291cmNlUm9vdCI6Im5nOi8vaWduaXRldWktYW5ndWxhci8iLCJzb3VyY2VzIjpbImxpYi9zZXJ2aWNlcy9vdmVybGF5L3V0aWxpdGllcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBTUEsT0FBTyxFQUFtRCxVQUFVLEVBQWtCLE1BQU0sa0JBQWtCLENBQUM7OztJQUczRyxRQUFTO0lBQ1QsWUFBYTtJQUNiLFFBQVM7Ozs7Ozs7O0lBSVQsT0FBUTtJQUNSLFlBQWE7SUFDYixTQUFVOzs7Ozs7QUFHZCxNQUFNLE9BQU8sS0FBSzs7Ozs7SUFDZCxZQUFtQixDQUFTLEVBQVMsQ0FBUztRQUEzQixNQUFDLEdBQUQsQ0FBQyxDQUFRO1FBQVMsTUFBQyxHQUFELENBQUMsQ0FBUTtJQUFJLENBQUM7Q0FDdEQ7OztJQURlLGtCQUFnQjs7SUFBRSxrQkFBZ0I7Ozs7O0FBR2xELHNDQWlCQzs7Ozs7O0lBZkcsa0NBQTZCOzs7OztJQUU3QiwrQ0FBMEM7Ozs7O0lBRTFDLDZDQUFzQzs7Ozs7SUFFdEMsZ0RBQTJDOzs7OztJQUUzQyw4Q0FBdUM7Ozs7O0lBRXZDLHlDQUEyQzs7Ozs7SUFFM0MsMENBQTRDOzs7OztJQUU1QyxtQ0FBZTs7Ozs7QUFHbkIscUNBZ0JDOzs7Ozs7SUFkRywyQ0FBcUM7Ozs7O0lBRXJDLHlDQUFpQzs7Ozs7SUFFakMsZ0NBQWdCOzs7OztJQUVoQiw4Q0FBOEI7Ozs7O0lBRTlCLGlDQUFnRDs7Ozs7O0lBS2hELGdEQUFnQzs7Ozs7QUFHcEMsc0NBS0M7Ozs7OztJQUhHLDhCQUFXOzs7OztJQUVYLHdDQUFnQzs7Ozs7QUFHcEMsZ0RBQ0M7Ozs7QUFFRCw2Q0FDQzs7OztBQUVELCtDQU9DOzs7Ozs7SUFMRyx1Q0FBVzs7Ozs7SUFFWCxvREFBaUM7Ozs7O0lBRWpDLGtEQUFnQzs7Ozs7QUFHcEMsMEJBTUM7Ozs7OztJQUpHLHFCQUFjOzs7OztJQUdkLHNCQUFlOzs7Ozs7QUFJbkIsaUNBWUM7OztJQVhHLHlCQUFZ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QUFDO0lBQ3JCLENBQUM7Q0FDSiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IElQb3NpdGlvblN0cmF0ZWd5IH0gZnJvbSAnLi9wb3NpdGlvbi9JUG9zaXRpb25TdHJhdGVneSc7XG5cbmltcG9ydCB7IElTY3JvbGxTdHJhdGVneSB9IGZyb20gJy4vc2Nyb2xsJztcbmltcG9ydCB7IEFuaW1hdGlvblJlZmVyZW5jZU1ldGFkYXRhLCBBbmltYXRpb25QbGF5ZXIgfSBmcm9tICdAYW5ndWxhci9hbmltYXRpb25zJztcbmltcG9ydCB7IENvbXBvbmVudFJlZiwgRWxlbWVudFJlZiwgTmdab25lIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBJZ3hPdmVybGF5T3V0bGV0RGlyZWN0aXZlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy90b2dnbGUvdG9nZ2xlLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBDYW5jZWxhYmxlRXZlbnRBcmdzLCBDYW5jZWxhYmxlQnJvd3NlckV2ZW50QXJncywgY2xvbmVWYWx1ZSwgSUJhc2VFdmVudEFyZ3MgfSBmcm9tICcuLi8uLi9jb3JlL3V0aWxzJztcblxuZXhwb3J0IGVudW0gSG9yaXpvbnRhbEFsaWdubWVudCB7XG4gICAgTGVmdCA9IC0xLFxuICAgIENlbnRlciA9IC0wLjUsXG4gICAgUmlnaHQgPSAwXG59XG5cbmV4cG9ydCBlbnVtIFZlcnRpY2FsQWxpZ25tZW50IHtcbiAgICBUb3AgPSAtMSxcbiAgICBNaWRkbGUgPSAtMC41LFxuICAgIEJvdHRvbSA9IDBcbn1cblxuZXhwb3J0IGNsYXNzIFBvaW50IHtcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgeDogbnVtYmVyLCBwdWJsaWMgeTogbnVtYmVyKSB7IH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBQb3NpdGlvblNldHRpbmdzIHtcbiAgICAvKiogQXR0YWNoaW5nIHRhcmdldCBmb3IgdGhlIGNvbXBvbmVudCB0byBzaG93ICovXG4gICAgdGFyZ2V0PzogUG9pbnQgfCBIVE1MRWxlbWVudDtcbiAgICAvKiogRGlyZWN0aW9uIGluIHdoaWNoIHRoZSBjb21wb25lbnQgc2hvdWxkIHNob3cgKi9cbiAgICBob3Jpem9udGFsRGlyZWN0aW9uPzogSG9yaXpvbnRhbEFsaWdubWVudDtcbiAgICAvKiogRGlyZWN0aW9uIGluIHdoaWNoIHRoZSBjb21wb25lbnQgc2hvdWxkIHNob3cgKi9cbiAgICB2ZXJ0aWNhbERpcmVjdGlvbj86IFZlcnRpY2FsQWxpZ25tZW50O1xuICAgIC8qKiBUYXJnZXQncyBzdGFydGluZyBwb2ludCAqL1xuICAgIGhvcml6b250YWxTdGFydFBvaW50PzogSG9yaXpvbnRhbEFsaWdubWVudDtcbiAgICAvKiogVGFyZ2V0J3Mgc3RhcnRpbmcgcG9pbnQgKi9cbiAgICB2ZXJ0aWNhbFN0YXJ0UG9pbnQ/OiBWZXJ0aWNhbEFsaWdubWVudDtcbiAgICAvKiogQW5pbWF0aW9uIGFwcGxpZWQgd2hpbGUgb3ZlcmxheSBvcGVucyAqL1xuICAgIG9wZW5BbmltYXRpb24/OiBBbmltYXRpb25SZWZlcmVuY2VNZXRhZGF0YTtcbiAgICAvKiogQW5pbWF0aW9uIGFwcGxpZWQgd2hpbGUgb3ZlcmxheSBjbG9zZXMgKi9cbiAgICBjbG9zZUFuaW1hdGlvbj86IEFuaW1hdGlvblJlZmVyZW5jZU1ldGFkYXRhO1xuICAgIC8qKiBUaGUgc2l6ZSB1cCB0byB3aGljaCBlbGVtZW50IG1heSBzaHJpbmsgd2hlbiBzaG93biBpbiBlbGFzdGljIHBvc2l0aW9uIHN0cmF0ZWd5ICovXG4gICAgbWluU2l6ZT86IFNpemU7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3ZlcmxheVNldHRpbmdzIHtcbiAgICAvKiogUG9zaXRpb24gc3RyYXRlZ3kgdG8gdXNlIHdpdGggdGhpcyBzZXR0aW5ncyAqL1xuICAgIHBvc2l0aW9uU3RyYXRlZ3k/OiBJUG9zaXRpb25TdHJhdGVneTtcbiAgICAvKiogU2Nyb2xsIHN0cmF0ZWd5IHRvIHVzZSB3aXRoIHRoaXMgc2V0dGluZ3MgKi9cbiAgICBzY3JvbGxTdHJhdGVneT86IElTY3JvbGxTdHJhdGVneTtcbiAgICAvKiogU2V0IGlmIHRoZSBvdmVybGF5IHNob3VsZCBiZSBpbiBtb2RhbCBtb2RlICovXG4gICAgbW9kYWw/OiBib29sZWFuO1xuICAgIC8qKiBTZXQgaWYgdGhlIG92ZXJsYXkgc2hvdWxkIGNsb3NlZCBvbiBvdXRzaWRlIGNsaWNrICovXG4gICAgY2xvc2VPbk91dHNpZGVDbGljaz86IGJvb2xlYW47XG4gICAgLyoqIFNldCB0aGUgb3V0bGV0IGNvbnRhaW5lciB0byBhdHRhY2ggdGhlIG92ZXJsYXkgdG8gKi9cbiAgICBvdXRsZXQ/OiBJZ3hPdmVybGF5T3V0bGV0RGlyZWN0aXZlIHwgRWxlbWVudFJlZjtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuIEBpbnRlcm5hbFxuICAgICAqIEV4Y2x1ZGUgdGhlIHBvc2l0aW9uIHN0cmF0ZWd5IHRhcmdldCBmb3Igb3V0c2lkZSBjbGlja3NcbiAgICAgKi9cbiAgICBleGNsdWRlUG9zaXRpb25UYXJnZXQ/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE92ZXJsYXlFdmVudEFyZ3MgZXh0ZW5kcyBJQmFzZUV2ZW50QXJncyB7XG4gICAgLyoqIElkIG9mIHRoZSBvdmVybGF5IGdlbmVyYXRlZCB3aXRoIGBhdHRhY2goKWAgbWV0aG9kICovXG4gICAgaWQ6IHN0cmluZztcbiAgICAvKiogQXZhaWxhYmxlIHdoZW4gYFR5cGU8VD5gIGlzIHByb3ZpZGVkIHRvIHRoZSBgYXR0YWNoKClgIG1ldGhvZCBhbmQgYWxsb3dzIGFjY2VzcyB0byB0aGUgY3JlYXRlZCBDb21wb25lbnQgaW5zdGFuY2UgKi9cbiAgICBjb21wb25lbnRSZWY/OiBDb21wb25lbnRSZWY8e30+O1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE92ZXJsYXlDYW5jZWxhYmxlRXZlbnRBcmdzIGV4dGVuZHMgT3ZlcmxheUV2ZW50QXJncywgQ2FuY2VsYWJsZUV2ZW50QXJncyB7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3ZlcmxheUNsb3NpbmdFdmVudEFyZ3MgZXh0ZW5kcyBPdmVybGF5RXZlbnRBcmdzLCBDYW5jZWxhYmxlQnJvd3NlckV2ZW50QXJncyB7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3ZlcmxheUFuaW1hdGlvbkV2ZW50QXJncyBleHRlbmRzIElCYXNlRXZlbnRBcmdzIHtcbiAgICAvKiogSWQgb2YgdGhlIG92ZXJsYXkgZ2VuZXJhdGVkIHdpdGggYGF0dGFjaCgpYCBtZXRob2QgKi9cbiAgICBpZDogc3RyaW5nO1xuICAgIC8qKiBBbmltYXRpb24gcGxheWVyIHRoYXQgd2lsbCBwbGF5IHRoZSBhbmltYXRpb24gKi9cbiAgICBhbmltYXRpb25QbGF5ZXI6IEFuaW1hdGlvblBsYXllcjtcbiAgICAvKiogVHlwZSBvZiBhbmltYXRpb24gdG8gYmUgcGxheWVkLiBJdCBzaG91bGQgYmUgZWl0aGVyICdvcGVuJyBvciAnY2xvc2UnICovXG4gICAgYW5pbWF0aW9uVHlwZTogJ29wZW4nIHwgJ2Nsb3NlJztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTaXplIHtcbiAgICAvKiogR2V0cyBvciBzZXRzIHRoZSBob3Jpem9udGFsIGNvbXBvbmVudCBvZiBTaXplICovXG4gICAgd2lkdGg6IG51bWJlcjtcblxuICAgIC8qKiBHZXRzIG9yIHNldHMgdGhlIHZlcnRpY2FsIGNvbXBvbmVudCBvZiBTaXplICovXG4gICAgaGVpZ2h0OiBudW1iZXI7XG59XG5cbi8qKiBAaGlkZGVuICovXG5leHBvcnQgaW50ZXJmYWNlIE92ZXJsYXlJbmZvIHtcbiAgICBpZD86IHN0cmluZztcbiAgICBlbGVtZW50UmVmPzogRWxlbWVudFJlZjtcbiAgICBjb21wb25lbnRSZWY/OiBDb21wb25lbnRSZWY8e30+O1xuICAgIHNldHRpbmdzPzogT3ZlcmxheVNldHRpbmdzO1xuICAgIGluaXRpYWxTaXplPzogU2l6ZTtcbiAgICBob29rPzogSFRNTEVsZW1lbnQ7XG4gICAgb3BlbkFuaW1hdGlvblBsYXllcj86IEFuaW1hdGlvblBsYXllcjtcbiAgICBjbG9zZUFuaW1hdGlvblBsYXllcj86IEFuaW1hdGlvblBsYXllcjtcbiAgICBvcGVuQW5pbWF0aW9uSW5uZXJQbGF5ZXI/OiBhbnk7XG4gICAgY2xvc2VBbmltYXRpb25Jbm5lclBsYXllcj86IGFueTtcbiAgICBuZ1pvbmU6IE5nWm9uZTtcbn1cblxuLyoqIEBoaWRkZW4gKi9cbmV4cG9ydCBjbGFzcyBVdGlsIHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgcmVjdGFuZ2xlIG9mIHRhcmdldCBmb3IgcHJvdmlkZWQgb3ZlcmxheSBzZXR0aW5ncy4gRGVmYXVsdHMgdG8gMCwwLDAsMCwwLDAgcmVjdGFuZ2xlXG4gICAgICogaWYgbm8gdGFyZ2V0IGlzIHByb3ZpZGVkXG4gICAgICogQHBhcmFtIHNldHRpbmdzIE92ZXJsYXkgc2V0dGluZ3MgZm9yIHdoaWNoIHRvIGNhbGN1bGF0ZSB0YXJnZXQgcmVjdGFuZ2xlXG4gICAgICovXG4gICAgc3RhdGljIGdldFRhcmdldFJlY3Qoc2V0dGluZ3M6IFBvc2l0aW9uU2V0dGluZ3MpOiBDbGllbnRSZWN0IHtcbiAgICAgICAgbGV0IHRhcmdldFJlY3Q6IENsaWVudFJlY3QgPSB7XG4gICAgICAgICAgICBib3R0b206IDAsXG4gICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgICBsZWZ0OiAwLFxuICAgICAgICAgICAgcmlnaHQ6IDAsXG4gICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICB3aWR0aDogMFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChzZXR0aW5ncy50YXJnZXQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgdGFyZ2V0UmVjdCA9IChzZXR0aW5ncy50YXJnZXQgYXMgSFRNTEVsZW1lbnQpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHNldHRpbmdzLnRhcmdldCBpbnN0YW5jZW9mIFBvaW50KSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXRQb2ludCA9IHNldHRpbmdzLnRhcmdldCBhcyBQb2ludDtcbiAgICAgICAgICAgIHRhcmdldFJlY3QgPSB7XG4gICAgICAgICAgICAgICAgYm90dG9tOiB0YXJnZXRQb2ludC55LFxuICAgICAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgICAgICBsZWZ0OiB0YXJnZXRQb2ludC54LFxuICAgICAgICAgICAgICAgIHJpZ2h0OiB0YXJnZXRQb2ludC54LFxuICAgICAgICAgICAgICAgIHRvcDogdGFyZ2V0UG9pbnQueSxcbiAgICAgICAgICAgICAgICB3aWR0aDogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXRSZWN0O1xuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuIEBpbnRlcm5hbCAqL1xuICAgIHN0YXRpYyBnZXRWaWV3cG9ydFJlY3QoZG9jdW1lbnQ6IERvY3VtZW50KTogQ2xpZW50UmVjdCB7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgICBjb25zdCBzY3JvbGxQb3NpdGlvbiA9IFV0aWwuZ2V0Vmlld3BvcnRTY3JvbGxQb3NpdGlvbihkb2N1bWVudCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvcDogc2Nyb2xsUG9zaXRpb24ueSxcbiAgICAgICAgICAgIGxlZnQ6IHNjcm9sbFBvc2l0aW9uLngsXG4gICAgICAgICAgICByaWdodDogc2Nyb2xsUG9zaXRpb24ueCArIHdpZHRoLFxuICAgICAgICAgICAgYm90dG9tOiBzY3JvbGxQb3NpdGlvbi55ICsgaGVpZ2h0LFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gQGludGVybmFsICovXG4gICAgc3RhdGljIGdldFZpZXdwb3J0U2Nyb2xsUG9zaXRpb24oZG9jdW1lbnQ6IERvY3VtZW50KTogUG9pbnQge1xuICAgICAgICBjb25zdCBkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50UmVjdCA9IGRvY3VtZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICBjb25zdCBob3Jpem9udGFsU2Nyb2xsUG9zaXRpb24gPVxuICAgICAgICAgICAgLWRvY3VtZW50UmVjdC5sZWZ0IHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCB8fCB3aW5kb3cuc2Nyb2xsWCB8fCBkb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCB8fCAwO1xuICAgICAgICBjb25zdCB2ZXJ0aWNhbFNjcm9sbFBvc2l0aW9uID0gLWRvY3VtZW50UmVjdC50b3AgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgfHwgd2luZG93LnNjcm9sbFkgfHwgZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCAwO1xuXG4gICAgICAgIHJldHVybiBuZXcgUG9pbnQoaG9yaXpvbnRhbFNjcm9sbFBvc2l0aW9uLCB2ZXJ0aWNhbFNjcm9sbFBvc2l0aW9uKTtcbiAgICB9XG5cbiAgICAvKiogQGhpZGRlbiBAaW50ZXJuYWwqL1xuICAgIHN0YXRpYyBjbG9uZUluc3RhbmNlKG9iamVjdCkge1xuICAgICAgICBjb25zdCBjbG9uZWRPYmogPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iamVjdCkpLCBvYmplY3QpO1xuICAgICAgICBjbG9uZWRPYmouc2V0dGluZ3MgPSBjbG9uZVZhbHVlKGNsb25lZE9iai5zZXR0aW5ncyk7XG4gICAgICAgIHJldHVybiBjbG9uZWRPYmo7XG4gICAgfVxufVxuIl19