/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { BaseFitPositionStrategy } from './base-fit-position-strategy';
import { HorizontalAlignment, VerticalAlignment } from '../utilities';
/**
 * Positions the element as in **Connected** positioning strategy and resize the element
 * to fit in the view port in case the element is partially getting out of view
 */
export class ElasticPositionStrategy extends BaseFitPositionStrategy {
    /**
     * \@inheritdoc
     * @protected
     * @param {?} element
     * @param {?} connectedFit
     * @return {?}
     */
    fitInViewport(element, connectedFit) {
        element.classList.add('igx-overlay__content--elastic');
        /** @type {?} */
        const transformString = [];
        if (!connectedFit.fitHorizontal) {
            /** @type {?} */
            const maxReduction = Math.max(0, connectedFit.contentElementRect.width - this.settings.minSize.width);
            /** @type {?} */
            const leftExtend = Math.max(0, 0 - connectedFit.left);
            /** @type {?} */
            const rightExtend = Math.max(0, connectedFit.right - connectedFit.viewPortRect.width);
            /** @type {?} */
            const reduction = Math.min(maxReduction, leftExtend + rightExtend);
            element.style.width = `${connectedFit.contentElementRect.width - reduction}px`;
            //  if direction is center and element goes off the screen in left direction we should push the
            //  element to the right. Prevents left still going out of view when normally positioned
            if (this.settings.horizontalDirection === HorizontalAlignment.Center) {
                //  the amount of translation depends on whether element goes off the screen to the left,
                //  to the right or in both directions, as well as how much it goes of the screen and finally
                //  on the minSize. The translation should be proportional between left and right extend
                //  taken from the reduction
                /** @type {?} */
                const translation = leftExtend * reduction / (leftExtend + rightExtend);
                if (translation > 0) {
                    transformString.push(`translateX(${translation}px)`);
                }
            }
        }
        if (!connectedFit.fitVertical) {
            /** @type {?} */
            const maxReduction = Math.max(0, connectedFit.contentElementRect.height - this.settings.minSize.height);
            /** @type {?} */
            const topExtend = Math.max(0, 0 - connectedFit.top);
            /** @type {?} */
            const bottomExtend = Math.max(0, connectedFit.bottom - connectedFit.viewPortRect.height);
            /** @type {?} */
            const reduction = Math.min(maxReduction, topExtend + bottomExtend);
            element.style.height = `${connectedFit.contentElementRect.height - reduction}px`;
            //  if direction is middle and element goes off the screen in top direction we should push the
            //  element to the bottom. Prevents top still going out of view when normally positioned
            if (this.settings.verticalDirection === VerticalAlignment.Middle) {
                //  the amount of translation depends on whether element goes off the screen to the top,
                //  to the bottom or in both directions, as well as how much it goes of the screen and finally
                //  on the minSize. The translation should be proportional between top and bottom extend
                //  taken from the reduction
                /** @type {?} */
                const translation = topExtend * reduction / (topExtend + bottomExtend);
                if (translation > 0) {
                    transformString.push(`translateY(${translation}px)`);
                }
            }
        }
        element.style.transform = transformString.join(' ').trim();
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWxhc3RpYy1wb3NpdGlvbi1zdHJhdGVneS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvc2VydmljZXMvb3ZlcmxheS9wb3NpdGlvbi9lbGFzdGljLXBvc2l0aW9uLXN0cmF0ZWd5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUUsdUJBQXVCLEVBQWdCLE1BQU0sOEJBQThCLENBQUM7QUFDckYsT0FBTyxFQUFFLG1CQUFtQixFQUFFLGlCQUFpQixFQUFFLE1BQU0sY0FBYyxDQUFDOzs7OztBQU10RSxNQUFNLE9BQU8sdUJBQXdCLFNBQVEsdUJBQXVCOzs7Ozs7OztJQUV0RCxhQUFhLENBQUMsT0FBb0IsRUFBRSxZQUEwQjtRQUNwRSxPQUFPLENBQUMsU0FBUyxDQUFDLEdBQUcsQ0FBQywrQkFBK0IsQ0FBQyxDQUFDOztjQUNqRCxlQUFlLEdBQWEsRUFBRTtRQUNwQyxJQUFJLENBQUMsWUFBWSxDQUFDLGFBQWEsRUFBRTs7a0JBQ3ZCLFlBQVksR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxZQUFZLENBQUMsa0JBQWtCLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQzs7a0JBQy9GLFVBQVUsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEdBQUcsWUFBWSxDQUFDLElBQUksQ0FBQzs7a0JBQy9DLFdBQVcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxZQUFZLENBQUMsS0FBSyxHQUFHLFlBQVksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDOztrQkFDL0UsU0FBUyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsWUFBWSxFQUFFLFVBQVUsR0FBRyxXQUFXLENBQUM7WUFDbEUsT0FBTyxDQUFDLEtBQUssQ0FBQyxLQUFLLEdBQUcsR0FBRyxZQUFZLENBQUMsa0JBQWtCLENBQUMsS0FBSyxHQUFHLFNBQVMsSUFBSSxDQUFDO1lBRS9FLCtGQUErRjtZQUMvRix3RkFBd0Y7WUFDeEYsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLG1CQUFtQixLQUFLLG1CQUFtQixDQUFDLE1BQU0sRUFBRTs7Ozs7O3NCQUs1RCxXQUFXLEdBQUcsVUFBVSxHQUFHLFNBQVMsR0FBRyxDQUFDLFVBQVUsR0FBRyxXQUFXLENBQUM7Z0JBQ3ZFLElBQUksV0FBVyxHQUFHLENBQUMsRUFBRTtvQkFDakIsZUFBZSxDQUFDLElBQUksQ0FBQyxjQUFjLFdBQVcsS0FBSyxDQUFDLENBQUM7aUJBQ3hEO2FBQ0o7U0FDSjtRQUVELElBQUksQ0FBQyxZQUFZLENBQUMsV0FBVyxFQUFFOztrQkFDckIsWUFBWSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLFlBQVksQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDOztrQkFDakcsU0FBUyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsR0FBRyxZQUFZLENBQUMsR0FBRyxDQUFDOztrQkFDN0MsWUFBWSxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLFlBQVksQ0FBQyxNQUFNLEdBQUcsWUFBWSxDQUFDLFlBQVksQ0FBQyxNQUFNLENBQUM7O2tCQUNsRixTQUFTLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxZQUFZLEVBQUUsU0FBUyxHQUFHLFlBQVksQ0FBQztZQUNsRSxPQUFPLENBQUMsS0FBSyxDQUFDLE1BQU0sR0FBRyxHQUFHLFlBQVksQ0FBQyxrQkFBa0IsQ0FBQyxNQUFNLEdBQUcsU0FBUyxJQUFJLENBQUM7WUFFakYsOEZBQThGO1lBQzlGLHdGQUF3RjtZQUN4RixJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsaUJBQWlCLEtBQUssaUJBQWlCLENBQUMsTUFBTSxFQUFFOzs7Ozs7c0JBS3hELFdBQVcsR0FBRyxTQUFTLEdBQUcsU0FBUyxHQUFHLENBQUMsU0FBUyxHQUFHLFlBQVksQ0FBQztnQkFDdEUsSUFBSSxXQUFXLEdBQUcsQ0FBQyxFQUFFO29CQUNqQixlQUFlLENBQUMsSUFBSSxDQUFDLGNBQWMsV0FBVyxLQUFLLENBQUMsQ0FBQztpQkFDeEQ7YUFDSjtTQUNKO1FBQ0QsT0FBTyxDQUFDLEtBQUssQ0FBQyxTQUFTLEdBQUcsZUFBZSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUMvRCxDQUFDO0NBQ0oiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlRml0UG9zaXRpb25TdHJhdGVneSwgQ29ubmVjdGVkRml0IH0gZnJvbSAnLi9iYXNlLWZpdC1wb3NpdGlvbi1zdHJhdGVneSc7XG5pbXBvcnQgeyBIb3Jpem9udGFsQWxpZ25tZW50LCBWZXJ0aWNhbEFsaWdubWVudCB9IGZyb20gJy4uL3V0aWxpdGllcyc7XG5cbi8qKlxuICogUG9zaXRpb25zIHRoZSBlbGVtZW50IGFzIGluICoqQ29ubmVjdGVkKiogcG9zaXRpb25pbmcgc3RyYXRlZ3kgYW5kIHJlc2l6ZSB0aGUgZWxlbWVudFxuICogdG8gZml0IGluIHRoZSB2aWV3IHBvcnQgaW4gY2FzZSB0aGUgZWxlbWVudCBpcyBwYXJ0aWFsbHkgZ2V0dGluZyBvdXQgb2Ygdmlld1xuICovXG5leHBvcnQgY2xhc3MgRWxhc3RpY1Bvc2l0aW9uU3RyYXRlZ3kgZXh0ZW5kcyBCYXNlRml0UG9zaXRpb25TdHJhdGVneSB7XG4gICAgLyoqIEBpbmhlcml0ZG9jICovXG4gICAgcHJvdGVjdGVkIGZpdEluVmlld3BvcnQoZWxlbWVudDogSFRNTEVsZW1lbnQsIGNvbm5lY3RlZEZpdDogQ29ubmVjdGVkRml0KSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgnaWd4LW92ZXJsYXlfX2NvbnRlbnQtLWVsYXN0aWMnKTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtU3RyaW5nOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgICBpZiAoIWNvbm5lY3RlZEZpdC5maXRIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICBjb25zdCBtYXhSZWR1Y3Rpb24gPSBNYXRoLm1heCgwLCBjb25uZWN0ZWRGaXQuY29udGVudEVsZW1lbnRSZWN0LndpZHRoIC0gdGhpcy5zZXR0aW5ncy5taW5TaXplLndpZHRoKTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnRFeHRlbmQgPSBNYXRoLm1heCgwLCAwIC0gY29ubmVjdGVkRml0LmxlZnQpO1xuICAgICAgICAgICAgY29uc3QgcmlnaHRFeHRlbmQgPSBNYXRoLm1heCgwLCBjb25uZWN0ZWRGaXQucmlnaHQgLSBjb25uZWN0ZWRGaXQudmlld1BvcnRSZWN0LndpZHRoKTtcbiAgICAgICAgICAgIGNvbnN0IHJlZHVjdGlvbiA9IE1hdGgubWluKG1heFJlZHVjdGlvbiwgbGVmdEV4dGVuZCArIHJpZ2h0RXh0ZW5kKTtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUud2lkdGggPSBgJHtjb25uZWN0ZWRGaXQuY29udGVudEVsZW1lbnRSZWN0LndpZHRoIC0gcmVkdWN0aW9ufXB4YDtcblxuICAgICAgICAgICAgLy8gIGlmIGRpcmVjdGlvbiBpcyBjZW50ZXIgYW5kIGVsZW1lbnQgZ29lcyBvZmYgdGhlIHNjcmVlbiBpbiBsZWZ0IGRpcmVjdGlvbiB3ZSBzaG91bGQgcHVzaCB0aGVcbiAgICAgICAgICAgIC8vICBlbGVtZW50IHRvIHRoZSByaWdodC4gUHJldmVudHMgbGVmdCBzdGlsbCBnb2luZyBvdXQgb2YgdmlldyB3aGVuIG5vcm1hbGx5IHBvc2l0aW9uZWRcbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLmhvcml6b250YWxEaXJlY3Rpb24gPT09IEhvcml6b250YWxBbGlnbm1lbnQuQ2VudGVyKSB7XG4gICAgICAgICAgICAgICAgLy8gIHRoZSBhbW91bnQgb2YgdHJhbnNsYXRpb24gZGVwZW5kcyBvbiB3aGV0aGVyIGVsZW1lbnQgZ29lcyBvZmYgdGhlIHNjcmVlbiB0byB0aGUgbGVmdCxcbiAgICAgICAgICAgICAgICAvLyAgdG8gdGhlIHJpZ2h0IG9yIGluIGJvdGggZGlyZWN0aW9ucywgYXMgd2VsbCBhcyBob3cgbXVjaCBpdCBnb2VzIG9mIHRoZSBzY3JlZW4gYW5kIGZpbmFsbHlcbiAgICAgICAgICAgICAgICAvLyAgb24gdGhlIG1pblNpemUuIFRoZSB0cmFuc2xhdGlvbiBzaG91bGQgYmUgcHJvcG9ydGlvbmFsIGJldHdlZW4gbGVmdCBhbmQgcmlnaHQgZXh0ZW5kXG4gICAgICAgICAgICAgICAgLy8gIHRha2VuIGZyb20gdGhlIHJlZHVjdGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zbGF0aW9uID0gbGVmdEV4dGVuZCAqIHJlZHVjdGlvbiAvIChsZWZ0RXh0ZW5kICsgcmlnaHRFeHRlbmQpO1xuICAgICAgICAgICAgICAgIGlmICh0cmFuc2xhdGlvbiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtU3RyaW5nLnB1c2goYHRyYW5zbGF0ZVgoJHt0cmFuc2xhdGlvbn1weClgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNvbm5lY3RlZEZpdC5maXRWZXJ0aWNhbCkge1xuICAgICAgICAgICAgY29uc3QgbWF4UmVkdWN0aW9uID0gTWF0aC5tYXgoMCwgY29ubmVjdGVkRml0LmNvbnRlbnRFbGVtZW50UmVjdC5oZWlnaHQgLSB0aGlzLnNldHRpbmdzLm1pblNpemUuaGVpZ2h0KTtcbiAgICAgICAgICAgIGNvbnN0IHRvcEV4dGVuZCA9IE1hdGgubWF4KDAsIDAgLSBjb25uZWN0ZWRGaXQudG9wKTtcbiAgICAgICAgICAgIGNvbnN0IGJvdHRvbUV4dGVuZCA9IE1hdGgubWF4KDAsIGNvbm5lY3RlZEZpdC5ib3R0b20gLSBjb25uZWN0ZWRGaXQudmlld1BvcnRSZWN0LmhlaWdodCk7XG4gICAgICAgICAgICBjb25zdCByZWR1Y3Rpb24gPSBNYXRoLm1pbihtYXhSZWR1Y3Rpb24sIHRvcEV4dGVuZCArIGJvdHRvbUV4dGVuZCk7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLmhlaWdodCA9IGAke2Nvbm5lY3RlZEZpdC5jb250ZW50RWxlbWVudFJlY3QuaGVpZ2h0IC0gcmVkdWN0aW9ufXB4YDtcblxuICAgICAgICAgICAgLy8gIGlmIGRpcmVjdGlvbiBpcyBtaWRkbGUgYW5kIGVsZW1lbnQgZ29lcyBvZmYgdGhlIHNjcmVlbiBpbiB0b3AgZGlyZWN0aW9uIHdlIHNob3VsZCBwdXNoIHRoZVxuICAgICAgICAgICAgLy8gIGVsZW1lbnQgdG8gdGhlIGJvdHRvbS4gUHJldmVudHMgdG9wIHN0aWxsIGdvaW5nIG91dCBvZiB2aWV3IHdoZW4gbm9ybWFsbHkgcG9zaXRpb25lZFxuICAgICAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MudmVydGljYWxEaXJlY3Rpb24gPT09IFZlcnRpY2FsQWxpZ25tZW50Lk1pZGRsZSkge1xuICAgICAgICAgICAgICAgIC8vICB0aGUgYW1vdW50IG9mIHRyYW5zbGF0aW9uIGRlcGVuZHMgb24gd2hldGhlciBlbGVtZW50IGdvZXMgb2ZmIHRoZSBzY3JlZW4gdG8gdGhlIHRvcCxcbiAgICAgICAgICAgICAgICAvLyAgdG8gdGhlIGJvdHRvbSBvciBpbiBib3RoIGRpcmVjdGlvbnMsIGFzIHdlbGwgYXMgaG93IG11Y2ggaXQgZ29lcyBvZiB0aGUgc2NyZWVuIGFuZCBmaW5hbGx5XG4gICAgICAgICAgICAgICAgLy8gIG9uIHRoZSBtaW5TaXplLiBUaGUgdHJhbnNsYXRpb24gc2hvdWxkIGJlIHByb3BvcnRpb25hbCBiZXR3ZWVuIHRvcCBhbmQgYm90dG9tIGV4dGVuZFxuICAgICAgICAgICAgICAgIC8vICB0YWtlbiBmcm9tIHRoZSByZWR1Y3Rpb25cbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2xhdGlvbiA9IHRvcEV4dGVuZCAqIHJlZHVjdGlvbiAvICh0b3BFeHRlbmQgKyBib3R0b21FeHRlbmQpO1xuICAgICAgICAgICAgICAgIGlmICh0cmFuc2xhdGlvbiA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtU3RyaW5nLnB1c2goYHRyYW5zbGF0ZVkoJHt0cmFuc2xhdGlvbn1weClgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1TdHJpbmcuam9pbignICcpLnRyaW0oKTtcbiAgICB9XG59XG4iXX0=