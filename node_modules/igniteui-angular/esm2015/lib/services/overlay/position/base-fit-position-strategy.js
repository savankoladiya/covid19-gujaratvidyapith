/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ConnectedPositioningStrategy } from './connected-positioning-strategy';
import { Util } from '../utilities';
/**
 * @abstract
 */
export class BaseFitPositionStrategy extends ConnectedPositioningStrategy {
    /**
     * \@inheritdoc
     * @param {?} contentElement
     * @param {?} size
     * @param {?=} document
     * @param {?=} initialCall
     * @return {?}
     */
    position(contentElement, size, document, initialCall) {
        /** @type {?} */
        const targetRect = Util.getTargetRect(this.settings);
        /** @type {?} */
        const contentElementRect = contentElement.getBoundingClientRect();
        if (initialCall) {
            /** @type {?} */
            const connectedFit = {};
            connectedFit.targetRect = targetRect;
            connectedFit.contentElementRect = contentElementRect;
            this._initialSettings = this._initialSettings || Object.assign({}, this.settings);
            this.settings = Object.assign({}, this._initialSettings);
            connectedFit.viewPortRect = Util.getViewportRect(document);
            this.updateViewPortFit(connectedFit);
            if (!connectedFit.fitHorizontal || !connectedFit.fitVertical) {
                this.fitInViewport(contentElement, connectedFit);
            }
        }
        this.setStyle(contentElement, targetRect, contentElementRect);
    }
    /**
     * Checks if element can fit in viewport and updates provided connectedFit
     * with the result
     * @protected
     * @param {?} connectedFit connectedFit to update
     * @return {?}
     */
    updateViewPortFit(connectedFit) {
        connectedFit.left = this.calculateLeft(connectedFit.targetRect, connectedFit.contentElementRect, this.settings.horizontalStartPoint, this.settings.horizontalDirection);
        connectedFit.right = connectedFit.left + connectedFit.contentElementRect.width;
        connectedFit.fitHorizontal =
            0 < connectedFit.left && connectedFit.right < connectedFit.viewPortRect.width;
        connectedFit.top = this.calculateTop(connectedFit.targetRect, connectedFit.contentElementRect, this.settings.verticalStartPoint, this.settings.verticalDirection);
        connectedFit.bottom = connectedFit.top + connectedFit.contentElementRect.height;
        connectedFit.fitVertical =
            0 < connectedFit.top && connectedFit.bottom < connectedFit.viewPortRect.height;
    }
    /**
     * Calculates the position of the left border of the element if it gets positioned
     * with provided start point and direction
     * @protected
     * @param {?} targetRect Rectangle of the target where element is attached
     * @param {?} elementRect Rectangle of the element
     * @param {?} startPoint Start point of the target
     * @param {?} direction Direction in which to show the element
     * @return {?}
     */
    calculateLeft(targetRect, elementRect, startPoint, direction) {
        return targetRect.right + targetRect.width * startPoint + elementRect.width * direction;
    }
    /**
     * Calculates the position of the top border of the element if it gets positioned
     * with provided position settings related to the target
     * @protected
     * @param {?} targetRect Rectangle of the target where element is attached
     * @param {?} elementRect Rectangle of the element
     * @param {?} startPoint Start point of the target
     * @param {?} direction Direction in which to show the element
     * @return {?}
     */
    calculateTop(targetRect, elementRect, startPoint, direction) {
        return targetRect.bottom + targetRect.height * startPoint + elementRect.height * direction;
    }
}
if (false) {
    /**
     * @type {?}
     * @protected
     */
    BaseFitPositionStrategy.prototype._initialSize;
    /**
     * @type {?}
     * @protected
     */
    BaseFitPositionStrategy.prototype._initialSettings;
    /**
     * Fits the element into viewport according to the position settings
     * @abstract
     * @protected
     * @param {?} element element to fit in viewport
     * @param {?} connectedFit connectedFit object containing all necessary parameters
     * @return {?}
     */
    BaseFitPositionStrategy.prototype.fitInViewport = function (element, connectedFit) { };
}
/**
 * @record
 */
export function ConnectedFit() { }
if (false) {
    /** @type {?|undefined} */
    ConnectedFit.prototype.contentElementRect;
    /** @type {?|undefined} */
    ConnectedFit.prototype.targetRect;
    /** @type {?|undefined} */
    ConnectedFit.prototype.viewPortRect;
    /** @type {?|undefined} */
    ConnectedFit.prototype.fitHorizontal;
    /** @type {?|undefined} */
    ConnectedFit.prototype.fitVertical;
    /** @type {?|undefined} */
    ConnectedFit.prototype.left;
    /** @type {?|undefined} */
    ConnectedFit.prototype.right;
    /** @type {?|undefined} */
    ConnectedFit.prototype.top;
    /** @type {?|undefined} */
    ConnectedFit.prototype.bottom;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS1maXQtcG9zaXRpb24tc3RyYXRlZ3kuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9pZ25pdGV1aS1hbmd1bGFyLyIsInNvdXJjZXMiOlsibGliL3NlcnZpY2VzL292ZXJsYXkvcG9zaXRpb24vYmFzZS1maXQtcG9zaXRpb24tc3RyYXRlZ3kudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSw0QkFBNEIsRUFBRSxNQUFNLGtDQUFrQyxDQUFDO0FBQ2hGLE9BQU8sRUFBa0UsSUFBSSxFQUFFLE1BQU0sY0FBYyxDQUFDOzs7O0FBRXBHLE1BQU0sT0FBZ0IsdUJBQXdCLFNBQVEsNEJBQTRCOzs7Ozs7Ozs7SUFLOUUsUUFBUSxDQUFDLGNBQTJCLEVBQUUsSUFBVSxFQUFFLFFBQW1CLEVBQUUsV0FBcUI7O2NBQ2xGLFVBQVUsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUM7O2NBQzlDLGtCQUFrQixHQUFHLGNBQWMsQ0FBQyxxQkFBcUIsRUFBRTtRQUNqRSxJQUFJLFdBQVcsRUFBRTs7a0JBQ1AsWUFBWSxHQUFpQixFQUFFO1lBQ3JDLFlBQVksQ0FBQyxVQUFVLEdBQUcsVUFBVSxDQUFDO1lBQ3JDLFlBQVksQ0FBQyxrQkFBa0IsR0FBRyxrQkFBa0IsQ0FBQztZQUNyRCxJQUFJLENBQUMsZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLGdCQUFnQixJQUFJLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUNsRixJQUFJLENBQUMsUUFBUSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1lBQ3pELFlBQVksQ0FBQyxZQUFZLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQyxRQUFRLENBQUMsQ0FBQztZQUMzRCxJQUFJLENBQUMsaUJBQWlCLENBQUMsWUFBWSxDQUFDLENBQUM7WUFDckMsSUFBSSxDQUFDLFlBQVksQ0FBQyxhQUFhLElBQUksQ0FBQyxZQUFZLENBQUMsV0FBVyxFQUFFO2dCQUMxRCxJQUFJLENBQUMsYUFBYSxDQUFDLGNBQWMsRUFBRSxZQUFZLENBQUMsQ0FBQzthQUNwRDtTQUNKO1FBQ0QsSUFBSSxDQUFDLFFBQVEsQ0FBQyxjQUFjLEVBQUUsVUFBVSxFQUFFLGtCQUFrQixDQUFDLENBQUM7SUFDbEUsQ0FBQzs7Ozs7Ozs7SUFPUyxpQkFBaUIsQ0FBQyxZQUEwQjtRQUNsRCxZQUFZLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQ2xDLFlBQVksQ0FBQyxVQUFVLEVBQ3ZCLFlBQVksQ0FBQyxrQkFBa0IsRUFDL0IsSUFBSSxDQUFDLFFBQVEsQ0FBQyxvQkFBb0IsRUFDbEMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1FBQ3ZDLFlBQVksQ0FBQyxLQUFLLEdBQUcsWUFBWSxDQUFDLElBQUksR0FBRyxZQUFZLENBQUMsa0JBQWtCLENBQUMsS0FBSyxDQUFDO1FBQy9FLFlBQVksQ0FBQyxhQUFhO1lBQ3RCLENBQUMsR0FBRyxZQUFZLENBQUMsSUFBSSxJQUFJLFlBQVksQ0FBQyxLQUFLLEdBQUcsWUFBWSxDQUFDLFlBQVksQ0FBQyxLQUFLLENBQUM7UUFFbEYsWUFBWSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsWUFBWSxDQUNoQyxZQUFZLENBQUMsVUFBVSxFQUN2QixZQUFZLENBQUMsa0JBQWtCLEVBQy9CLElBQUksQ0FBQyxRQUFRLENBQUMsa0JBQWtCLEVBQ2hDLElBQUksQ0FBQyxRQUFRLENBQUMsaUJBQWlCLENBQUMsQ0FBQztRQUNyQyxZQUFZLENBQUMsTUFBTSxHQUFHLFlBQVksQ0FBQyxHQUFHLEdBQUcsWUFBWSxDQUFDLGtCQUFrQixDQUFDLE1BQU0sQ0FBQztRQUNoRixZQUFZLENBQUMsV0FBVztZQUNwQixDQUFDLEdBQUcsWUFBWSxDQUFDLEdBQUcsSUFBSSxZQUFZLENBQUMsTUFBTSxHQUFHLFlBQVksQ0FBQyxZQUFZLENBQUMsTUFBTSxDQUFDO0lBQ3ZGLENBQUM7Ozs7Ozs7Ozs7O0lBVVMsYUFBYSxDQUNuQixVQUFzQixFQUFFLFdBQXVCLEVBQUUsVUFBK0IsRUFBRSxTQUE4QjtRQUNoSCxPQUFPLFVBQVUsQ0FBQyxLQUFLLEdBQUcsVUFBVSxDQUFDLEtBQUssR0FBRyxVQUFVLEdBQUcsV0FBVyxDQUFDLEtBQUssR0FBRyxTQUFTLENBQUM7SUFDNUYsQ0FBQzs7Ozs7Ozs7Ozs7SUFVUyxZQUFZLENBQ2xCLFVBQXNCLEVBQUUsV0FBdUIsRUFBRSxVQUE2QixFQUFFLFNBQTRCO1FBQzVHLE9BQU8sVUFBVSxDQUFDLE1BQU0sR0FBRyxVQUFVLENBQUMsTUFBTSxHQUFHLFVBQVUsR0FBRyxXQUFXLENBQUMsTUFBTSxHQUFHLFNBQVMsQ0FBQztJQUMvRixDQUFDO0NBVUo7Ozs7OztJQWpGRywrQ0FBNkI7Ozs7O0lBQzdCLG1EQUE2Qzs7Ozs7Ozs7O0lBNkU3Qyx1RkFFZ0M7Ozs7O0FBR3BDLGtDQVVDOzs7SUFURywwQ0FBZ0M7O0lBQ2hDLGtDQUF3Qjs7SUFDeEIsb0NBQTBCOztJQUMxQixxQ0FBd0I7O0lBQ3hCLG1DQUFzQjs7SUFDdEIsNEJBQWM7O0lBQ2QsNkJBQWU7O0lBQ2YsMkJBQWE7O0lBQ2IsOEJBQWdCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29ubmVjdGVkUG9zaXRpb25pbmdTdHJhdGVneSB9IGZyb20gJy4vY29ubmVjdGVkLXBvc2l0aW9uaW5nLXN0cmF0ZWd5JztcbmltcG9ydCB7IEhvcml6b250YWxBbGlnbm1lbnQsIFZlcnRpY2FsQWxpZ25tZW50LCBQb3NpdGlvblNldHRpbmdzLCBTaXplLCBVdGlsIH0gZnJvbSAnLi4vdXRpbGl0aWVzJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEJhc2VGaXRQb3NpdGlvblN0cmF0ZWd5IGV4dGVuZHMgQ29ubmVjdGVkUG9zaXRpb25pbmdTdHJhdGVneSB7XG4gICAgcHJvdGVjdGVkIF9pbml0aWFsU2l6ZTogU2l6ZTtcbiAgICBwcm90ZWN0ZWQgX2luaXRpYWxTZXR0aW5nczogUG9zaXRpb25TZXR0aW5ncztcblxuICAgIC8qKiBAaW5oZXJpdGRvYyAqL1xuICAgIHBvc2l0aW9uKGNvbnRlbnRFbGVtZW50OiBIVE1MRWxlbWVudCwgc2l6ZTogU2l6ZSwgZG9jdW1lbnQ/OiBEb2N1bWVudCwgaW5pdGlhbENhbGw/OiBib29sZWFuKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHRhcmdldFJlY3QgPSBVdGlsLmdldFRhcmdldFJlY3QodGhpcy5zZXR0aW5ncyk7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRFbGVtZW50UmVjdCA9IGNvbnRlbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBpZiAoaW5pdGlhbENhbGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3RlZEZpdDogQ29ubmVjdGVkRml0ID0ge307XG4gICAgICAgICAgICBjb25uZWN0ZWRGaXQudGFyZ2V0UmVjdCA9IHRhcmdldFJlY3Q7XG4gICAgICAgICAgICBjb25uZWN0ZWRGaXQuY29udGVudEVsZW1lbnRSZWN0ID0gY29udGVudEVsZW1lbnRSZWN0O1xuICAgICAgICAgICAgdGhpcy5faW5pdGlhbFNldHRpbmdzID0gdGhpcy5faW5pdGlhbFNldHRpbmdzIHx8IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc2V0dGluZ3MpO1xuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX2luaXRpYWxTZXR0aW5ncyk7XG4gICAgICAgICAgICBjb25uZWN0ZWRGaXQudmlld1BvcnRSZWN0ID0gVXRpbC5nZXRWaWV3cG9ydFJlY3QoZG9jdW1lbnQpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVWaWV3UG9ydEZpdChjb25uZWN0ZWRGaXQpO1xuICAgICAgICAgICAgaWYgKCFjb25uZWN0ZWRGaXQuZml0SG9yaXpvbnRhbCB8fCAhY29ubmVjdGVkRml0LmZpdFZlcnRpY2FsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXRJblZpZXdwb3J0KGNvbnRlbnRFbGVtZW50LCBjb25uZWN0ZWRGaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0U3R5bGUoY29udGVudEVsZW1lbnQsIHRhcmdldFJlY3QsIGNvbnRlbnRFbGVtZW50UmVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGVsZW1lbnQgY2FuIGZpdCBpbiB2aWV3cG9ydCBhbmQgdXBkYXRlcyBwcm92aWRlZCBjb25uZWN0ZWRGaXRcbiAgICAgKiB3aXRoIHRoZSByZXN1bHRcbiAgICAgKiBAcGFyYW0gY29ubmVjdGVkRml0IGNvbm5lY3RlZEZpdCB0byB1cGRhdGVcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgdXBkYXRlVmlld1BvcnRGaXQoY29ubmVjdGVkRml0OiBDb25uZWN0ZWRGaXQpIHtcbiAgICAgICAgY29ubmVjdGVkRml0LmxlZnQgPSB0aGlzLmNhbGN1bGF0ZUxlZnQoXG4gICAgICAgICAgICBjb25uZWN0ZWRGaXQudGFyZ2V0UmVjdCxcbiAgICAgICAgICAgIGNvbm5lY3RlZEZpdC5jb250ZW50RWxlbWVudFJlY3QsXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLmhvcml6b250YWxTdGFydFBvaW50LFxuICAgICAgICAgICAgdGhpcy5zZXR0aW5ncy5ob3Jpem9udGFsRGlyZWN0aW9uKTtcbiAgICAgICAgY29ubmVjdGVkRml0LnJpZ2h0ID0gY29ubmVjdGVkRml0LmxlZnQgKyBjb25uZWN0ZWRGaXQuY29udGVudEVsZW1lbnRSZWN0LndpZHRoO1xuICAgICAgICBjb25uZWN0ZWRGaXQuZml0SG9yaXpvbnRhbCA9XG4gICAgICAgICAgICAwIDwgY29ubmVjdGVkRml0LmxlZnQgJiYgY29ubmVjdGVkRml0LnJpZ2h0IDwgY29ubmVjdGVkRml0LnZpZXdQb3J0UmVjdC53aWR0aDtcblxuICAgICAgICBjb25uZWN0ZWRGaXQudG9wID0gdGhpcy5jYWxjdWxhdGVUb3AoXG4gICAgICAgICAgICBjb25uZWN0ZWRGaXQudGFyZ2V0UmVjdCxcbiAgICAgICAgICAgIGNvbm5lY3RlZEZpdC5jb250ZW50RWxlbWVudFJlY3QsXG4gICAgICAgICAgICB0aGlzLnNldHRpbmdzLnZlcnRpY2FsU3RhcnRQb2ludCxcbiAgICAgICAgICAgIHRoaXMuc2V0dGluZ3MudmVydGljYWxEaXJlY3Rpb24pO1xuICAgICAgICBjb25uZWN0ZWRGaXQuYm90dG9tID0gY29ubmVjdGVkRml0LnRvcCArIGNvbm5lY3RlZEZpdC5jb250ZW50RWxlbWVudFJlY3QuaGVpZ2h0O1xuICAgICAgICBjb25uZWN0ZWRGaXQuZml0VmVydGljYWwgPVxuICAgICAgICAgICAgMCA8IGNvbm5lY3RlZEZpdC50b3AgJiYgY29ubmVjdGVkRml0LmJvdHRvbSA8IGNvbm5lY3RlZEZpdC52aWV3UG9ydFJlY3QuaGVpZ2h0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGN1bGF0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBsZWZ0IGJvcmRlciBvZiB0aGUgZWxlbWVudCBpZiBpdCBnZXRzIHBvc2l0aW9uZWRcbiAgICAgKiB3aXRoIHByb3ZpZGVkIHN0YXJ0IHBvaW50IGFuZCBkaXJlY3Rpb25cbiAgICAgKiBAcGFyYW0gdGFyZ2V0UmVjdCBSZWN0YW5nbGUgb2YgdGhlIHRhcmdldCB3aGVyZSBlbGVtZW50IGlzIGF0dGFjaGVkXG4gICAgICogQHBhcmFtIGVsZW1lbnRSZWN0IFJlY3RhbmdsZSBvZiB0aGUgZWxlbWVudFxuICAgICAqIEBwYXJhbSBzdGFydFBvaW50IFN0YXJ0IHBvaW50IG9mIHRoZSB0YXJnZXRcbiAgICAgKiBAcGFyYW0gZGlyZWN0aW9uIERpcmVjdGlvbiBpbiB3aGljaCB0byBzaG93IHRoZSBlbGVtZW50XG4gICAgICovXG4gICAgcHJvdGVjdGVkIGNhbGN1bGF0ZUxlZnQoXG4gICAgICAgIHRhcmdldFJlY3Q6IENsaWVudFJlY3QsIGVsZW1lbnRSZWN0OiBDbGllbnRSZWN0LCBzdGFydFBvaW50OiBIb3Jpem9udGFsQWxpZ25tZW50LCBkaXJlY3Rpb246IEhvcml6b250YWxBbGlnbm1lbnQpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gdGFyZ2V0UmVjdC5yaWdodCArIHRhcmdldFJlY3Qud2lkdGggKiBzdGFydFBvaW50ICsgZWxlbWVudFJlY3Qud2lkdGggKiBkaXJlY3Rpb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIHRvcCBib3JkZXIgb2YgdGhlIGVsZW1lbnQgaWYgaXQgZ2V0cyBwb3NpdGlvbmVkXG4gICAgICogd2l0aCBwcm92aWRlZCBwb3NpdGlvbiBzZXR0aW5ncyByZWxhdGVkIHRvIHRoZSB0YXJnZXRcbiAgICAgKiBAcGFyYW0gdGFyZ2V0UmVjdCBSZWN0YW5nbGUgb2YgdGhlIHRhcmdldCB3aGVyZSBlbGVtZW50IGlzIGF0dGFjaGVkXG4gICAgICogQHBhcmFtIGVsZW1lbnRSZWN0IFJlY3RhbmdsZSBvZiB0aGUgZWxlbWVudFxuICAgICAqIEBwYXJhbSBzdGFydFBvaW50IFN0YXJ0IHBvaW50IG9mIHRoZSB0YXJnZXRcbiAgICAgKiBAcGFyYW0gZGlyZWN0aW9uIERpcmVjdGlvbiBpbiB3aGljaCB0byBzaG93IHRoZSBlbGVtZW50XG4gICAgICovXG4gICAgcHJvdGVjdGVkIGNhbGN1bGF0ZVRvcChcbiAgICAgICAgdGFyZ2V0UmVjdDogQ2xpZW50UmVjdCwgZWxlbWVudFJlY3Q6IENsaWVudFJlY3QsIHN0YXJ0UG9pbnQ6IFZlcnRpY2FsQWxpZ25tZW50LCBkaXJlY3Rpb246IFZlcnRpY2FsQWxpZ25tZW50KTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldFJlY3QuYm90dG9tICsgdGFyZ2V0UmVjdC5oZWlnaHQgKiBzdGFydFBvaW50ICsgZWxlbWVudFJlY3QuaGVpZ2h0ICogZGlyZWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpdHMgdGhlIGVsZW1lbnQgaW50byB2aWV3cG9ydCBhY2NvcmRpbmcgdG8gdGhlIHBvc2l0aW9uIHNldHRpbmdzXG4gICAgICogQHBhcmFtIGVsZW1lbnQgZWxlbWVudCB0byBmaXQgaW4gdmlld3BvcnRcbiAgICAgKiBAcGFyYW0gY29ubmVjdGVkRml0IGNvbm5lY3RlZEZpdCBvYmplY3QgY29udGFpbmluZyBhbGwgbmVjZXNzYXJ5IHBhcmFtZXRlcnNcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgYWJzdHJhY3QgZml0SW5WaWV3cG9ydChcbiAgICAgICAgZWxlbWVudDogSFRNTEVsZW1lbnQsXG4gICAgICAgIGNvbm5lY3RlZEZpdDogQ29ubmVjdGVkRml0KTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb25uZWN0ZWRGaXQge1xuICAgIGNvbnRlbnRFbGVtZW50UmVjdD86IENsaWVudFJlY3Q7XG4gICAgdGFyZ2V0UmVjdD86IENsaWVudFJlY3Q7XG4gICAgdmlld1BvcnRSZWN0PzogQ2xpZW50UmVjdDtcbiAgICBmaXRIb3Jpem9udGFsPzogYm9vbGVhbjtcbiAgICBmaXRWZXJ0aWNhbD86IGJvb2xlYW47XG4gICAgbGVmdD86IG51bWJlcjtcbiAgICByaWdodD86IG51bWJlcjtcbiAgICB0b3A/OiBudW1iZXI7XG4gICAgYm90dG9tPzogbnVtYmVyO1xufVxuIl19