/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { CommonModule } from '@angular/common';
import { Component, ElementRef, EventEmitter, HostBinding, Input, NgModule, Output, Renderer2, ViewChild, TemplateRef, ContentChild, HostListener, ViewChildren, QueryList, ChangeDetectorRef } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { DeprecateProperty } from '../core/deprecateDecorators';
import { IgxSliderThumbComponent } from './thumb/thumb-slider.component';
import { Subject, merge, timer } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { SliderHandle, IgxThumbFromTemplateDirective, IgxThumbToTemplateDirective, SliderType } from './slider.common';
import { IgxThumbLabelComponent } from './label/thumb-label.component';
/** @type {?} */
const noop = () => {
};
const ɵ0 = noop;
/** @type {?} */
let NEXT_ID = 0;
/**
 * **Ignite UI for Angular Slider** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/slider.html)
 *
 * The Ignite UI Slider allows selection in a given range by moving the thumb along the track. The track
 * can be defined as continuous or stepped, and you can choose between single and range slider types.
 *
 * Example:
 * ```html
 * <igx-slider id="slider"
 *            [minValue]="0" [maxValue]="100"
 *            [continuous]=true [(ngModel)]="volume">
 * </igx-slider>
 * ```
 */
export class IgxSliderComponent {
    /**
     * @param {?} renderer
     * @param {?} _el
     * @param {?} _cdr
     */
    constructor(renderer, _el, _cdr) {
        this.renderer = renderer;
        this._el = _el;
        this._cdr = _cdr;
        // Limit handle travel zone
        this._pMin = 0;
        this._pMax = 1;
        // From/upperValue in percent values
        this._hasViewInit = false;
        this._minValue = 0;
        this._maxValue = 100;
        this._continuous = false;
        this._disabled = false;
        this._step = 1;
        this._labels = new Array();
        this._type = SliderType.SLIDER;
        this._destroyer$ = new Subject();
        this._indicatorsDestroyer$ = new Subject();
        this._onChangeCallback = noop;
        this._onTouchedCallback = noop;
        /**
         * @hidden
         */
        this.thumbs = new QueryList();
        /**
         * @hidden
         */
        this.labelRefs = new QueryList();
        /**
         * @hidden
         */
        this.stepDistance = this._step;
        /**
         * @hidden
         */
        this.onPan = new Subject();
        /**
         * @hidden
         */
        this.role = 'slider';
        /**
         * @hidden
         */
        this.slierClass = true;
        /**
         * An \@Input property that sets the value of the `id` attribute.
         * If not provided it will be automatically generated.
         * ```html
         * <igx-slider [id]="'igx-slider-32'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
         * ```
         */
        this.id = `igx-slider-${NEXT_ID++}`;
        /**
         * An \@Input property that sets the duration visibility of thumbs labels. The default value is 750 milliseconds.
         * ```html
         * <igx-slider #slider [thumbLabelVisibilityDuration]="3000" [(ngModel)]="task.percentCompleted" [step]="5">
         * ```
         */
        this.thumbLabelVisibilityDuration = 750;
        /**
         * This event is emitted when user has stopped interacting the thumb and value is changed.
         * ```typescript
         * public change(event){
         *    alert("The value has been changed!");
         * }
         * ```
         * ```html
         * <igx-slider (onValueChange)="change($event)" #slider [(ngModel)]="task.percentCompleted" [step]="5">
         * ```
         */
        this.onValueChange = new EventEmitter();
    }
    /**
     * @private
     * @return {?}
     */
    get thumbFrom() {
        return this.thumbs.find(thumb => thumb.type === SliderHandle.FROM);
    }
    /**
     * @private
     * @return {?}
     */
    get thumbTo() {
        return this.thumbs.find(thumb => thumb.type === SliderHandle.TO);
    }
    /**
     * @private
     * @return {?}
     */
    get labelFrom() {
        return this.labelRefs.find(label => label.type === SliderHandle.FROM);
    }
    /**
     * @private
     * @return {?}
     */
    get labelTo() {
        return this.labelRefs.find(label => label.type === SliderHandle.TO);
    }
    /**
     * @hidden
     * @return {?}
     */
    get valuemin() {
        return this.minValue;
    }
    /**
     * @hidden
     * @return {?}
     */
    get valuemax() {
        return this.maxValue;
    }
    /**
     * @hidden
     * @return {?}
     */
    get readonly() {
        return this.disabled;
    }
    /**
     * @hidden
     * @return {?}
     */
    get disabledClass() {
        return this.disabled;
    }
    /**
     * An \@Input property that gets the type of the `IgxSliderComponent`. The slider can be SliderType.SLIDER(default) or SliderType.RANGE.
     * ```typescript
     * \@ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *     let type = this.slider.type;
     * }
     * @return {?}
     */
    get type() {
        return this._type;
    }
    /**
     * An \@Input property that sets the type of the `IgxSliderComponent`. The slider can be SliderType.SLIDER(default) or SliderType.RANGE.
     * ```typescript
     * sliderType: SliderType = SliderType.RANGE;
     * ```
     * ```html
     * <igx-slider #slider2 [type]="sliderType" [(ngModel)]="rangeValue" [minValue]="0" [maxValue]="100">
     * ```
     * @param {?} type
     * @return {?}
     */
    set type(type) {
        this._type = type;
        if (type === SliderType.SLIDER) {
            this.lowerValue = 0;
        }
        if (this.labelsViewEnabled && this.upperValue > this.maxValue) {
            this.upperValue = this.labels.length - 1;
        }
        if (this._hasViewInit) {
            this.updateTrack();
        }
    }
    /**
     * Enables `labelView`, by accepting a collection of primitive values with more than one element.
     * Each element will be equally spread over the slider and it will serve as a thumb label.
     * Once the property is set, it will precendence over {\@link maxValue}, {\@link minValue}, {\@link step}.
     * This means that the manipulation for those properties won't be allowed.
     * @return {?}
     */
    get labels() {
        return this._labels;
    }
    /**
     * @param {?} labels
     * @return {?}
     */
    set labels(labels) {
        this._labels = labels;
        this._pMax = 1;
        if (this._hasViewInit) {
            this.stepDistance = this.calculateStepDistance();
            this.positionHandlesAndUpdateTrack();
            this.setTickInterval(labels);
        }
    }
    /**
     * Returns the template context corresponding
     * to {\@link IgxThumbFromTemplateDirective} and {\@link IgxThumbToTemplateDirective} templates.
     *
     * return {
     *  $implicit: {\@link value},
     *  labels: {\@link labels}
     * }
     * ```
     * @return {?}
     */
    get context() {
        return {
            $implicit: this.value,
            labels: this.labels
        };
    }
    /**
     * An \@Input property that sets the incremental/decremental step of the value when dragging the thumb.
     * The default step is 1, and step should not be less or equal than 0.
     * ```html
     * <igx-slider #slider [(ngModel)]="task.percentCompleted" [step]="5">
     * ```
     * @param {?} step
     * @return {?}
     */
    set step(step) {
        this._step = step;
        if (this._hasViewInit) {
            this.stepDistance = this.calculateStepDistance();
            this.normalizeByStep(this.value);
            this.setTickInterval(this.labels);
        }
    }
    /**
     * Returns the incremental/decremental dragging step of the {\@link IgxSliderComponent}.
     * ```typescript
     * \@ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *     let step = this.slider.step;
     * }
     * ```
     * @return {?}
     */
    get step() {
        return this.labelsViewEnabled ? 1 : this._step;
    }
    /**
     * Returns if the {\@link IgxSliderComponent} is disabled.
     * ```typescript
     * \@ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *     let isDisabled = this.slider.disabled;
     * }
     * ```
     * @return {?}
     */
    get disabled() {
        return this._disabled;
    }
    /**
     * An \@Input property that disables or enables UI interaction.
     * ```html
     * <igx-slider #slider [disabled]="'true'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
     * ```
     * @param {?} disable
     * @return {?}
     */
    set disabled(disable) {
        this._disabled = disable;
        if (this._hasViewInit) {
            this.changeThumbFocusableState(disable);
        }
    }
    /**
     * Returns if the {\@link IgxSliderComponent} is set as continuous.
     * ```typescript
     * \@ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *     let continuous = this.slider.continuous;
     * }
     * ```
     * @return {?}
     */
    get continuous() {
        return this._continuous;
    }
    /**
     * An \@Input property that marks the {\@link IgxSliderComponent} as continuous.
     * By default is considered that the {\@link IgxSliderComponent} is discrete.
     * Discrete {\@link IgxSliderComponent} does not have ticks and does not show bubble labels for values.
     * ```html
     * <igx-slider #slider [continuous]="'true'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
     * ```
     * @param {?} continuous
     * @return {?}
     */
    set continuous(continuous) {
        this._continuous = continuous;
        this.setTickInterval(null);
    }
    /**
     * Returns if the {\@link IgxSliderComponent} is set as continuous.
     * ```typescript
     * \@ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *     let continuous = this.slider.continuous;
     * }
     * ```
     * @return {?}
     */
    get isContinuous() {
        return this.continuous;
    }
    /**
     * @hidden
     * \@internal
     * @param {?} continuous
     * @return {?}
     */
    set isContinuous(continuous) {
        this.continuous = continuous;
    }
    /**
     * Returns the maximum value for the {\@link IgxSliderComponent}.
     * ```typescript
     * \@ViewChild("slider")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *    let sliderMax = this.slider.maxValue;
     * }
     * ```
     * @return {?}
     */
    get maxValue() {
        return this.labelsViewEnabled ?
            this.labels.length - 1 :
            this._maxValue;
    }
    /**
     * Sets the maximal value for the `IgxSliderComponent`.
     * The default maximum value is 100.
     * ```html
     * <igx-slider [type]="sliderType" [minValue]="56" [maxValue]="256">
     * ```
     * @param {?} value
     * @return {?}
     */
    set maxValue(value) {
        if (value <= this._minValue) {
            this._maxValue = this._minValue + 1;
        }
        else {
            this._maxValue = value;
        }
        if (value < this.lowerBound) {
            this.updateLowerBoundAndMinTravelZone();
            this.upperBound = value;
        }
        // refresh max travel zone limits.
        this._pMax = 1;
        // recalculate step distance.
        this.stepDistance = this.calculateStepDistance();
        this.positionHandlesAndUpdateTrack();
        this.setTickInterval(null);
    }
    /**
     * Returns the minimal value of the `IgxSliderComponent`.
     * ```typescript
     * \@ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *    let sliderMin = this.slider.minValue;
     * }
     * ```
     * @return {?}
     */
    get minValue() {
        if (this.labelsViewEnabled) {
            return 0;
        }
        return this._minValue;
    }
    /**
     * Sets the minimal value for the `IgxSliderComponent`.
     * The default minimal value is 0.
     * ```html
     * <igx-slider [type]="sliderType" [minValue]="56" [maxValue]="100">
     * ```
     * @param {?} value
     * @return {?}
     */
    set minValue(value) {
        if (value >= this.maxValue) {
            this._minValue = this.maxValue - 1;
        }
        else {
            this._minValue = value;
        }
        if (value > this.upperBound) {
            this.updateUpperBoundAndMaxTravelZone();
            this.lowerBound = value;
        }
        // Refresh min travel zone limit.
        this._pMin = 0;
        // Recalculate step distance.
        this.stepDistance = this.calculateStepDistance();
        this.positionHandlesAndUpdateTrack();
        this.setTickInterval(null);
    }
    /**
     * Returns the lower boundary of the `IgxSliderComponent`.
     * ```typescript
     * \@ViewChild("slider")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *    let sliderLowBound = this.slider.lowerBound;
     * }
     * ```
     * @return {?}
     */
    get lowerBound() {
        if (!Number.isNaN(this._lowerBound) && this._lowerBound !== undefined) {
            return this.valueInRange(this._lowerBound, this.minValue, this.maxValue);
        }
        return this.minValue;
    }
    /**
     * Sets the lower boundary of the `IgxSliderComponent`.
     * If not set is the same as min value.
     * ```html
     * <igx-slider [step]="5" [lowerBound]="20">
     * ```
     * @param {?} value
     * @return {?}
     */
    set lowerBound(value) {
        if (value >= this.upperBound || (this.labelsViewEnabled && value < 0)) {
            return;
        }
        this._lowerBound = this.valueInRange(value, this.minValue, this.maxValue);
        // Refresh time travel zone.
        this._pMin = this.valueToFraction(this._lowerBound) || 0;
        this.positionHandlesAndUpdateTrack();
    }
    /**
     * Returns the upper boundary of the `IgxSliderComponent`.
     * ```typescript
     * \@ViewChild("slider")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *    let sliderUpBound = this.slider.upperBound;
     * }
     * ```
     * @return {?}
     */
    get upperBound() {
        if (!Number.isNaN(this._upperBound) && this._upperBound !== undefined) {
            return this.valueInRange(this._upperBound, this.minValue, this.maxValue);
        }
        return this.maxValue;
    }
    /**
     * Sets the upper boundary of the `IgxSliderComponent`.
     * If not set is the same as max value.
     * ```html
     * <igx-slider [step]="5" [upperBound]="20">
     * ```
     * @param {?} value
     * @return {?}
     */
    set upperBound(value) {
        if (value <= this.lowerBound || (this.labelsViewEnabled && value > this.labels.length - 1)) {
            return;
        }
        this._upperBound = this.valueInRange(value, this.minValue, this.maxValue);
        // Refresh time travel zone.
        this._pMax = this.valueToFraction(this._upperBound) || 1;
        this.positionHandlesAndUpdateTrack();
    }
    /**
     * Returns the slider value. If the slider is of type {\@link SliderType.SLIDER} the returned value is number.
     * If the slider type is {\@link SliderType.RANGE} the returned value represents an object of {\@link lowerValue} and {\@link upperValue}.
     * ```typescript
     * \@ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * public sliderValue(event){
     *    let sliderVal = this.slider.value;
     * }
     * ```
     * @return {?}
     */
    get value() {
        if (this.isRange) {
            return {
                lower: this.valueInRange(this.lowerValue, this.lowerBound, this.upperBound),
                upper: this.valueInRange(this.upperValue, this.lowerBound, this.upperBound)
            };
        }
        else {
            return this.valueInRange(this.upperValue, this.lowerBound, this.upperBound);
        }
    }
    /**
     * Sets the slider value.
     * If the slider is of type {\@link SliderType.SLIDER} the argument is number. By default the {\@link value} gets the {\@link lowerBound}.
     * If the slider type is {\@link SliderType.RANGE} the argument
     * represents an object of {\@link lowerValue} and {\@link upperValue} properties.
     * By default the object is associated with the {\@link lowerBound} and {\@link upperBound} property values.
     * ```typescript
     * rangeValue = {
     *   lower: 30,
     *   upper: 60
     * };
     * ```
     * ```html
     * <igx-slider [type]="sliderType" [(ngModel)]="rangeValue" [minValue]="56" [maxValue]="256">
     * ```
     * @param {?} value
     * @return {?}
     */
    set value(value) {
        if (!this.isRange) {
            this.upperValue = (/** @type {?} */ (value));
        }
        else {
            value = this.validateInitialValue((/** @type {?} */ (value)));
            this.upperValue = ((/** @type {?} */ (value))).upper;
            this.lowerValue = ((/** @type {?} */ (value))).lower;
        }
        this._onChangeCallback(this.value);
        if (this._hasViewInit) {
            this.positionHandlesAndUpdateTrack();
        }
    }
    /**
     * @hidden
     * @param {?} $event
     * @return {?}
     */
    onPointerDown($event) {
        this.findClosestThumb($event);
        if (!this.thumbTo.isActive && this.thumbFrom === undefined) {
            return;
        }
        /** @type {?} */
        const activeThumb = this.thumbTo.isActive ? this.thumbTo : this.thumbFrom;
        activeThumb.nativeElement.setPointerCapture($event.pointerId);
        this.showSliderIndicators();
        $event.preventDefault();
    }
    /**
     * @hidden
     * @param {?} $event
     * @return {?}
     */
    onPointerUp($event) {
        if (!this.thumbTo.isActive && this.thumbFrom === undefined) {
            return;
        }
        /** @type {?} */
        const activeThumb = this.thumbTo.isActive ? this.thumbTo : this.thumbTo;
        activeThumb.nativeElement.releasePointerCapture($event.pointerId);
        this.hideSliderIndicators();
    }
    /**
     * @hidden
     * @return {?}
     */
    onFocus() {
        this.toggleSliderIndicators();
    }
    /**
     * @hidden
     * @param {?} $event
     * @return {?}
     */
    onPanListener($event) {
        this.update($event.srcEvent.clientX);
    }
    /**
     * @return {?}
     */
    onPanStart() {
        this.showSliderIndicators();
    }
    /**
     * @return {?}
     */
    onPanEnd() {
        this.hideSliderIndicators();
    }
    /**
     * Returns whether the `IgxSliderComponent` type is RANGE.
     * ```typescript
     * \@ViewChild("slider")
     * public slider: IgxSliderComponent;
     * ngAfterViewInit(){
     *    let sliderRange = this.slider.isRange;
     * }
     * ```
     * @return {?}
     */
    get isRange() {
        return this.type === SliderType.RANGE;
    }
    /**
     * Returns the lower value of the `IgxSliderComponent`.
     * ```typescript
     * \@ViewChild("slider")
     * public slider: IgxSliderComponent;
     * public lowValue(event){
     *    let sliderLowValue = this.slider.lowerValue;
     * }
     * ```
     * @return {?}
     */
    get lowerValue() {
        if (!Number.isNaN(this._lowerValue) && this._lowerValue !== undefined && this._lowerValue >= this.lowerBound) {
            return this._lowerValue;
        }
        return this.lowerBound;
    }
    /**
     * Sets the lower value of the `IgxSliderComponent`.
     * ```typescript
     * \@ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * public lowValue(event){
     *    this.slider.lowerValue = 120;
     * }
     * ```
     * @param {?} value
     * @return {?}
     */
    set lowerValue(value) {
        value = this.valueInRange(value, this.lowerBound, this.upperBound);
        this._lowerValue = value;
    }
    /**
     * Returns the upper value of the `IgxSliderComponent`.
     * ```typescript
     * \@ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * public upperValue(event){
     *    let upperValue = this.slider.upperValue;
     * }
     * ```
     * @return {?}
     */
    get upperValue() {
        if (!Number.isNaN(this._upperValue) && this._upperValue !== undefined && this._upperValue <= this.upperBound) {
            return this._upperValue;
        }
        return this.upperBound;
    }
    /**
     * Sets the upper value of the `IgxSliderComponent`.
     * ```typescript
     * \@ViewChild("slider2")
     * public slider: IgxSliderComponent;
     * public upperValue(event){
     *    this.slider.upperValue = 120;
     * }
     * ```
     * @param {?} value
     * @return {?}
     */
    set upperValue(value) {
        value = this.valueInRange(value, this.lowerBound, this.upperBound);
        this._upperValue = value;
    }
    /**
     * Returns the value corresponding the lower label.
     * ```typescript
     * \@ViewChild("slider")
     * public slider: IgxSliderComponent;
     * let label = this.slider.lowerLabel;
     * ```
     * @return {?}
     */
    get lowerLabel() {
        return this.labelsViewEnabled ?
            this.labels[this.lowerValue] :
            this.lowerValue;
    }
    /**
     * Returns the value corresponding the upper label.
     * ```typescript
     * \@ViewChild("slider")
     * public slider: IgxSliderComponent;
     * let label = this.slider.upperLabel;
     * ```
     * @return {?}
     */
    get upperLabel() {
        return this.labelsViewEnabled ?
            this.labels[this.upperValue] :
            this.upperValue;
    }
    /**
     * Returns if label view is enabled.
     * If the {\@link labels} is set, the view is automatically activated.
     * ```typescript
     * \@ViewChild("slider")
     * public slider: IgxSliderComponent;
     * let labelView = this.slider.labelsViewEnabled;
     * ```
     * @return {?}
     */
    get labelsViewEnabled() {
        return !!(this.labels && this.labels.length > 1);
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        this.sliderSetup();
        // Set track travel zone
        this._pMin = this.valueToFraction(this.lowerBound) || 0;
        this._pMax = this.valueToFraction(this.upperBound) || 1;
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterViewInit() {
        this._hasViewInit = true;
        this.positionHandlesAndUpdateTrack();
        this.setTickInterval(this.labels);
        this.changeThumbFocusableState(this.disabled);
        this.subscribeTo(this.thumbFrom, this.thumbChanged.bind(this));
        this.subscribeTo(this.thumbTo, this.thumbChanged.bind(this));
        this.thumbs.changes.pipe(takeUntil(this._destroyer$)).subscribe(change => {
            /** @type {?} */
            const thumbFrom = change.find((thumb) => thumb.type === SliderHandle.FROM);
            /** @type {?} */
            const labelFrom = this.labelRefs.find((label) => label.type === SliderHandle.FROM);
            this.positionHandle(thumbFrom, labelFrom, this.lowerValue);
            this.subscribeTo(thumbFrom, this.thumbChanged.bind(this));
            this.changeThumbFocusableState(this.disabled);
        });
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterContentChecked() {
        // Calculates the distance between every step in pixels.
        this.stepDistance = this.calculateStepDistance();
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnDestroy() {
        this._destroyer$.next(true);
        this._destroyer$.complete();
        this._indicatorsDestroyer$.next(true);
        this._indicatorsDestroyer$.complete();
    }
    /**
     * @hidden
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        if (!value) {
            return;
        }
        this.normalizeByStep(value);
    }
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    registerOnChange(fn) {
        this._onChangeCallback = fn;
    }
    /**
     * @hidden
     * @param {?} fn
     * @return {?}
     */
    registerOnTouched(fn) {
        this._onTouchedCallback = fn;
    }
    /**
     * @hidden
     * @return {?}
     */
    getEditElement() {
        return this.isRange ? this.thumbFrom.nativeElement : this.thumbTo.nativeElement;
    }
    /**
     *
     * @hidden
     * @param {?} mouseX
     * @return {?}
     */
    update(mouseX) {
        if (this.disabled) {
            return;
        }
        // Update To/From Values
        this.onPan.next(mouseX);
        // Finally do positionHandlesAndUpdateTrack the DOM
        // based on data values
        this.positionHandlesAndUpdateTrack();
        this._onTouchedCallback();
    }
    /**
     * @hidden
     * @param {?} value
     * @param {?} thumbType
     * @return {?}
     */
    thumbChanged(value, thumbType) {
        /** @type {?} */
        const oldValue = this.value;
        /** @type {?} */
        let newVal;
        if (this.isRange) {
            if (thumbType === SliderHandle.FROM) {
                newVal = {
                    lower: ((/** @type {?} */ (this.value))).lower + value,
                    upper: ((/** @type {?} */ (this.value))).upper
                };
            }
            else {
                newVal = {
                    lower: ((/** @type {?} */ (this.value))).lower,
                    upper: ((/** @type {?} */ (this.value))).upper + value
                };
            }
            // Swap the thumbs if a collision appears.
            if (newVal.lower >= newVal.upper) {
                this.value = this.swapThumb(newVal);
            }
            else {
                this.value = newVal;
            }
        }
        else {
            this.value = (/** @type {?} */ (this.value)) + value;
        }
        if (this.hasValueChanged(oldValue)) {
            this.emitValueChanged(oldValue);
        }
    }
    /**
     * @hidden
     * @return {?}
     */
    onThumbChange() {
        this.toggleSliderIndicators();
    }
    /**
     * @param {?} state
     * @return {?}
     */
    onHoverChange(state) {
        return state ? this.showSliderIndicators() : this.hideSliderIndicators();
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    swapThumb(value) {
        if (this.thumbFrom.isActive) {
            value.upper = this.upperValue;
            value.lower = this.upperValue;
        }
        else {
            value.upper = this.lowerValue;
            value.lower = this.lowerValue;
        }
        this.toggleThumb();
        return value;
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    findClosestThumb(event) {
        if (this.isRange) {
            this.closestHandle(event);
        }
        else {
            this.thumbTo.nativeElement.focus();
        }
        this.update(event.clientX);
    }
    /**
     * @private
     * @return {?}
     */
    updateLowerBoundAndMinTravelZone() {
        this.lowerBound = this.minValue;
        this._pMin = 0;
    }
    /**
     * @private
     * @return {?}
     */
    updateUpperBoundAndMaxTravelZone() {
        this.upperBound = this.maxValue;
        this._pMax = 1;
    }
    /**
     * @private
     * @return {?}
     */
    sliderSetup() {
        /**
         * if {@link SliderType.SLIDER} than the initial value shold be the lowest one.
         */
        if (!this.isRange && this.value === this.upperBound) {
            this.value = this.lowerBound;
        }
    }
    /**
     * @private
     * @return {?}
     */
    calculateStepDistance() {
        return this._el.nativeElement.getBoundingClientRect().width / (this.maxValue - this.minValue) * this.step;
    }
    /**
     * @private
     * @return {?}
     */
    toggleThumb() {
        return this.thumbFrom.isActive ?
            this.thumbTo.nativeElement.focus() :
            this.thumbFrom.nativeElement.focus();
    }
    /**
     * @private
     * @param {?} value
     * @param {?=} min
     * @param {?=} max
     * @return {?}
     */
    valueInRange(value, min = 0, max = 100) {
        return Math.max(Math.min(value, max), min);
    }
    /**
     * @private
     * @param {?} color
     * @param {?} interval
     * @return {?}
     */
    generateTickMarks(color, interval) {
        return interval !== null ? `repeating-linear-gradient(
            ${'to left'},
            ${color},
            ${color} 1.5px,
            transparent 1.5px,
            transparent ${interval}%
        ), repeating-linear-gradient(
            ${'to right'},
            ${color},
            ${color} 1.5px,
            transparent 1.5px,
            transparent ${interval}%
        )` : interval;
    }
    /**
     * @private
     * @param {?} thumbHandle
     * @param {?} labelHandle
     * @param {?} position
     * @return {?}
     */
    positionHandle(thumbHandle, labelHandle, position) {
        /** @type {?} */
        const positionLeft = `${this.valueToFraction(position) * 100}%`;
        if (thumbHandle) {
            thumbHandle.nativeElement.style.left = positionLeft;
        }
        if (labelHandle) {
            labelHandle.nativeElement.style.left = positionLeft;
        }
    }
    /**
     * @private
     * @return {?}
     */
    positionHandlesAndUpdateTrack() {
        if (!this.isRange) {
            this.positionHandle(this.thumbTo, this.labelTo, (/** @type {?} */ (this.value)));
        }
        else {
            this.positionHandle(this.thumbTo, this.labelTo, ((/** @type {?} */ (this.value))).upper);
            this.positionHandle(this.thumbFrom, this.labelFrom, ((/** @type {?} */ (this.value))).lower);
        }
        this.updateTrack();
    }
    /**
     * @private
     * @param {?} event
     * @return {?}
     */
    closestHandle(event) {
        /** @type {?} */
        const fromOffset = this.thumbFrom.nativeElement.offsetLeft + this.thumbFrom.nativeElement.offsetWidth / 2;
        /** @type {?} */
        const toOffset = this.thumbTo.nativeElement.offsetLeft + this.thumbTo.nativeElement.offsetWidth / 2;
        /** @type {?} */
        const xPointer = event.clientX - this._el.nativeElement.getBoundingClientRect().left;
        /** @type {?} */
        const match = this.closestTo(xPointer, [fromOffset, toOffset]);
        if (fromOffset === toOffset && toOffset < xPointer) {
            this.thumbTo.nativeElement.focus();
        }
        else if (fromOffset === toOffset && toOffset > xPointer) {
            this.thumbFrom.nativeElement.focus();
        }
        else if (match === fromOffset) {
            this.thumbFrom.nativeElement.focus();
        }
        else {
            this.thumbTo.nativeElement.focus();
        }
    }
    /**
     * @private
     * @param {?} labels
     * @return {?}
     */
    setTickInterval(labels) {
        /** @type {?} */
        let interval;
        /** @type {?} */
        const trackProgress = 100;
        if (this.labelsViewEnabled) {
            // Calc ticks depending on the labels length;
            interval = ((trackProgress / (this.labels.length - 1) * 10)) / 10;
        }
        else {
            /** @type {?} */
            const trackRange = this.maxValue - this.minValue;
            interval = this.step > 1 ?
                (trackProgress / ((trackRange / this.step)) * 10) / 10
                : null;
        }
        /** @type {?} */
        const renderCallbackExecution = !this.continuous ? this.generateTickMarks('white', interval) : null;
        this.renderer.setStyle(this.ticks.nativeElement, 'background', renderCallbackExecution);
    }
    /**
     * @private
     * @return {?}
     */
    showSliderIndicators() {
        if (this.disabled) {
            return;
        }
        if (this._indicatorsTimer) {
            this._indicatorsDestroyer$.next(true);
            this._indicatorsTimer = null;
        }
        this.thumbTo.showThumbIndicators();
        this.labelTo.active = true;
        if (this.thumbFrom) {
            this.thumbFrom.showThumbIndicators();
        }
        if (this.labelFrom) {
            this.labelFrom.active = true;
        }
    }
    /**
     * @private
     * @return {?}
     */
    hideSliderIndicators() {
        if (this.disabled) {
            return;
        }
        this._indicatorsTimer = timer(this.thumbLabelVisibilityDuration);
        this._indicatorsTimer.pipe(takeUntil(this._indicatorsDestroyer$)).subscribe(() => {
            this.thumbTo.hideThumbIndicators();
            this.labelTo.active = false;
            if (this.thumbFrom) {
                this.thumbFrom.hideThumbIndicators();
            }
            if (this.labelFrom) {
                this.labelFrom.active = false;
            }
        });
    }
    /**
     * @private
     * @return {?}
     */
    toggleSliderIndicators() {
        this.showSliderIndicators();
        this.hideSliderIndicators();
    }
    /**
     * @private
     * @param {?} state
     * @return {?}
     */
    changeThumbFocusableState(state) {
        /** @type {?} */
        const value = state ? -1 : 1;
        if (this.isRange) {
            this.thumbFrom.tabindex = value;
        }
        this.thumbTo.tabindex = value;
        this._cdr.detectChanges();
    }
    /**
     * @private
     * @param {?} goal
     * @param {?} positions
     * @return {?}
     */
    closestTo(goal, positions) {
        return positions.reduce((previous, current) => {
            return (Math.abs(goal - current) < Math.abs(goal - previous) ? current : previous);
        });
    }
    /**
     * @private
     * @param {?} value
     * @param {?=} pMin
     * @param {?=} pMax
     * @return {?}
     */
    valueToFraction(value, pMin = this._pMin, pMax = this._pMax) {
        return this.valueInRange((value - this.minValue) / (this.maxValue - this.minValue), pMin, pMax);
    }
    /**
     * @hidden
     * Normalizе the value when two-way data bind is used and {\@link this.step} is set.
     * @private
     * @param {?} value
     * @return {?}
     */
    normalizeByStep(value) {
        if (this.isRange) {
            this.value = {
                lower: ((/** @type {?} */ (value))).lower - (((/** @type {?} */ (value))).lower % this.step),
                upper: ((/** @type {?} */ (value))).upper - (((/** @type {?} */ (value))).upper % this.step)
            };
        }
        else {
            this.value = ((/** @type {?} */ (value))) - (((/** @type {?} */ (value))) % this.step);
        }
    }
    /**
     * @private
     * @return {?}
     */
    updateTrack() {
        /** @type {?} */
        const fromPosition = this.valueToFraction(this.lowerValue);
        /** @type {?} */
        const toPosition = this.valueToFraction(this.upperValue);
        /** @type {?} */
        const positionGap = toPosition - fromPosition;
        /** @type {?} */
        let trackLeftIndention = fromPosition;
        if (this.isRange) {
            if (positionGap) {
                trackLeftIndention = Math.round((1 / positionGap * fromPosition) * 100);
            }
            this.renderer.setStyle(this.track.nativeElement, 'transform', `scaleX(${positionGap}) translateX(${trackLeftIndention}%)`);
        }
        else {
            this.renderer.setStyle(this.track.nativeElement, 'transform', `scaleX(${toPosition})`);
        }
    }
    /**
     * @private
     * @param {?} value
     * @return {?}
     */
    validateInitialValue(value) {
        if (value.lower < this.lowerBound && value.upper < this.lowerBound) {
            value.upper = this.lowerBound;
            value.lower = this.lowerBound;
        }
        if (value.lower > this.upperBound && value.upper > this.upperBound) {
            value.upper = this.upperBound;
            value.lower = this.upperBound;
        }
        if (value.upper < value.lower) {
            value.upper = this.upperValue;
            value.lower = this.lowerValue;
        }
        return value;
    }
    /**
     * @private
     * @param {?} thumb
     * @param {?} callback
     * @return {?}
     */
    subscribeTo(thumb, callback) {
        if (!thumb) {
            return;
        }
        thumb.onThumbValueChange
            .pipe(takeUntil(this.unsubscriber(thumb)))
            .subscribe(value => callback(value, thumb.type));
    }
    /**
     * @private
     * @param {?} thumb
     * @return {?}
     */
    unsubscriber(thumb) {
        return merge(this._destroyer$, thumb.destroy);
    }
    /**
     * @private
     * @param {?} oldValue
     * @return {?}
     */
    hasValueChanged(oldValue) {
        /** @type {?} */
        const isSliderWithDifferentValue = !this.isRange && oldValue !== this.value;
        /** @type {?} */
        const isRangeWithOneDifferentValue = this.isRange &&
            (((/** @type {?} */ (oldValue))).lower !== ((/** @type {?} */ (this.value))).lower ||
                ((/** @type {?} */ (oldValue))).upper !== ((/** @type {?} */ (this.value))).upper);
        return isSliderWithDifferentValue || isRangeWithOneDifferentValue;
    }
    /**
     * @private
     * @param {?} oldValue
     * @return {?}
     */
    emitValueChanged(oldValue) {
        this.onValueChange.emit({ oldValue, value: this.value });
    }
}
IgxSliderComponent.decorators = [
    { type: Component, args: [{
                providers: [{ provide: NG_VALUE_ACCESSOR, useExisting: IgxSliderComponent, multi: true }],
                selector: 'igx-slider',
                template: "<div class=\"igx-slider__track\">\n    <div #track class=\"igx-slider__track-fill\"></div>\n    <div #ticks class=\"igx-slider__track-ticks\"></div>\n</div>\n<div class=\"igx-slider__thumbs\">\n    <igx-thumb-label\n        *ngIf=\"isRange\"\n        [type]=\"0\"\n        [value]=\"lowerLabel\"\n        [templateRef]=\"thumbFromTemplateRef\"\n        [continuous]=\"continuous\"\n        [context]=\"context\"></igx-thumb-label>\n\n    <igx-thumb *ngIf=\"isRange\"\n        #thumbFrom\n        [type]=\"0\"\n        [value]=\"lowerLabel\"\n        [disabled]=\"disabled\"\n        [continuous]=\"continuous\"\n        [onPan]=\"onPan\"\n        [stepDistance]=\"stepDistance\"\n        [step]=\"step\"\n        [templateRef]=\"thumbFromTemplateRef\"\n        [context]=\"context\"\n        (onChange)=\"onThumbChange()\"\n        (onHoverChange)=\"onHoverChange($event)\"\n        [thumbLabelVisibilityDuration]=\"thumbLabelVisibilityDuration\"></igx-thumb>\n\n    <igx-thumb-label\n        [value]=\"upperLabel\"\n        [type]=\"1\"\n        [templateRef]=\"thumbToTemplateRef\"\n        [continuous]=\"continuous\"\n        [context]=\"context\"></igx-thumb-label>\n\n    <igx-thumb\n        #thumbTo\n        [type]=\"1\"\n        [value]=\"upperLabel\"\n        [disabled]=\"disabled\"\n        [continuous]=\"continuous\"\n        [onPan]=\"onPan\"\n        [stepDistance]=\"stepDistance\"\n        [step]=\"step\"\n        [templateRef]=\"thumbToTemplateRef\"\n        [context]=\"context\"\n        (onChange)=\"onThumbChange()\"\n        (onHoverChange)=\"onHoverChange($event)\"\n        [thumbLabelVisibilityDuration]=\"thumbLabelVisibilityDuration\"></igx-thumb>\n</div>\n"
            }] }
];
/** @nocollapse */
IgxSliderComponent.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
IgxSliderComponent.propDecorators = {
    track: [{ type: ViewChild, args: ['track', { static: true },] }],
    ticks: [{ type: ViewChild, args: ['ticks', { static: true },] }],
    thumbs: [{ type: ViewChildren, args: [IgxSliderThumbComponent,] }],
    labelRefs: [{ type: ViewChildren, args: [IgxThumbLabelComponent,] }],
    thumbFromTemplateRef: [{ type: ContentChild, args: [IgxThumbFromTemplateDirective, { read: TemplateRef, static: false },] }],
    thumbToTemplateRef: [{ type: ContentChild, args: [IgxThumbToTemplateDirective, { read: TemplateRef, static: false },] }],
    role: [{ type: HostBinding, args: [`attr.role`,] }],
    valuemin: [{ type: HostBinding, args: [`attr.aria-valuemin`,] }],
    valuemax: [{ type: HostBinding, args: [`attr.aria-valuemax`,] }],
    readonly: [{ type: HostBinding, args: [`attr.aria-readonly`,] }],
    slierClass: [{ type: HostBinding, args: ['class.igx-slider',] }],
    disabledClass: [{ type: HostBinding, args: ['class.igx-slider--disabled',] }],
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    type: [{ type: Input }],
    thumbLabelVisibilityDuration: [{ type: Input }],
    labels: [{ type: Input }],
    step: [{ type: Input }],
    disabled: [{ type: Input }],
    continuous: [{ type: Input }],
    isContinuous: [{ type: Input }],
    maxValue: [{ type: Input }],
    minValue: [{ type: Input }],
    lowerBound: [{ type: Input }],
    upperBound: [{ type: Input }],
    value: [{ type: Input }],
    onValueChange: [{ type: Output }],
    onPointerDown: [{ type: HostListener, args: ['pointerdown', ['$event'],] }],
    onPointerUp: [{ type: HostListener, args: ['pointerup', ['$event'],] }],
    onFocus: [{ type: HostListener, args: ['focus',] }],
    onPanListener: [{ type: HostListener, args: ['pan', ['$event'],] }],
    onPanStart: [{ type: HostListener, args: ['panstart',] }],
    onPanEnd: [{ type: HostListener, args: ['panend',] }]
};
tslib_1.__decorate([
    DeprecateProperty(`IgxSliderComponent \`isContinuous\` property is deprecated.\nUse \`continuous\` instead.`),
    tslib_1.__metadata("design:type", Boolean),
    tslib_1.__metadata("design:paramtypes", [Boolean])
], IgxSliderComponent.prototype, "isContinuous", null);
if (false) {
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._pMin;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._pMax;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._hasViewInit;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._minValue;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._maxValue;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._lowerBound;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._upperBound;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._lowerValue;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._upperValue;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._continuous;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._disabled;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._step;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._labels;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._type;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._destroyer$;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._indicatorsDestroyer$;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._indicatorsTimer;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._onChangeCallback;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._onTouchedCallback;
    /**
     * @hidden
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype.track;
    /**
     * @hidden
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype.ticks;
    /**
     * @hidden
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype.thumbs;
    /**
     * @hidden
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype.labelRefs;
    /**
     * @hidden
     * @type {?}
     */
    IgxSliderComponent.prototype.stepDistance;
    /**
     * @hidden
     * @type {?}
     */
    IgxSliderComponent.prototype.onPan;
    /**
     * @hidden
     * @type {?}
     */
    IgxSliderComponent.prototype.thumbFromTemplateRef;
    /**
     * @hidden
     * @type {?}
     */
    IgxSliderComponent.prototype.thumbToTemplateRef;
    /**
     * @hidden
     * @type {?}
     */
    IgxSliderComponent.prototype.role;
    /**
     * @hidden
     * @type {?}
     */
    IgxSliderComponent.prototype.slierClass;
    /**
     * An \@Input property that sets the value of the `id` attribute.
     * If not provided it will be automatically generated.
     * ```html
     * <igx-slider [id]="'igx-slider-32'" [(ngModel)]="task.percentCompleted" [step]="5" [lowerBound]="20">
     * ```
     * @type {?}
     */
    IgxSliderComponent.prototype.id;
    /**
     * An \@Input property that sets the duration visibility of thumbs labels. The default value is 750 milliseconds.
     * ```html
     * <igx-slider #slider [thumbLabelVisibilityDuration]="3000" [(ngModel)]="task.percentCompleted" [step]="5">
     * ```
     * @type {?}
     */
    IgxSliderComponent.prototype.thumbLabelVisibilityDuration;
    /**
     * This event is emitted when user has stopped interacting the thumb and value is changed.
     * ```typescript
     * public change(event){
     *    alert("The value has been changed!");
     * }
     * ```
     * ```html
     * <igx-slider (onValueChange)="change($event)" #slider [(ngModel)]="task.percentCompleted" [step]="5">
     * ```
     * @type {?}
     */
    IgxSliderComponent.prototype.onValueChange;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype.renderer;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._el;
    /**
     * @type {?}
     * @private
     */
    IgxSliderComponent.prototype._cdr;
}
/**
 * @hidden
 */
export class IgxSliderModule {
}
IgxSliderModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    IgxSliderComponent,
                    IgxThumbFromTemplateDirective,
                    IgxThumbToTemplateDirective,
                    IgxSliderThumbComponent,
                    IgxThumbLabelComponent
                ],
                exports: [
                    IgxSliderComponent,
                    IgxThumbFromTemplateDirective,
                    IgxThumbToTemplateDirective,
                    IgxSliderThumbComponent,
                    IgxThumbLabelComponent
                ],
                imports: [CommonModule]
            },] }
];
export { ɵ0 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2xpZGVyLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvc2xpZGVyL3NsaWRlci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0saUJBQWlCLENBQUM7QUFDL0MsT0FBTyxFQUNZLFNBQVMsRUFBRSxVQUFVLEVBQUUsWUFBWSxFQUNsRCxXQUFXLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBVSxNQUFNLEVBQUUsU0FBUyxFQUN2RCxTQUFTLEVBQ1QsV0FBVyxFQUNYLFlBQVksRUFFWixZQUFZLEVBQ1osWUFBWSxFQUNaLFNBQVMsRUFDVCxpQkFBaUIsRUFFcEIsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUF3QixpQkFBaUIsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRXpFLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBQ2hFLE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxNQUFNLGdDQUFnQyxDQUFDO0FBQ3pFLE9BQU8sRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFjLEtBQUssRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUN6RCxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDM0MsT0FBTyxFQUFFLFlBQVksRUFDakIsNkJBQTZCLEVBQzdCLDJCQUEyQixFQUUzQixVQUFVLEVBRWIsTUFBTSxpQkFBaUIsQ0FBQztBQUN6QixPQUFPLEVBQUUsc0JBQXNCLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQzs7TUFHakUsSUFBSSxHQUFHLEdBQUcsRUFBRTtBQUNsQixDQUFDOzs7SUFFRyxPQUFPLEdBQUcsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7OztBQXNCZixNQUFNLE9BQU8sa0JBQWtCOzs7Ozs7SUE2a0IzQixZQUFvQixRQUFtQixFQUFVLEdBQWUsRUFBVSxJQUF1QjtRQUE3RSxhQUFR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O2dCQUMzQixPQUFPLEVBQUU7b0JBQ0wsa0JBQWtCO29CQUNsQiw2QkFBNkI7b0JBQzdCLDJCQUEyQjtvQkFDM0IsdUJBQXVCO29CQUN2QixzQkFBc0I7aUJBQUM7Z0JBQzNCLE9BQU8sRUFBRSxDQUFDLFlBQVksQ0FBQzthQUMxQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbW1vbk1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XG5pbXBvcnQge1xuICAgIEFmdGVyVmlld0luaXQsIENvbXBvbmVudCwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLFxuICAgIEhvc3RCaW5kaW5nLCBJbnB1dCwgTmdNb2R1bGUsIE9uSW5pdCwgT3V0cHV0LCBSZW5kZXJlcjIsXG4gICAgVmlld0NoaWxkLFxuICAgIFRlbXBsYXRlUmVmLFxuICAgIENvbnRlbnRDaGlsZCxcbiAgICBPbkRlc3Ryb3ksXG4gICAgSG9zdExpc3RlbmVyLFxuICAgIFZpZXdDaGlsZHJlbixcbiAgICBRdWVyeUxpc3QsXG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgQWZ0ZXJDb250ZW50Q2hlY2tlZFxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IEVkaXRvclByb3ZpZGVyIH0gZnJvbSAnLi4vY29yZS9lZGl0LXByb3ZpZGVyJztcbmltcG9ydCB7IERlcHJlY2F0ZVByb3BlcnR5IH0gZnJvbSAnLi4vY29yZS9kZXByZWNhdGVEZWNvcmF0b3JzJztcbmltcG9ydCB7IElneFNsaWRlclRodW1iQ29tcG9uZW50IH0gZnJvbSAnLi90aHVtYi90aHVtYi1zbGlkZXIuY29tcG9uZW50JztcbmltcG9ydCB7IFN1YmplY3QsIG1lcmdlLCBPYnNlcnZhYmxlLCB0aW1lciB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgU2xpZGVySGFuZGxlLFxuICAgIElneFRodW1iRnJvbVRlbXBsYXRlRGlyZWN0aXZlLFxuICAgIElneFRodW1iVG9UZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBJUmFuZ2VTbGlkZXJWYWx1ZSxcbiAgICBTbGlkZXJUeXBlLFxuICAgIElTbGlkZXJWYWx1ZUNoYW5nZUV2ZW50QXJnc1xufSBmcm9tICcuL3NsaWRlci5jb21tb24nO1xuaW1wb3J0IHsgSWd4VGh1bWJMYWJlbENvbXBvbmVudCB9IGZyb20gJy4vbGFiZWwvdGh1bWItbGFiZWwuY29tcG9uZW50JztcblxuXG5jb25zdCBub29wID0gKCkgPT4ge1xufTtcblxubGV0IE5FWFRfSUQgPSAwO1xuXG4vKipcbiAqICoqSWduaXRlIFVJIGZvciBBbmd1bGFyIFNsaWRlcioqIC1cbiAqIFtEb2N1bWVudGF0aW9uXShodHRwczovL3d3dy5pbmZyYWdpc3RpY3MuY29tL3Byb2R1Y3RzL2lnbml0ZS11aS1hbmd1bGFyL2FuZ3VsYXIvY29tcG9uZW50cy9zbGlkZXIuaHRtbClcbiAqXG4gKiBUaGUgSWduaXRlIFVJIFNsaWRlciBhbGxvd3Mgc2VsZWN0aW9uIGluIGEgZ2l2ZW4gcmFuZ2UgYnkgbW92aW5nIHRoZSB0aHVtYiBhbG9uZyB0aGUgdHJhY2suIFRoZSB0cmFja1xuICogY2FuIGJlIGRlZmluZWQgYXMgY29udGludW91cyBvciBzdGVwcGVkLCBhbmQgeW91IGNhbiBjaG9vc2UgYmV0d2VlbiBzaW5nbGUgYW5kIHJhbmdlIHNsaWRlciB0eXBlcy5cbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgaHRtbFxuICogPGlneC1zbGlkZXIgaWQ9XCJzbGlkZXJcIlxuICogICAgICAgICAgICBbbWluVmFsdWVdPVwiMFwiIFttYXhWYWx1ZV09XCIxMDBcIlxuICogICAgICAgICAgICBbY29udGludW91c109dHJ1ZSBbKG5nTW9kZWwpXT1cInZvbHVtZVwiPlxuICogPC9pZ3gtc2xpZGVyPlxuICogYGBgXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHByb3ZpZGVyczogW3sgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsIHVzZUV4aXN0aW5nOiBJZ3hTbGlkZXJDb21wb25lbnQsIG11bHRpOiB0cnVlIH1dLFxuICAgIHNlbGVjdG9yOiAnaWd4LXNsaWRlcicsXG4gICAgdGVtcGxhdGVVcmw6ICdzbGlkZXIuY29tcG9uZW50Lmh0bWwnXG59KVxuZXhwb3J0IGNsYXNzIElneFNsaWRlckNvbXBvbmVudCBpbXBsZW1lbnRzXG4gICAgQ29udHJvbFZhbHVlQWNjZXNzb3IsXG4gICAgRWRpdG9yUHJvdmlkZXIsXG4gICAgT25Jbml0LFxuICAgIEFmdGVyVmlld0luaXQsXG4gICAgQWZ0ZXJDb250ZW50Q2hlY2tlZCxcbiAgICBPbkRlc3Ryb3kge1xuXG4gICAgLy8gTGltaXQgaGFuZGxlIHRyYXZlbCB6b25lXG4gICAgcHJpdmF0ZSBfcE1pbiA9IDA7XG4gICAgcHJpdmF0ZSBfcE1heCA9IDE7XG5cbiAgICAvLyBGcm9tL3VwcGVyVmFsdWUgaW4gcGVyY2VudCB2YWx1ZXNcbiAgICBwcml2YXRlIF9oYXNWaWV3SW5pdCA9IGZhbHNlO1xuICAgIHByaXZhdGUgX21pblZhbHVlID0gMDtcbiAgICBwcml2YXRlIF9tYXhWYWx1ZSA9IDEwMDtcbiAgICBwcml2YXRlIF9sb3dlckJvdW5kPzogbnVtYmVyO1xuICAgIHByaXZhdGUgX3VwcGVyQm91bmQ/OiBudW1iZXI7XG4gICAgcHJpdmF0ZSBfbG93ZXJWYWx1ZT86IG51bWJlcjtcbiAgICBwcml2YXRlIF91cHBlclZhbHVlPzogbnVtYmVyO1xuICAgIHByaXZhdGUgX2NvbnRpbnVvdXMgPSBmYWxzZTtcbiAgICBwcml2YXRlIF9kaXNhYmxlZCA9IGZhbHNlO1xuICAgIHByaXZhdGUgX3N0ZXAgPSAxO1xuXG4gICAgcHJpdmF0ZSBfbGFiZWxzID0gbmV3IEFycmF5PG51bWJlcnxzdHJpbmd8Ym9vbGVhbnxudWxsfHVuZGVmaW5lZD4oKTtcbiAgICBwcml2YXRlIF90eXBlID0gU2xpZGVyVHlwZS5TTElERVI7XG5cbiAgICBwcml2YXRlIF9kZXN0cm95ZXIkID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcbiAgICBwcml2YXRlIF9pbmRpY2F0b3JzRGVzdHJveWVyJCA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG4gICAgcHJpdmF0ZSBfaW5kaWNhdG9yc1RpbWVyOiBPYnNlcnZhYmxlPGFueT47XG5cblxuICAgIHByaXZhdGUgX29uQ2hhbmdlQ2FsbGJhY2s6IChfOiBhbnkpID0+IHZvaWQgPSBub29wO1xuICAgIHByaXZhdGUgX29uVG91Y2hlZENhbGxiYWNrOiAoKSA9PiB2b2lkID0gbm9vcDtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCd0cmFjaycsIHsgc3RhdGljOiB0cnVlIH0pXG4gICAgcHJpdmF0ZSB0cmFjazogRWxlbWVudFJlZjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCd0aWNrcycsIHsgc3RhdGljOiB0cnVlIH0pXG4gICAgcHJpdmF0ZSB0aWNrczogRWxlbWVudFJlZjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAVmlld0NoaWxkcmVuKElneFNsaWRlclRodW1iQ29tcG9uZW50KVxuICAgIHByaXZhdGUgdGh1bWJzOiBRdWVyeUxpc3Q8SWd4U2xpZGVyVGh1bWJDb21wb25lbnQ+ID0gbmV3IFF1ZXJ5TGlzdDxJZ3hTbGlkZXJUaHVtYkNvbXBvbmVudD4oKTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAVmlld0NoaWxkcmVuKElneFRodW1iTGFiZWxDb21wb25lbnQpXG4gICAgcHJpdmF0ZSBsYWJlbFJlZnM6IFF1ZXJ5TGlzdDxJZ3hUaHVtYkxhYmVsQ29tcG9uZW50PiA9IG5ldyBRdWVyeUxpc3Q8SWd4VGh1bWJMYWJlbENvbXBvbmVudD4oKTtcblxuICAgIHByaXZhdGUgZ2V0IHRodW1iRnJvbSgpOiBJZ3hTbGlkZXJUaHVtYkNvbXBvbmVudCB7XG4gICAgICAgIHJldHVybiB0aGlzLnRodW1icy5maW5kKHRodW1iID0+IHRodW1iLnR5cGUgPT09IFNsaWRlckhhbmRsZS5GUk9NKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldCB0aHVtYlRvKCk6IElneFNsaWRlclRodW1iQ29tcG9uZW50IHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGh1bWJzLmZpbmQodGh1bWIgPT4gdGh1bWIudHlwZSA9PT0gU2xpZGVySGFuZGxlLlRPKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldCBsYWJlbEZyb20oKTogSWd4VGh1bWJMYWJlbENvbXBvbmVudCB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhYmVsUmVmcy5maW5kKGxhYmVsID0+IGxhYmVsLnR5cGUgPT09IFNsaWRlckhhbmRsZS5GUk9NKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGdldCBsYWJlbFRvKCk6IElneFRodW1iTGFiZWxDb21wb25lbnQge1xuICAgICAgICByZXR1cm4gdGhpcy5sYWJlbFJlZnMuZmluZChsYWJlbCA9PiBsYWJlbC50eXBlID09PSBTbGlkZXJIYW5kbGUuVE8pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgc3RlcERpc3RhbmNlID0gdGhpcy5fc3RlcDtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgb25QYW46IFN1YmplY3Q8bnVtYmVyPiA9IG5ldyBTdWJqZWN0PG51bWJlcj4oKTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKElneFRodW1iRnJvbVRlbXBsYXRlRGlyZWN0aXZlLCB7IHJlYWQ6IFRlbXBsYXRlUmVmLCBzdGF0aWM6IGZhbHNlIH0pXG4gICAgcHVibGljIHRodW1iRnJvbVRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxhbnk+O1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoSWd4VGh1bWJUb1RlbXBsYXRlRGlyZWN0aXZlLCB7IHJlYWQ6IFRlbXBsYXRlUmVmLCBzdGF0aWM6IGZhbHNlIH0pXG4gICAgcHVibGljIHRodW1iVG9UZW1wbGF0ZVJlZjogVGVtcGxhdGVSZWY8YW55PjtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoYGF0dHIucm9sZWApXG4gICAgcHVibGljIHJvbGUgPSAnc2xpZGVyJztcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoYGF0dHIuYXJpYS12YWx1ZW1pbmApXG4gICAgcHVibGljIGdldCB2YWx1ZW1pbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluVmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZyhgYXR0ci5hcmlhLXZhbHVlbWF4YClcbiAgICBwdWJsaWMgZ2V0IHZhbHVlbWF4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXhWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKGBhdHRyLmFyaWEtcmVhZG9ubHlgKVxuICAgIHB1YmxpYyBnZXQgcmVhZG9ubHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1zbGlkZXInKVxuICAgIHB1YmxpYyBzbGllckNsYXNzID0gdHJ1ZTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1zbGlkZXItLWRpc2FibGVkJylcbiAgICBwdWJsaWMgZ2V0IGRpc2FibGVkQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIHZhbHVlIG9mIHRoZSBgaWRgIGF0dHJpYnV0ZS5cbiAgICAgKiBJZiBub3QgcHJvdmlkZWQgaXQgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zbGlkZXIgW2lkXT1cIidpZ3gtc2xpZGVyLTMyJ1wiIFsobmdNb2RlbCldPVwidGFzay5wZXJjZW50Q29tcGxldGVkXCIgW3N0ZXBdPVwiNVwiIFtsb3dlckJvdW5kXT1cIjIwXCI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLmlkJylcbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBpZCA9IGBpZ3gtc2xpZGVyLSR7TkVYVF9JRCsrfWA7XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBnZXRzIHRoZSB0eXBlIG9mIHRoZSBgSWd4U2xpZGVyQ29tcG9uZW50YC4gVGhlIHNsaWRlciBjYW4gYmUgU2xpZGVyVHlwZS5TTElERVIoZGVmYXVsdCkgb3IgU2xpZGVyVHlwZS5SQU5HRS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQFZpZXdDaGlsZChcInNsaWRlcjJcIilcbiAgICAgKiBwdWJsaWMgc2xpZGVyOiBJZ3hTbGlkZXJDb21wb25lbnQ7XG4gICAgICogbmdBZnRlclZpZXdJbml0KCl7XG4gICAgICogICAgIGxldCB0eXBlID0gdGhpcy5zbGlkZXIudHlwZTtcbiAgICAgKiB9XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IHR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90eXBlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IHNldHMgdGhlIHR5cGUgb2YgdGhlIGBJZ3hTbGlkZXJDb21wb25lbnRgLiBUaGUgc2xpZGVyIGNhbiBiZSBTbGlkZXJUeXBlLlNMSURFUihkZWZhdWx0KSBvciBTbGlkZXJUeXBlLlJBTkdFLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBzbGlkZXJUeXBlOiBTbGlkZXJUeXBlID0gU2xpZGVyVHlwZS5SQU5HRTtcbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zbGlkZXIgI3NsaWRlcjIgW3R5cGVdPVwic2xpZGVyVHlwZVwiIFsobmdNb2RlbCldPVwicmFuZ2VWYWx1ZVwiIFttaW5WYWx1ZV09XCIwXCIgW21heFZhbHVlXT1cIjEwMFwiPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgdHlwZSh0eXBlOiBTbGlkZXJUeXBlKSB7XG4gICAgICAgIHRoaXMuX3R5cGUgPSB0eXBlO1xuXG4gICAgICAgIGlmICh0eXBlID09PSBTbGlkZXJUeXBlLlNMSURFUikge1xuICAgICAgICAgICAgdGhpcy5sb3dlclZhbHVlID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmxhYmVsc1ZpZXdFbmFibGVkICYmIHRoaXMudXBwZXJWYWx1ZSA+IHRoaXMubWF4VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMudXBwZXJWYWx1ZSA9IHRoaXMubGFiZWxzLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5faGFzVmlld0luaXQpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVHJhY2soKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgZHVyYXRpb24gdmlzaWJpbGl0eSBvZiB0aHVtYnMgbGFiZWxzLiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyA3NTAgbWlsbGlzZWNvbmRzLlxuICAgICAqYGBgaHRtbFxuICAgICAqPGlneC1zbGlkZXIgI3NsaWRlciBbdGh1bWJMYWJlbFZpc2liaWxpdHlEdXJhdGlvbl09XCIzMDAwXCIgWyhuZ01vZGVsKV09XCJ0YXNrLnBlcmNlbnRDb21wbGV0ZWRcIiBbc3RlcF09XCI1XCI+XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyB0aHVtYkxhYmVsVmlzaWJpbGl0eUR1cmF0aW9uID0gNzUwO1xuXG5cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIGBsYWJlbFZpZXdgLCBieSBhY2NlcHRpbmcgYSBjb2xsZWN0aW9uIG9mIHByaW1pdGl2ZSB2YWx1ZXMgd2l0aCBtb3JlIHRoYW4gb25lIGVsZW1lbnQuXG4gICAgICogRWFjaCBlbGVtZW50IHdpbGwgYmUgZXF1YWxseSBzcHJlYWQgb3ZlciB0aGUgc2xpZGVyIGFuZCBpdCB3aWxsIHNlcnZlIGFzIGEgdGh1bWIgbGFiZWwuXG4gICAgICogT25jZSB0aGUgcHJvcGVydHkgaXMgc2V0LCBpdCB3aWxsIHByZWNlbmRlbmNlIG92ZXIge0BsaW5rIG1heFZhbHVlfSwge0BsaW5rIG1pblZhbHVlfSwge0BsaW5rIHN0ZXB9LlxuICAgICAqIFRoaXMgbWVhbnMgdGhhdCB0aGUgbWFuaXB1bGF0aW9uIGZvciB0aG9zZSBwcm9wZXJ0aWVzIHdvbid0IGJlIGFsbG93ZWQuXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IGxhYmVscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhYmVscztcbiAgICB9XG5cbiAgICBwdWJsaWMgc2V0IGxhYmVscyhsYWJlbHM6IEFycmF5PG51bWJlcnxzdHJpbmd8Ym9vbGVhbnxudWxsfHVuZGVmaW5lZD4pIHtcbiAgICAgICAgdGhpcy5fbGFiZWxzID0gbGFiZWxzO1xuXG4gICAgICAgIHRoaXMuX3BNYXggPSAxO1xuXG4gICAgICAgIGlmICh0aGlzLl9oYXNWaWV3SW5pdCkge1xuICAgICAgICAgICAgdGhpcy5zdGVwRGlzdGFuY2UgPSB0aGlzLmNhbGN1bGF0ZVN0ZXBEaXN0YW5jZSgpO1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbkhhbmRsZXNBbmRVcGRhdGVUcmFjaygpO1xuICAgICAgICAgICAgdGhpcy5zZXRUaWNrSW50ZXJ2YWwobGFiZWxzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRlbXBsYXRlIGNvbnRleHQgY29ycmVzcG9uZGluZ1xuICAgICAqIHRvIHtAbGluayBJZ3hUaHVtYkZyb21UZW1wbGF0ZURpcmVjdGl2ZX0gYW5kIHtAbGluayBJZ3hUaHVtYlRvVGVtcGxhdGVEaXJlY3RpdmV9IHRlbXBsYXRlcy5cbiAgICAgKlxuICAgICAqIHJldHVybiB7XG4gICAgICogICRpbXBsaWNpdDoge0BsaW5rIHZhbHVlfSxcbiAgICAgKiAgbGFiZWxzOiB7QGxpbmsgbGFiZWxzfVxuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGNvbnRleHQoKTogYW55IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICRpbXBsaWNpdDogdGhpcy52YWx1ZSxcbiAgICAgICAgICAgIGxhYmVsczogdGhpcy5sYWJlbHNcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHRoZSBpbmNyZW1lbnRhbC9kZWNyZW1lbnRhbCBzdGVwIG9mIHRoZSB2YWx1ZSB3aGVuIGRyYWdnaW5nIHRoZSB0aHVtYi5cbiAgICAgKiBUaGUgZGVmYXVsdCBzdGVwIGlzIDEsIGFuZCBzdGVwIHNob3VsZCBub3QgYmUgbGVzcyBvciBlcXVhbCB0aGFuIDAuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc2xpZGVyICNzbGlkZXIgWyhuZ01vZGVsKV09XCJ0YXNrLnBlcmNlbnRDb21wbGV0ZWRcIiBbc3RlcF09XCI1XCI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2V0IHN0ZXAoc3RlcDogbnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX3N0ZXAgPSBzdGVwO1xuXG4gICAgICAgIGlmICh0aGlzLl9oYXNWaWV3SW5pdCkge1xuICAgICAgICAgICAgdGhpcy5zdGVwRGlzdGFuY2UgPSB0aGlzLmNhbGN1bGF0ZVN0ZXBEaXN0YW5jZSgpO1xuICAgICAgICAgICAgdGhpcy5ub3JtYWxpemVCeVN0ZXAodGhpcy52YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLnNldFRpY2tJbnRlcnZhbCh0aGlzLmxhYmVscyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBpbmNyZW1lbnRhbC9kZWNyZW1lbnRhbCBkcmFnZ2luZyBzdGVwIG9mIHRoZSB7QGxpbmsgSWd4U2xpZGVyQ29tcG9uZW50fS5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQFZpZXdDaGlsZChcInNsaWRlcjJcIilcbiAgICAgKiBwdWJsaWMgc2xpZGVyOiBJZ3hTbGlkZXJDb21wb25lbnQ7XG4gICAgICogbmdBZnRlclZpZXdJbml0KCl7XG4gICAgICogICAgIGxldCBzdGVwID0gdGhpcy5zbGlkZXIuc3RlcDtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCBzdGVwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYWJlbHNWaWV3RW5hYmxlZCA/IDEgOiB0aGlzLl9zdGVwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaWYgdGhlIHtAbGluayBJZ3hTbGlkZXJDb21wb25lbnR9IGlzIGRpc2FibGVkLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKFwic2xpZGVyMlwiKVxuICAgICAqIHB1YmxpYyBzbGlkZXI6IElneFNsaWRlckNvbXBvbmVudDtcbiAgICAgKiBuZ0FmdGVyVmlld0luaXQoKXtcbiAgICAgKiAgICAgbGV0IGlzRGlzYWJsZWQgPSB0aGlzLnNsaWRlci5kaXNhYmxlZDtcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IGRpc2FibGVkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGlzYWJsZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBkaXNhYmxlcyBvciBlbmFibGVzIFVJIGludGVyYWN0aW9uLlxuICAgICAqYGBgaHRtbFxuICAgICAqPGlneC1zbGlkZXIgI3NsaWRlciBbZGlzYWJsZWRdPVwiJ3RydWUnXCIgWyhuZ01vZGVsKV09XCJ0YXNrLnBlcmNlbnRDb21wbGV0ZWRcIiBbc3RlcF09XCI1XCIgW2xvd2VyQm91bmRdPVwiMjBcIj5cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgZGlzYWJsZWQoZGlzYWJsZTogYm9vbGVhbikge1xuICAgICAgICB0aGlzLl9kaXNhYmxlZCA9IGRpc2FibGU7XG5cbiAgICAgICAgaWYgKHRoaXMuX2hhc1ZpZXdJbml0KSB7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVRodW1iRm9jdXNhYmxlU3RhdGUoZGlzYWJsZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlmIHRoZSB7QGxpbmsgSWd4U2xpZGVyQ29tcG9uZW50fSBpcyBzZXQgYXMgY29udGludW91cy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQFZpZXdDaGlsZChcInNsaWRlcjJcIilcbiAgICAgKiBwdWJsaWMgc2xpZGVyOiBJZ3hTbGlkZXJDb21wb25lbnQ7XG4gICAgICogbmdBZnRlclZpZXdJbml0KCl7XG4gICAgICogICAgIGxldCBjb250aW51b3VzID0gdGhpcy5zbGlkZXIuY29udGludW91cztcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgZ2V0IGNvbnRpbnVvdXMoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250aW51b3VzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IG1hcmtzIHRoZSB7QGxpbmsgSWd4U2xpZGVyQ29tcG9uZW50fSBhcyBjb250aW51b3VzLlxuICAgICAqIEJ5IGRlZmF1bHQgaXMgY29uc2lkZXJlZCB0aGF0IHRoZSB7QGxpbmsgSWd4U2xpZGVyQ29tcG9uZW50fSBpcyBkaXNjcmV0ZS5cbiAgICAgKiBEaXNjcmV0ZSB7QGxpbmsgSWd4U2xpZGVyQ29tcG9uZW50fSBkb2VzIG5vdCBoYXZlIHRpY2tzIGFuZCBkb2VzIG5vdCBzaG93IGJ1YmJsZSBsYWJlbHMgZm9yIHZhbHVlcy5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zbGlkZXIgI3NsaWRlciBbY29udGludW91c109XCIndHJ1ZSdcIiBbKG5nTW9kZWwpXT1cInRhc2sucGVyY2VudENvbXBsZXRlZFwiIFtzdGVwXT1cIjVcIiBbbG93ZXJCb3VuZF09XCIyMFwiPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgY29udGludW91cyhjb250aW51b3VzOiBib29sZWFuKSB7XG4gICAgICAgIHRoaXMuX2NvbnRpbnVvdXMgPSBjb250aW51b3VzO1xuICAgICAgICB0aGlzLnNldFRpY2tJbnRlcnZhbChudWxsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlmIHRoZSB7QGxpbmsgSWd4U2xpZGVyQ29tcG9uZW50fSBpcyBzZXQgYXMgY29udGludW91cy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQFZpZXdDaGlsZChcInNsaWRlcjJcIilcbiAgICAgKiBwdWJsaWMgc2xpZGVyOiBJZ3hTbGlkZXJDb21wb25lbnQ7XG4gICAgICogbmdBZnRlclZpZXdJbml0KCl7XG4gICAgICogICAgIGxldCBjb250aW51b3VzID0gdGhpcy5zbGlkZXIuY29udGludW91cztcbiAgICAgKiB9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBARGVwcmVjYXRlUHJvcGVydHkoYElneFNsaWRlckNvbXBvbmVudCBcXGBpc0NvbnRpbnVvdXNcXGAgcHJvcGVydHkgaXMgZGVwcmVjYXRlZC5cXG5Vc2UgXFxgY29udGludW91c1xcYCBpbnN0ZWFkLmApXG4gICAgcHVibGljIGdldCBpc0NvbnRpbnVvdXMoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRpbnVvdXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgaXNDb250aW51b3VzKGNvbnRpbnVvdXM6IGJvb2xlYW4pIHtcbiAgICAgICAgdGhpcy5jb250aW51b3VzID0gY29udGludW91cztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlIGZvciB0aGUge0BsaW5rIElneFNsaWRlckNvbXBvbmVudH0uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqQFZpZXdDaGlsZChcInNsaWRlclwiKVxuICAgICAqcHVibGljIHNsaWRlcjogSWd4U2xpZGVyQ29tcG9uZW50O1xuICAgICAqbmdBZnRlclZpZXdJbml0KCl7XG4gICAgICogICAgbGV0IHNsaWRlck1heCA9IHRoaXMuc2xpZGVyLm1heFZhbHVlO1xuICAgICAqfVxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgbWF4VmFsdWUoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFiZWxzVmlld0VuYWJsZWQgP1xuICAgICAgICAgICAgdGhpcy5sYWJlbHMubGVuZ3RoIC0gMSA6XG4gICAgICAgICAgICB0aGlzLl9tYXhWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtYXhpbWFsIHZhbHVlIGZvciB0aGUgYElneFNsaWRlckNvbXBvbmVudGAuXG4gICAgICogVGhlIGRlZmF1bHQgbWF4aW11bSB2YWx1ZSBpcyAxMDAuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc2xpZGVyIFt0eXBlXT1cInNsaWRlclR5cGVcIiBbbWluVmFsdWVdPVwiNTZcIiBbbWF4VmFsdWVdPVwiMjU2XCI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2V0IG1heFZhbHVlKHZhbHVlOiBudW1iZXIpIHtcbiAgICAgICAgaWYgKHZhbHVlIDw9IHRoaXMuX21pblZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXhWYWx1ZSA9IHRoaXMuX21pblZhbHVlICsgMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX21heFZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgPCB0aGlzLmxvd2VyQm91bmQpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTG93ZXJCb3VuZEFuZE1pblRyYXZlbFpvbmUoKTtcbiAgICAgICAgICAgIHRoaXMudXBwZXJCb3VuZCA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVmcmVzaCBtYXggdHJhdmVsIHpvbmUgbGltaXRzLlxuICAgICAgICB0aGlzLl9wTWF4ID0gMTtcbiAgICAgICAgLy8gcmVjYWxjdWxhdGUgc3RlcCBkaXN0YW5jZS5cbiAgICAgICAgdGhpcy5zdGVwRGlzdGFuY2UgPSB0aGlzLmNhbGN1bGF0ZVN0ZXBEaXN0YW5jZSgpO1xuICAgICAgICB0aGlzLnBvc2l0aW9uSGFuZGxlc0FuZFVwZGF0ZVRyYWNrKCk7XG4gICAgICAgIHRoaXMuc2V0VGlja0ludGVydmFsKG51bGwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqUmV0dXJucyB0aGUgbWluaW1hbCB2YWx1ZSBvZiB0aGUgYElneFNsaWRlckNvbXBvbmVudGAuXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICpAVmlld0NoaWxkKFwic2xpZGVyMlwiKVxuICAgICAqcHVibGljIHNsaWRlcjogSWd4U2xpZGVyQ29tcG9uZW50O1xuICAgICAqbmdBZnRlclZpZXdJbml0KCl7XG4gICAgICogICAgbGV0IHNsaWRlck1pbiA9IHRoaXMuc2xpZGVyLm1pblZhbHVlO1xuICAgICAqfVxuICAgICAqYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCBtaW5WYWx1ZSgpOiBudW1iZXIge1xuICAgICAgICBpZiAodGhpcy5sYWJlbHNWaWV3RW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fbWluVmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbWluaW1hbCB2YWx1ZSBmb3IgdGhlIGBJZ3hTbGlkZXJDb21wb25lbnRgLlxuICAgICAqIFRoZSBkZWZhdWx0IG1pbmltYWwgdmFsdWUgaXMgMC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zbGlkZXIgW3R5cGVdPVwic2xpZGVyVHlwZVwiIFttaW5WYWx1ZV09XCI1NlwiIFttYXhWYWx1ZV09XCIxMDBcIj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZXQgbWluVmFsdWUodmFsdWU6IG51bWJlcikge1xuICAgICAgICBpZiAodmFsdWUgPj0gdGhpcy5tYXhWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5fbWluVmFsdWUgPSB0aGlzLm1heFZhbHVlIC0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX21pblZhbHVlID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUgPiB0aGlzLnVwcGVyQm91bmQpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlVXBwZXJCb3VuZEFuZE1heFRyYXZlbFpvbmUoKTtcbiAgICAgICAgICAgIHRoaXMubG93ZXJCb3VuZCA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVmcmVzaCBtaW4gdHJhdmVsIHpvbmUgbGltaXQuXG4gICAgICAgIHRoaXMuX3BNaW4gPSAwO1xuICAgICAgICAvLyBSZWNhbGN1bGF0ZSBzdGVwIGRpc3RhbmNlLlxuICAgICAgICB0aGlzLnN0ZXBEaXN0YW5jZSA9IHRoaXMuY2FsY3VsYXRlU3RlcERpc3RhbmNlKCk7XG4gICAgICAgIHRoaXMucG9zaXRpb25IYW5kbGVzQW5kVXBkYXRlVHJhY2soKTtcbiAgICAgICAgdGhpcy5zZXRUaWNrSW50ZXJ2YWwobnVsbCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbG93ZXIgYm91bmRhcnkgb2YgdGhlIGBJZ3hTbGlkZXJDb21wb25lbnRgLlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqQFZpZXdDaGlsZChcInNsaWRlclwiKVxuICAgICAqcHVibGljIHNsaWRlcjogSWd4U2xpZGVyQ29tcG9uZW50O1xuICAgICAqbmdBZnRlclZpZXdJbml0KCl7XG4gICAgICogICAgbGV0IHNsaWRlckxvd0JvdW5kID0gdGhpcy5zbGlkZXIubG93ZXJCb3VuZDtcbiAgICAgKn1cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgbG93ZXJCb3VuZCgpOiBudW1iZXIge1xuICAgICAgICBpZiAoIU51bWJlci5pc05hTih0aGlzLl9sb3dlckJvdW5kKSAmJiB0aGlzLl9sb3dlckJvdW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlSW5SYW5nZSh0aGlzLl9sb3dlckJvdW5kLCB0aGlzLm1pblZhbHVlLCB0aGlzLm1heFZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLm1pblZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGxvd2VyIGJvdW5kYXJ5IG9mIHRoZSBgSWd4U2xpZGVyQ29tcG9uZW50YC5cbiAgICAgKiBJZiBub3Qgc2V0IGlzIHRoZSBzYW1lIGFzIG1pbiB2YWx1ZS5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC1zbGlkZXIgW3N0ZXBdPVwiNVwiIFtsb3dlckJvdW5kXT1cIjIwXCI+XG4gICAgICogYGBgXG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgc2V0IGxvd2VyQm91bmQodmFsdWU6IG51bWJlcikge1xuICAgICAgICBpZiAodmFsdWUgPj0gdGhpcy51cHBlckJvdW5kIHx8ICh0aGlzLmxhYmVsc1ZpZXdFbmFibGVkICYmIHZhbHVlIDwgMCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xvd2VyQm91bmQgPSB0aGlzLnZhbHVlSW5SYW5nZSh2YWx1ZSwgdGhpcy5taW5WYWx1ZSwgdGhpcy5tYXhWYWx1ZSk7XG5cbiAgICAgICAgLy8gUmVmcmVzaCB0aW1lIHRyYXZlbCB6b25lLlxuICAgICAgICB0aGlzLl9wTWluID0gdGhpcy52YWx1ZVRvRnJhY3Rpb24odGhpcy5fbG93ZXJCb3VuZCkgfHwgMDtcbiAgICAgICAgdGhpcy5wb3NpdGlvbkhhbmRsZXNBbmRVcGRhdGVUcmFjaygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHVwcGVyIGJvdW5kYXJ5IG9mIHRoZSBgSWd4U2xpZGVyQ29tcG9uZW50YC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICpAVmlld0NoaWxkKFwic2xpZGVyXCIpXG4gICAgICpwdWJsaWMgc2xpZGVyOiBJZ3hTbGlkZXJDb21wb25lbnQ7XG4gICAgICpuZ0FmdGVyVmlld0luaXQoKXtcbiAgICAgKiAgICBsZXQgc2xpZGVyVXBCb3VuZCA9IHRoaXMuc2xpZGVyLnVwcGVyQm91bmQ7XG4gICAgICp9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCB1cHBlckJvdW5kKCk6IG51bWJlciB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzTmFOKHRoaXMuX3VwcGVyQm91bmQpICYmIHRoaXMuX3VwcGVyQm91bmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVJblJhbmdlKHRoaXMuX3VwcGVyQm91bmQsIHRoaXMubWluVmFsdWUsIHRoaXMubWF4VmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMubWF4VmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdXBwZXIgYm91bmRhcnkgb2YgdGhlIGBJZ3hTbGlkZXJDb21wb25lbnRgLlxuICAgICAqIElmIG5vdCBzZXQgaXMgdGhlIHNhbWUgYXMgbWF4IHZhbHVlLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXNsaWRlciBbc3RlcF09XCI1XCIgW3VwcGVyQm91bmRdPVwiMjBcIj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBzZXQgdXBwZXJCb3VuZCh2YWx1ZTogbnVtYmVyKSB7XG4gICAgICAgIGlmICh2YWx1ZSA8PSB0aGlzLmxvd2VyQm91bmQgfHwgKHRoaXMubGFiZWxzVmlld0VuYWJsZWQgJiYgdmFsdWUgPiB0aGlzLmxhYmVscy5sZW5ndGggLSAxKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fdXBwZXJCb3VuZCA9IHRoaXMudmFsdWVJblJhbmdlKHZhbHVlLCB0aGlzLm1pblZhbHVlLCB0aGlzLm1heFZhbHVlKTtcbiAgICAgICAgLy8gUmVmcmVzaCB0aW1lIHRyYXZlbCB6b25lLlxuICAgICAgICB0aGlzLl9wTWF4ID0gdGhpcy52YWx1ZVRvRnJhY3Rpb24odGhpcy5fdXBwZXJCb3VuZCkgfHwgMTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbkhhbmRsZXNBbmRVcGRhdGVUcmFjaygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHNsaWRlciB2YWx1ZS4gSWYgdGhlIHNsaWRlciBpcyBvZiB0eXBlIHtAbGluayBTbGlkZXJUeXBlLlNMSURFUn0gdGhlIHJldHVybmVkIHZhbHVlIGlzIG51bWJlci5cbiAgICAgKiBJZiB0aGUgc2xpZGVyIHR5cGUgaXMge0BsaW5rIFNsaWRlclR5cGUuUkFOR0V9IHRoZSByZXR1cm5lZCB2YWx1ZSByZXByZXNlbnRzIGFuIG9iamVjdCBvZiB7QGxpbmsgbG93ZXJWYWx1ZX0gYW5kIHtAbGluayB1cHBlclZhbHVlfS5cbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKkBWaWV3Q2hpbGQoXCJzbGlkZXIyXCIpXG4gICAgICpwdWJsaWMgc2xpZGVyOiBJZ3hTbGlkZXJDb21wb25lbnQ7XG4gICAgICpwdWJsaWMgc2xpZGVyVmFsdWUoZXZlbnQpe1xuICAgICAqICAgIGxldCBzbGlkZXJWYWwgPSB0aGlzLnNsaWRlci52YWx1ZTtcbiAgICAgKn1cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgdmFsdWUoKTogbnVtYmVyIHwgSVJhbmdlU2xpZGVyVmFsdWUge1xuICAgICAgICBpZiAodGhpcy5pc1JhbmdlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGxvd2VyOiB0aGlzLnZhbHVlSW5SYW5nZSh0aGlzLmxvd2VyVmFsdWUsIHRoaXMubG93ZXJCb3VuZCwgdGhpcy51cHBlckJvdW5kKSxcbiAgICAgICAgICAgICAgICB1cHBlcjogdGhpcy52YWx1ZUluUmFuZ2UodGhpcy51cHBlclZhbHVlLCB0aGlzLmxvd2VyQm91bmQsIHRoaXMudXBwZXJCb3VuZClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZUluUmFuZ2UodGhpcy51cHBlclZhbHVlLCB0aGlzLmxvd2VyQm91bmQsIHRoaXMudXBwZXJCb3VuZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzbGlkZXIgdmFsdWUuXG4gICAgICogSWYgdGhlIHNsaWRlciBpcyBvZiB0eXBlIHtAbGluayBTbGlkZXJUeXBlLlNMSURFUn0gdGhlIGFyZ3VtZW50IGlzIG51bWJlci4gQnkgZGVmYXVsdCB0aGUge0BsaW5rIHZhbHVlfSBnZXRzIHRoZSB7QGxpbmsgbG93ZXJCb3VuZH0uXG4gICAgICogSWYgdGhlIHNsaWRlciB0eXBlIGlzIHtAbGluayBTbGlkZXJUeXBlLlJBTkdFfSB0aGUgYXJndW1lbnRcbiAgICAgKiByZXByZXNlbnRzIGFuIG9iamVjdCBvZiB7QGxpbmsgbG93ZXJWYWx1ZX0gYW5kIHtAbGluayB1cHBlclZhbHVlfSBwcm9wZXJ0aWVzLlxuICAgICAqIEJ5IGRlZmF1bHQgdGhlIG9iamVjdCBpcyBhc3NvY2lhdGVkIHdpdGggdGhlIHtAbGluayBsb3dlckJvdW5kfSBhbmQge0BsaW5rIHVwcGVyQm91bmR9IHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICpyYW5nZVZhbHVlID0ge1xuICAgICAqICAgbG93ZXI6IDMwLFxuICAgICAqICAgdXBwZXI6IDYwXG4gICAgICp9O1xuICAgICAqIGBgYFxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXNsaWRlciBbdHlwZV09XCJzbGlkZXJUeXBlXCIgWyhuZ01vZGVsKV09XCJyYW5nZVZhbHVlXCIgW21pblZhbHVlXT1cIjU2XCIgW21heFZhbHVlXT1cIjI1NlwiPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHNldCB2YWx1ZSh2YWx1ZTogbnVtYmVyIHwgSVJhbmdlU2xpZGVyVmFsdWUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzUmFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMudXBwZXJWYWx1ZSA9IHZhbHVlIGFzIG51bWJlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy52YWxpZGF0ZUluaXRpYWxWYWx1ZSh2YWx1ZSBhcyBJUmFuZ2VTbGlkZXJWYWx1ZSk7XG4gICAgICAgICAgICB0aGlzLnVwcGVyVmFsdWUgPSAodmFsdWUgYXMgSVJhbmdlU2xpZGVyVmFsdWUpLnVwcGVyO1xuICAgICAgICAgICAgdGhpcy5sb3dlclZhbHVlID0gKHZhbHVlIGFzIElSYW5nZVNsaWRlclZhbHVlKS5sb3dlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX29uQ2hhbmdlQ2FsbGJhY2sodGhpcy52YWx1ZSk7XG5cbiAgICAgICAgaWYgKHRoaXMuX2hhc1ZpZXdJbml0KSB7XG4gICAgICAgICAgICB0aGlzLnBvc2l0aW9uSGFuZGxlc0FuZFVwZGF0ZVRyYWNrKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGV2ZW50IGlzIGVtaXR0ZWQgd2hlbiB1c2VyIGhhcyBzdG9wcGVkIGludGVyYWN0aW5nIHRoZSB0aHVtYiBhbmQgdmFsdWUgaXMgY2hhbmdlZC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIGNoYW5nZShldmVudCl7XG4gICAgICogICAgYWxlcnQoXCJUaGUgdmFsdWUgaGFzIGJlZW4gY2hhbmdlZCFcIik7XG4gICAgICp9XG4gICAgICogYGBgXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtc2xpZGVyIChvblZhbHVlQ2hhbmdlKT1cImNoYW5nZSgkZXZlbnQpXCIgI3NsaWRlciBbKG5nTW9kZWwpXT1cInRhc2sucGVyY2VudENvbXBsZXRlZFwiIFtzdGVwXT1cIjVcIj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgb25WYWx1ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8SVNsaWRlclZhbHVlQ2hhbmdlRXZlbnRBcmdzPigpO1xuXG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlbmRlcmVyOiBSZW5kZXJlcjIsIHByaXZhdGUgX2VsOiBFbGVtZW50UmVmLCBwcml2YXRlIF9jZHI6IENoYW5nZURldGVjdG9yUmVmKSB7IH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdExpc3RlbmVyKCdwb2ludGVyZG93bicsIFsnJGV2ZW50J10pXG4gICAgcHVibGljIG9uUG9pbnRlckRvd24oJGV2ZW50OiBQb2ludGVyRXZlbnQpIHtcbiAgICAgICAgdGhpcy5maW5kQ2xvc2VzdFRodW1iKCRldmVudCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLnRodW1iVG8uaXNBY3RpdmUgJiYgdGhpcy50aHVtYkZyb20gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYWN0aXZlVGh1bWIgPSB0aGlzLnRodW1iVG8uaXNBY3RpdmUgPyB0aGlzLnRodW1iVG8gOiB0aGlzLnRodW1iRnJvbTtcbiAgICAgICAgYWN0aXZlVGh1bWIubmF0aXZlRWxlbWVudC5zZXRQb2ludGVyQ2FwdHVyZSgkZXZlbnQucG9pbnRlcklkKTtcbiAgICAgICAgdGhpcy5zaG93U2xpZGVySW5kaWNhdG9ycygpO1xuXG4gICAgICAgICRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIEBIb3N0TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIFsnJGV2ZW50J10pXG4gICAgcHVibGljIG9uUG9pbnRlclVwKCRldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMudGh1bWJUby5pc0FjdGl2ZSAmJiB0aGlzLnRodW1iRnJvbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBhY3RpdmVUaHVtYiA9IHRoaXMudGh1bWJUby5pc0FjdGl2ZSA/IHRoaXMudGh1bWJUbyA6IHRoaXMudGh1bWJUbztcbiAgICAgICAgYWN0aXZlVGh1bWIubmF0aXZlRWxlbWVudC5yZWxlYXNlUG9pbnRlckNhcHR1cmUoJGV2ZW50LnBvaW50ZXJJZCk7XG5cbiAgICAgICAgdGhpcy5oaWRlU2xpZGVySW5kaWNhdG9ycygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdExpc3RlbmVyKCdmb2N1cycpXG4gICAgcHVibGljIG9uRm9jdXMoKSB7XG4gICAgICAgIHRoaXMudG9nZ2xlU2xpZGVySW5kaWNhdG9ycygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdExpc3RlbmVyKCdwYW4nLCBbJyRldmVudCddKVxuICAgIHB1YmxpYyBvblBhbkxpc3RlbmVyKCRldmVudCkge1xuICAgICAgICB0aGlzLnVwZGF0ZSgkZXZlbnQuc3JjRXZlbnQuY2xpZW50WCk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcigncGFuc3RhcnQnKVxuICAgIHB1YmxpYyBvblBhblN0YXJ0KCkge1xuICAgICAgICB0aGlzLnNob3dTbGlkZXJJbmRpY2F0b3JzKCk7XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcigncGFuZW5kJylcbiAgICBwdWJsaWMgb25QYW5FbmQoKSB7XG4gICAgICAgIHRoaXMuaGlkZVNsaWRlckluZGljYXRvcnMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlJldHVybnMgd2hldGhlciB0aGUgYElneFNsaWRlckNvbXBvbmVudGAgdHlwZSBpcyBSQU5HRS5cbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKkBWaWV3Q2hpbGQoXCJzbGlkZXJcIilcbiAgICAgKnB1YmxpYyBzbGlkZXI6IElneFNsaWRlckNvbXBvbmVudDtcbiAgICAgKm5nQWZ0ZXJWaWV3SW5pdCgpe1xuICAgICAqICAgIGxldCBzbGlkZXJSYW5nZSA9IHRoaXMuc2xpZGVyLmlzUmFuZ2U7XG4gICAgICp9XG4gICAgICogYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCBpc1JhbmdlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSBTbGlkZXJUeXBlLlJBTkdFO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxvd2VyIHZhbHVlIG9mIHRoZSBgSWd4U2xpZGVyQ29tcG9uZW50YC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogQFZpZXdDaGlsZChcInNsaWRlclwiKVxuICAgICAqIHB1YmxpYyBzbGlkZXI6IElneFNsaWRlckNvbXBvbmVudDtcbiAgICAgKiBwdWJsaWMgbG93VmFsdWUoZXZlbnQpe1xuICAgICAqICAgIGxldCBzbGlkZXJMb3dWYWx1ZSA9IHRoaXMuc2xpZGVyLmxvd2VyVmFsdWU7XG4gICAgICp9XG4gICAgICpgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IGxvd2VyVmFsdWUoKTogbnVtYmVyIHtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4odGhpcy5fbG93ZXJWYWx1ZSkgJiYgdGhpcy5fbG93ZXJWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuX2xvd2VyVmFsdWUgPj0gdGhpcy5sb3dlckJvdW5kKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbG93ZXJWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmxvd2VyQm91bmQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpTZXRzIHRoZSBsb3dlciB2YWx1ZSBvZiB0aGUgYElneFNsaWRlckNvbXBvbmVudGAuXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICpAVmlld0NoaWxkKFwic2xpZGVyMlwiKVxuICAgICAqcHVibGljIHNsaWRlcjogSWd4U2xpZGVyQ29tcG9uZW50O1xuICAgICAqcHVibGljIGxvd1ZhbHVlKGV2ZW50KXtcbiAgICAgKiAgICB0aGlzLnNsaWRlci5sb3dlclZhbHVlID0gMTIwO1xuICAgICAqfVxuICAgICAqYGBgXG4gICAgICovXG4gICAgcHVibGljIHNldCBsb3dlclZhbHVlKHZhbHVlOiBudW1iZXIpIHtcbiAgICAgICAgdmFsdWUgPSB0aGlzLnZhbHVlSW5SYW5nZSh2YWx1ZSwgdGhpcy5sb3dlckJvdW5kLCB0aGlzLnVwcGVyQm91bmQpO1xuICAgICAgICB0aGlzLl9sb3dlclZhbHVlID0gdmFsdWU7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlJldHVybnMgdGhlIHVwcGVyIHZhbHVlIG9mIHRoZSBgSWd4U2xpZGVyQ29tcG9uZW50YC5cbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKkBWaWV3Q2hpbGQoXCJzbGlkZXIyXCIpXG4gICAgICpwdWJsaWMgc2xpZGVyOiBJZ3hTbGlkZXJDb21wb25lbnQ7XG4gICAgICpwdWJsaWMgdXBwZXJWYWx1ZShldmVudCl7XG4gICAgICogICAgbGV0IHVwcGVyVmFsdWUgPSB0aGlzLnNsaWRlci51cHBlclZhbHVlO1xuICAgICAqfVxuICAgICAqYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCB1cHBlclZhbHVlKCkge1xuICAgICAgICBpZiAoIU51bWJlci5pc05hTih0aGlzLl91cHBlclZhbHVlKSAmJiB0aGlzLl91cHBlclZhbHVlICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fdXBwZXJWYWx1ZSA8PSB0aGlzLnVwcGVyQm91bmQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl91cHBlclZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMudXBwZXJCb3VuZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKlNldHMgdGhlIHVwcGVyIHZhbHVlIG9mIHRoZSBgSWd4U2xpZGVyQ29tcG9uZW50YC5cbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKkBWaWV3Q2hpbGQoXCJzbGlkZXIyXCIpXG4gICAgICpwdWJsaWMgc2xpZGVyOiBJZ3hTbGlkZXJDb21wb25lbnQ7XG4gICAgICpwdWJsaWMgdXBwZXJWYWx1ZShldmVudCl7XG4gICAgICogICAgdGhpcy5zbGlkZXIudXBwZXJWYWx1ZSA9IDEyMDtcbiAgICAgKn1cbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBzZXQgdXBwZXJWYWx1ZSh2YWx1ZTogbnVtYmVyKSB7XG4gICAgICAgIHZhbHVlID0gdGhpcy52YWx1ZUluUmFuZ2UodmFsdWUsIHRoaXMubG93ZXJCb3VuZCwgdGhpcy51cHBlckJvdW5kKTtcbiAgICAgICAgdGhpcy5fdXBwZXJWYWx1ZSA9IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHZhbHVlIGNvcnJlc3BvbmRpbmcgdGhlIGxvd2VyIGxhYmVsLlxuICAgICAqYGBgdHlwZXNjcmlwdFxuICAgICAqIEBWaWV3Q2hpbGQoXCJzbGlkZXJcIilcbiAgICAgKiBwdWJsaWMgc2xpZGVyOiBJZ3hTbGlkZXJDb21wb25lbnQ7XG4gICAgICogbGV0IGxhYmVsID0gdGhpcy5zbGlkZXIubG93ZXJMYWJlbDtcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgbG93ZXJMYWJlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFiZWxzVmlld0VuYWJsZWQgP1xuICAgICAgICAgICAgdGhpcy5sYWJlbHNbdGhpcy5sb3dlclZhbHVlXSA6XG4gICAgICAgICAgICB0aGlzLmxvd2VyVmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmFsdWUgY29ycmVzcG9uZGluZyB0aGUgdXBwZXIgbGFiZWwuXG4gICAgICpgYGB0eXBlc2NyaXB0XG4gICAgICogQFZpZXdDaGlsZChcInNsaWRlclwiKVxuICAgICAqIHB1YmxpYyBzbGlkZXI6IElneFNsaWRlckNvbXBvbmVudDtcbiAgICAgKiBsZXQgbGFiZWwgPSB0aGlzLnNsaWRlci51cHBlckxhYmVsO1xuICAgICAqYGBgXG4gICAgICovXG4gICAgcHVibGljIGdldCB1cHBlckxhYmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYWJlbHNWaWV3RW5hYmxlZCA/XG4gICAgICAgICAgICB0aGlzLmxhYmVsc1t0aGlzLnVwcGVyVmFsdWVdIDpcbiAgICAgICAgICAgIHRoaXMudXBwZXJWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGlmIGxhYmVsIHZpZXcgaXMgZW5hYmxlZC5cbiAgICAgKiBJZiB0aGUge0BsaW5rIGxhYmVsc30gaXMgc2V0LCB0aGUgdmlldyBpcyBhdXRvbWF0aWNhbGx5IGFjdGl2YXRlZC5cbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKiBAVmlld0NoaWxkKFwic2xpZGVyXCIpXG4gICAgICogcHVibGljIHNsaWRlcjogSWd4U2xpZGVyQ29tcG9uZW50O1xuICAgICAqIGxldCBsYWJlbFZpZXcgPSB0aGlzLnNsaWRlci5sYWJlbHNWaWV3RW5hYmxlZDtcbiAgICAgKmBgYFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXQgbGFiZWxzVmlld0VuYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiAhISh0aGlzLmxhYmVscyAmJiB0aGlzLmxhYmVscy5sZW5ndGggPiAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnNsaWRlclNldHVwKCk7XG5cbiAgICAgICAgLy8gU2V0IHRyYWNrIHRyYXZlbCB6b25lXG4gICAgICAgIHRoaXMuX3BNaW4gPSB0aGlzLnZhbHVlVG9GcmFjdGlvbih0aGlzLmxvd2VyQm91bmQpIHx8IDA7XG4gICAgICAgIHRoaXMuX3BNYXggPSB0aGlzLnZhbHVlVG9GcmFjdGlvbih0aGlzLnVwcGVyQm91bmQpIHx8IDE7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIHRoaXMuX2hhc1ZpZXdJbml0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wb3NpdGlvbkhhbmRsZXNBbmRVcGRhdGVUcmFjaygpO1xuICAgICAgICB0aGlzLnNldFRpY2tJbnRlcnZhbCh0aGlzLmxhYmVscyk7XG4gICAgICAgIHRoaXMuY2hhbmdlVGh1bWJGb2N1c2FibGVTdGF0ZSh0aGlzLmRpc2FibGVkKTtcblxuICAgICAgICB0aGlzLnN1YnNjcmliZVRvKHRoaXMudGh1bWJGcm9tLCB0aGlzLnRodW1iQ2hhbmdlZC5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVUbyh0aGlzLnRodW1iVG8sIHRoaXMudGh1bWJDaGFuZ2VkLmJpbmQodGhpcykpO1xuXG4gICAgICAgIHRoaXMudGh1bWJzLmNoYW5nZXMucGlwZSh0YWtlVW50aWwodGhpcy5fZGVzdHJveWVyJCkpLnN1YnNjcmliZShjaGFuZ2UgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGh1bWJGcm9tID0gY2hhbmdlLmZpbmQoKHRodW1iOiBJZ3hTbGlkZXJUaHVtYkNvbXBvbmVudCkgPT4gdGh1bWIudHlwZSA9PT0gU2xpZGVySGFuZGxlLkZST00pO1xuICAgICAgICAgICAgY29uc3QgbGFiZWxGcm9tID0gdGhpcy5sYWJlbFJlZnMuZmluZCgobGFiZWw6IElneFRodW1iTGFiZWxDb21wb25lbnQpID0+IGxhYmVsLnR5cGUgPT09IFNsaWRlckhhbmRsZS5GUk9NKTtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25IYW5kbGUodGh1bWJGcm9tLCBsYWJlbEZyb20sIHRoaXMubG93ZXJWYWx1ZSk7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZVRvKHRodW1iRnJvbSwgdGhpcy50aHVtYkNoYW5nZWQuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVRodW1iRm9jdXNhYmxlU3RhdGUodGhpcy5kaXNhYmxlZCk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgbmdBZnRlckNvbnRlbnRDaGVja2VkKCkge1xuICAgICAgICAvLyBDYWxjdWxhdGVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIGV2ZXJ5IHN0ZXAgaW4gcGl4ZWxzLlxuICAgICAgICB0aGlzLnN0ZXBEaXN0YW5jZSA9IHRoaXMuY2FsY3VsYXRlU3RlcERpc3RhbmNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5fZGVzdHJveWVyJC5uZXh0KHRydWUpO1xuICAgICAgICB0aGlzLl9kZXN0cm95ZXIkLmNvbXBsZXRlKCk7XG5cbiAgICAgICAgdGhpcy5faW5kaWNhdG9yc0Rlc3Ryb3llciQubmV4dCh0cnVlKTtcbiAgICAgICAgdGhpcy5faW5kaWNhdG9yc0Rlc3Ryb3llciQuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHdyaXRlVmFsdWUodmFsdWU6IElSYW5nZVNsaWRlclZhbHVlIHwgbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubm9ybWFsaXplQnlTdGVwKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSk6IHZvaWQge1xuICAgICAgICB0aGlzLl9vbkNoYW5nZUNhbGxiYWNrID0gZm47XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHB1YmxpYyByZWdpc3Rlck9uVG91Y2hlZChmbjogYW55KTogdm9pZCB7XG4gICAgICAgIHRoaXMuX29uVG91Y2hlZENhbGxiYWNrID0gZm47XG4gICAgfVxuXG4gICAgLyoqIEBoaWRkZW4gKi9cbiAgICBwdWJsaWMgZ2V0RWRpdEVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzUmFuZ2UgPyB0aGlzLnRodW1iRnJvbS5uYXRpdmVFbGVtZW50IDogdGhpcy50aHVtYlRvLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIHVwZGF0ZShtb3VzZVgpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVwZGF0ZSBUby9Gcm9tIFZhbHVlc1xuICAgICAgICB0aGlzLm9uUGFuLm5leHQobW91c2VYKTtcblxuICAgICAgICAvLyBGaW5hbGx5IGRvIHBvc2l0aW9uSGFuZGxlc0FuZFVwZGF0ZVRyYWNrIHRoZSBET01cbiAgICAgICAgLy8gYmFzZWQgb24gZGF0YSB2YWx1ZXNcbiAgICAgICAgdGhpcy5wb3NpdGlvbkhhbmRsZXNBbmRVcGRhdGVUcmFjaygpO1xuICAgICAgICB0aGlzLl9vblRvdWNoZWRDYWxsYmFjaygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgdGh1bWJDaGFuZ2VkKHZhbHVlOiBudW1iZXIsIHRodW1iVHlwZTogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcblxuICAgICAgICBsZXQgbmV3VmFsOiBJUmFuZ2VTbGlkZXJWYWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuaXNSYW5nZSkge1xuICAgICAgICAgICAgaWYgKHRodW1iVHlwZSA9PT0gU2xpZGVySGFuZGxlLkZST00pIHtcbiAgICAgICAgICAgICAgICBuZXdWYWwgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxvd2VyOiAodGhpcy52YWx1ZSBhcyBJUmFuZ2VTbGlkZXJWYWx1ZSkubG93ZXIgKyB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgdXBwZXI6ICh0aGlzLnZhbHVlIGFzIElSYW5nZVNsaWRlclZhbHVlKS51cHBlclxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1ZhbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgbG93ZXI6ICh0aGlzLnZhbHVlIGFzIElSYW5nZVNsaWRlclZhbHVlKS5sb3dlcixcbiAgICAgICAgICAgICAgICAgICAgdXBwZXI6ICh0aGlzLnZhbHVlIGFzIElSYW5nZVNsaWRlclZhbHVlKS51cHBlciArIHZhbHVlXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3dhcCB0aGUgdGh1bWJzIGlmIGEgY29sbGlzaW9uIGFwcGVhcnMuXG4gICAgICAgICAgICBpZiAobmV3VmFsLmxvd2VyID49IG5ld1ZhbC51cHBlcikge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnN3YXBUaHVtYihuZXdWYWwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlID0gbmV3VmFsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy52YWx1ZSBhcyBudW1iZXIgKyB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmhhc1ZhbHVlQ2hhbmdlZChvbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdFZhbHVlQ2hhbmdlZChvbGRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG9uVGh1bWJDaGFuZ2UoKSB7XG4gICAgICAgIHRoaXMudG9nZ2xlU2xpZGVySW5kaWNhdG9ycygpO1xuICAgIH1cblxuICAgIHB1YmxpYyBvbkhvdmVyQ2hhbmdlKHN0YXRlOiBib29sZWFuKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZSA/IHRoaXMuc2hvd1NsaWRlckluZGljYXRvcnMoKSA6IHRoaXMuaGlkZVNsaWRlckluZGljYXRvcnMoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHN3YXBUaHVtYih2YWx1ZTogSVJhbmdlU2xpZGVyVmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMudGh1bWJGcm9tLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICB2YWx1ZS51cHBlciA9IHRoaXMudXBwZXJWYWx1ZTtcbiAgICAgICAgICAgIHZhbHVlLmxvd2VyID0gdGhpcy51cHBlclZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUudXBwZXIgPSB0aGlzLmxvd2VyVmFsdWU7XG4gICAgICAgICAgICB2YWx1ZS5sb3dlciA9IHRoaXMubG93ZXJWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudG9nZ2xlVGh1bWIoKTtcblxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBmaW5kQ2xvc2VzdFRodW1iKGV2ZW50OiBQb2ludGVyRXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNSYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZXN0SGFuZGxlKGV2ZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudGh1bWJUby5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnVwZGF0ZShldmVudC5jbGllbnRYKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZUxvd2VyQm91bmRBbmRNaW5UcmF2ZWxab25lKCkge1xuICAgICAgICB0aGlzLmxvd2VyQm91bmQgPSB0aGlzLm1pblZhbHVlO1xuICAgICAgICB0aGlzLl9wTWluID0gMDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHVwZGF0ZVVwcGVyQm91bmRBbmRNYXhUcmF2ZWxab25lKCkge1xuICAgICAgICB0aGlzLnVwcGVyQm91bmQgPSB0aGlzLm1heFZhbHVlO1xuICAgICAgICB0aGlzLl9wTWF4ID0gMTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNsaWRlclNldHVwKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogaWYge0BsaW5rIFNsaWRlclR5cGUuU0xJREVSfSB0aGFuIHRoZSBpbml0aWFsIHZhbHVlIHNob2xkIGJlIHRoZSBsb3dlc3Qgb25lLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCF0aGlzLmlzUmFuZ2UgJiYgdGhpcy52YWx1ZSA9PT0gdGhpcy51cHBlckJvdW5kKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gdGhpcy5sb3dlckJvdW5kO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjYWxjdWxhdGVTdGVwRGlzdGFuY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIC8gKHRoaXMubWF4VmFsdWUgLSB0aGlzLm1pblZhbHVlKSAqIHRoaXMuc3RlcDtcbiAgICB9XG5cbiAgICBwcml2YXRlIHRvZ2dsZVRodW1iKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50aHVtYkZyb20uaXNBY3RpdmUgP1xuICAgICAgICAgICAgdGhpcy50aHVtYlRvLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKSA6XG4gICAgICAgICAgICB0aGlzLnRodW1iRnJvbS5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB2YWx1ZUluUmFuZ2UodmFsdWUsIG1pbiA9IDAsIG1heCA9IDEwMCkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4odmFsdWUsIG1heCksIG1pbik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBnZW5lcmF0ZVRpY2tNYXJrcyhjb2xvcjogc3RyaW5nLCBpbnRlcnZhbDogbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBpbnRlcnZhbCAhPT0gbnVsbCA/IGByZXBlYXRpbmctbGluZWFyLWdyYWRpZW50KFxuICAgICAgICAgICAgJHsndG8gbGVmdCd9LFxuICAgICAgICAgICAgJHtjb2xvcn0sXG4gICAgICAgICAgICAke2NvbG9yfSAxLjVweCxcbiAgICAgICAgICAgIHRyYW5zcGFyZW50IDEuNXB4LFxuICAgICAgICAgICAgdHJhbnNwYXJlbnQgJHtpbnRlcnZhbH0lXG4gICAgICAgICksIHJlcGVhdGluZy1saW5lYXItZ3JhZGllbnQoXG4gICAgICAgICAgICAkeyd0byByaWdodCd9LFxuICAgICAgICAgICAgJHtjb2xvcn0sXG4gICAgICAgICAgICAke2NvbG9yfSAxLjVweCxcbiAgICAgICAgICAgIHRyYW5zcGFyZW50IDEuNXB4LFxuICAgICAgICAgICAgdHJhbnNwYXJlbnQgJHtpbnRlcnZhbH0lXG4gICAgICAgIClgIDogaW50ZXJ2YWw7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBwb3NpdGlvbkhhbmRsZSh0aHVtYkhhbmRsZTogRWxlbWVudFJlZiwgbGFiZWxIYW5kbGU6IEVsZW1lbnRSZWYsIHBvc2l0aW9uOiBudW1iZXIpIHtcbiAgICAgICAgY29uc3QgcG9zaXRpb25MZWZ0ID0gYCR7dGhpcy52YWx1ZVRvRnJhY3Rpb24ocG9zaXRpb24pICogMTAwfSVgO1xuXG4gICAgICAgIGlmICh0aHVtYkhhbmRsZSkge1xuICAgICAgICAgICAgdGh1bWJIYW5kbGUubmF0aXZlRWxlbWVudC5zdHlsZS5sZWZ0ID0gcG9zaXRpb25MZWZ0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxhYmVsSGFuZGxlKSB7XG4gICAgICAgICAgICBsYWJlbEhhbmRsZS5uYXRpdmVFbGVtZW50LnN0eWxlLmxlZnQgPSBwb3NpdGlvbkxlZnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHBvc2l0aW9uSGFuZGxlc0FuZFVwZGF0ZVRyYWNrKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNSYW5nZSkge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbkhhbmRsZSh0aGlzLnRodW1iVG8sIHRoaXMubGFiZWxUbywgdGhpcy52YWx1ZSBhcyBudW1iZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wb3NpdGlvbkhhbmRsZSh0aGlzLnRodW1iVG8sIHRoaXMubGFiZWxUbywgKHRoaXMudmFsdWUgYXMgSVJhbmdlU2xpZGVyVmFsdWUpLnVwcGVyKTtcbiAgICAgICAgICAgIHRoaXMucG9zaXRpb25IYW5kbGUodGhpcy50aHVtYkZyb20sIHRoaXMubGFiZWxGcm9tLCAodGhpcy52YWx1ZSBhcyBJUmFuZ2VTbGlkZXJWYWx1ZSkubG93ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGVUcmFjaygpO1xuICAgIH1cblxuICAgIHByaXZhdGUgY2xvc2VzdEhhbmRsZShldmVudDogUG9pbnRlckV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGZyb21PZmZzZXQgPSB0aGlzLnRodW1iRnJvbS5uYXRpdmVFbGVtZW50Lm9mZnNldExlZnQgKyB0aGlzLnRodW1iRnJvbS5uYXRpdmVFbGVtZW50Lm9mZnNldFdpZHRoIC8gMjtcbiAgICAgICAgY29uc3QgdG9PZmZzZXQgPSB0aGlzLnRodW1iVG8ubmF0aXZlRWxlbWVudC5vZmZzZXRMZWZ0ICsgdGhpcy50aHVtYlRvLm5hdGl2ZUVsZW1lbnQub2Zmc2V0V2lkdGggLyAyO1xuICAgICAgICBjb25zdCB4UG9pbnRlciA9IGV2ZW50LmNsaWVudFggLSB0aGlzLl9lbC5uYXRpdmVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdGhpcy5jbG9zZXN0VG8oeFBvaW50ZXIsIFtmcm9tT2Zmc2V0LCB0b09mZnNldF0pO1xuXG4gICAgICAgIGlmIChmcm9tT2Zmc2V0ID09PSB0b09mZnNldCAmJiB0b09mZnNldCA8IHhQb2ludGVyKSB7XG4gICAgICAgICAgICB0aGlzLnRodW1iVG8ubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICB9IGVsc2UgaWYgKGZyb21PZmZzZXQgPT09IHRvT2Zmc2V0ICYmIHRvT2Zmc2V0ID4geFBvaW50ZXIgKSB7XG4gICAgICAgICAgICB0aGlzLnRodW1iRnJvbS5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2ggPT09IGZyb21PZmZzZXQpIHtcbiAgICAgICAgICAgIHRoaXMudGh1bWJGcm9tLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudGh1bWJUby5uYXRpdmVFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcml2YXRlIHNldFRpY2tJbnRlcnZhbChsYWJlbHMpIHtcbiAgICAgICAgbGV0IGludGVydmFsO1xuICAgICAgICBjb25zdCB0cmFja1Byb2dyZXNzID0gMTAwO1xuICAgICAgICBpZiAodGhpcy5sYWJlbHNWaWV3RW5hYmxlZCkge1xuICAgICAgICAgICAgLy8gQ2FsYyB0aWNrcyBkZXBlbmRpbmcgb24gdGhlIGxhYmVscyBsZW5ndGg7XG4gICAgICAgICAgICBpbnRlcnZhbCA9ICgodHJhY2tQcm9ncmVzcyAvICh0aGlzLmxhYmVscy5sZW5ndGggLSAxKSAqIDEwKSkgLyAxMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHRyYWNrUmFuZ2UgPSB0aGlzLm1heFZhbHVlIC0gdGhpcy5taW5WYWx1ZTtcbiAgICAgICAgICAgIGludGVydmFsID0gdGhpcy5zdGVwID4gMSA/XG4gICAgICAgICAgICAgICAgKHRyYWNrUHJvZ3Jlc3MgLyAoKHRyYWNrUmFuZ2UgLyB0aGlzLnN0ZXApKSAqIDEwKSAvIDEwXG4gICAgICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcmVuZGVyQ2FsbGJhY2tFeGVjdXRpb24gPSAhdGhpcy5jb250aW51b3VzID8gdGhpcy5nZW5lcmF0ZVRpY2tNYXJrcygnd2hpdGUnLCBpbnRlcnZhbCkgOiBudWxsO1xuICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMudGlja3MubmF0aXZlRWxlbWVudCwgJ2JhY2tncm91bmQnLCByZW5kZXJDYWxsYmFja0V4ZWN1dGlvbik7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzaG93U2xpZGVySW5kaWNhdG9ycygpIHtcbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9pbmRpY2F0b3JzVGltZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2luZGljYXRvcnNEZXN0cm95ZXIkLm5leHQodHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLl9pbmRpY2F0b3JzVGltZXIgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50aHVtYlRvLnNob3dUaHVtYkluZGljYXRvcnMoKTtcbiAgICAgICAgdGhpcy5sYWJlbFRvLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLnRodW1iRnJvbSkge1xuICAgICAgICAgICAgdGhpcy50aHVtYkZyb20uc2hvd1RodW1iSW5kaWNhdG9ycygpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubGFiZWxGcm9tKSB7XG4gICAgICAgICAgICB0aGlzLmxhYmVsRnJvbS5hY3RpdmUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICB9XG5cbiAgICBwcml2YXRlIGhpZGVTbGlkZXJJbmRpY2F0b3JzKCkge1xuICAgICAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faW5kaWNhdG9yc1RpbWVyID0gdGltZXIodGhpcy50aHVtYkxhYmVsVmlzaWJpbGl0eUR1cmF0aW9uKTtcbiAgICAgICAgdGhpcy5faW5kaWNhdG9yc1RpbWVyLnBpcGUodGFrZVVudGlsKHRoaXMuX2luZGljYXRvcnNEZXN0cm95ZXIkKSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudGh1bWJUby5oaWRlVGh1bWJJbmRpY2F0b3JzKCk7XG4gICAgICAgICAgICB0aGlzLmxhYmVsVG8uYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAodGhpcy50aHVtYkZyb20pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRodW1iRnJvbS5oaWRlVGh1bWJJbmRpY2F0b3JzKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmxhYmVsRnJvbSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGFiZWxGcm9tLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHRvZ2dsZVNsaWRlckluZGljYXRvcnMoKSB7XG4gICAgICAgIHRoaXMuc2hvd1NsaWRlckluZGljYXRvcnMoKTtcbiAgICAgICAgdGhpcy5oaWRlU2xpZGVySW5kaWNhdG9ycygpO1xuICAgIH1cblxuICAgIHByaXZhdGUgY2hhbmdlVGh1bWJGb2N1c2FibGVTdGF0ZShzdGF0ZTogYm9vbGVhbikge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHN0YXRlID8gLTEgOiAxO1xuXG4gICAgICAgIGlmICh0aGlzLmlzUmFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMudGh1bWJGcm9tLnRhYmluZGV4ID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRodW1iVG8udGFiaW5kZXggPSB2YWx1ZTtcblxuICAgICAgICB0aGlzLl9jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgIH1cblxuICAgIHByaXZhdGUgY2xvc2VzdFRvKGdvYWw6IG51bWJlciwgcG9zaXRpb25zOiBudW1iZXJbXSk6IG51bWJlciB7XG4gICAgICAgIHJldHVybiBwb3NpdGlvbnMucmVkdWNlKChwcmV2aW91cywgY3VycmVudCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChNYXRoLmFicyhnb2FsIC0gY3VycmVudCkgPCBNYXRoLmFicyhnb2FsIC0gcHJldmlvdXMpID8gY3VycmVudCA6IHByZXZpb3VzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB2YWx1ZVRvRnJhY3Rpb24odmFsdWU6IG51bWJlciwgcE1pbiA9IHRoaXMuX3BNaW4sIHBNYXggPSB0aGlzLl9wTWF4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlSW5SYW5nZSgodmFsdWUgLSB0aGlzLm1pblZhbHVlKSAvICh0aGlzLm1heFZhbHVlIC0gdGhpcy5taW5WYWx1ZSksIHBNaW4sIHBNYXgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBOb3JtYWxpetC1IHRoZSB2YWx1ZSB3aGVuIHR3by13YXkgZGF0YSBiaW5kIGlzIHVzZWQgYW5kIHtAbGluayB0aGlzLnN0ZXB9IGlzIHNldC5cbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKi9cbiAgICBwcml2YXRlIG5vcm1hbGl6ZUJ5U3RlcCh2YWx1ZTogSVJhbmdlU2xpZGVyVmFsdWUgfCBudW1iZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNSYW5nZSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZSA9ICB7XG4gICAgICAgICAgICAgICAgbG93ZXI6ICh2YWx1ZSBhcyBJUmFuZ2VTbGlkZXJWYWx1ZSkubG93ZXIgLSAoKHZhbHVlIGFzIElSYW5nZVNsaWRlclZhbHVlKS5sb3dlciAlIHRoaXMuc3RlcCksXG4gICAgICAgICAgICAgICAgdXBwZXI6ICh2YWx1ZSBhcyBJUmFuZ2VTbGlkZXJWYWx1ZSkudXBwZXIgLSAoKHZhbHVlIGFzIElSYW5nZVNsaWRlclZhbHVlKS51cHBlciAlIHRoaXMuc3RlcClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gKHZhbHVlIGFzIG51bWJlcikgLSAoKHZhbHVlIGFzIG51bWJlcikgJSB0aGlzLnN0ZXApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVUcmFjaygpIHtcbiAgICAgICAgY29uc3QgZnJvbVBvc2l0aW9uID0gdGhpcy52YWx1ZVRvRnJhY3Rpb24odGhpcy5sb3dlclZhbHVlKTtcbiAgICAgICAgY29uc3QgdG9Qb3NpdGlvbiA9IHRoaXMudmFsdWVUb0ZyYWN0aW9uKHRoaXMudXBwZXJWYWx1ZSk7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uR2FwID0gdG9Qb3NpdGlvbiAtIGZyb21Qb3NpdGlvbjtcblxuICAgICAgICBsZXQgdHJhY2tMZWZ0SW5kZW50aW9uID0gZnJvbVBvc2l0aW9uO1xuICAgICAgICBpZiAodGhpcy5pc1JhbmdlKSB7XG4gICAgICAgICAgICBpZiAocG9zaXRpb25HYXApIHtcbiAgICAgICAgICAgICAgICB0cmFja0xlZnRJbmRlbnRpb24gPSBNYXRoLnJvdW5kKCgxIC8gcG9zaXRpb25HYXAgKiBmcm9tUG9zaXRpb24pICogMTAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRTdHlsZSh0aGlzLnRyYWNrLm5hdGl2ZUVsZW1lbnQsICd0cmFuc2Zvcm0nLCBgc2NhbGVYKCR7cG9zaXRpb25HYXB9KSB0cmFuc2xhdGVYKCR7dHJhY2tMZWZ0SW5kZW50aW9ufSUpYCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHRoaXMudHJhY2submF0aXZlRWxlbWVudCwgJ3RyYW5zZm9ybScsIGBzY2FsZVgoJHt0b1Bvc2l0aW9ufSlgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgdmFsaWRhdGVJbml0aWFsVmFsdWUodmFsdWU6IElSYW5nZVNsaWRlclZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZS5sb3dlciA8IHRoaXMubG93ZXJCb3VuZCAmJiB2YWx1ZS51cHBlciA8IHRoaXMubG93ZXJCb3VuZCkge1xuICAgICAgICAgICAgdmFsdWUudXBwZXIgPSB0aGlzLmxvd2VyQm91bmQ7XG4gICAgICAgICAgICB2YWx1ZS5sb3dlciA9IHRoaXMubG93ZXJCb3VuZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZS5sb3dlciA+IHRoaXMudXBwZXJCb3VuZCAmJiB2YWx1ZS51cHBlciA+IHRoaXMudXBwZXJCb3VuZCkge1xuICAgICAgICAgICAgdmFsdWUudXBwZXIgPSB0aGlzLnVwcGVyQm91bmQ7XG4gICAgICAgICAgICB2YWx1ZS5sb3dlciA9IHRoaXMudXBwZXJCb3VuZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZS51cHBlciA8IHZhbHVlLmxvd2VyKSB7XG4gICAgICAgICAgICB2YWx1ZS51cHBlciA9IHRoaXMudXBwZXJWYWx1ZTtcbiAgICAgICAgICAgIHZhbHVlLmxvd2VyID0gdGhpcy5sb3dlclZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIHByaXZhdGUgc3Vic2NyaWJlVG8odGh1bWI6IElneFNsaWRlclRodW1iQ29tcG9uZW50LCBjYWxsYmFjazogKGE6IG51bWJlciwgYjogbnVtYmVyKSA9PiB2b2lkKSB7XG4gICAgICAgIGlmICghdGh1bWIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRodW1iLm9uVGh1bWJWYWx1ZUNoYW5nZVxuICAgICAgICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMudW5zdWJzY3JpYmVyKHRodW1iKSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKHZhbHVlID0+IGNhbGxiYWNrKHZhbHVlLCB0aHVtYi50eXBlKSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1bnN1YnNjcmliZXIodGh1bWI6IElneFNsaWRlclRodW1iQ29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybiBtZXJnZSh0aGlzLl9kZXN0cm95ZXIkLCB0aHVtYi5kZXN0cm95KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGhhc1ZhbHVlQ2hhbmdlZChvbGRWYWx1ZSkge1xuICAgICAgICBjb25zdCBpc1NsaWRlcldpdGhEaWZmZXJlbnRWYWx1ZTogYm9vbGVhbiA9ICF0aGlzLmlzUmFuZ2UgJiYgb2xkVmFsdWUgIT09IHRoaXMudmFsdWU7XG4gICAgICAgIGNvbnN0IGlzUmFuZ2VXaXRoT25lRGlmZmVyZW50VmFsdWU6IGJvb2xlYW4gPSB0aGlzLmlzUmFuZ2UgJiZcbiAgICAgICAgICAgICgob2xkVmFsdWUgYXMgSVJhbmdlU2xpZGVyVmFsdWUpLmxvd2VyICE9PSAodGhpcy52YWx1ZSBhcyBJUmFuZ2VTbGlkZXJWYWx1ZSkubG93ZXIgfHxcbiAgICAgICAgICAgICAgICAob2xkVmFsdWUgYXMgSVJhbmdlU2xpZGVyVmFsdWUpLnVwcGVyICE9PSAodGhpcy52YWx1ZSBhcyBJUmFuZ2VTbGlkZXJWYWx1ZSkudXBwZXIpO1xuXG4gICAgICAgIHJldHVybiBpc1NsaWRlcldpdGhEaWZmZXJlbnRWYWx1ZSB8fCBpc1JhbmdlV2l0aE9uZURpZmZlcmVudFZhbHVlO1xuICAgIH1cblxuICAgIHByaXZhdGUgZW1pdFZhbHVlQ2hhbmdlZChvbGRWYWx1ZTogbnVtYmVyIHwgSVJhbmdlU2xpZGVyVmFsdWUpIHtcbiAgICAgICAgdGhpcy5vblZhbHVlQ2hhbmdlLmVtaXQoeyBvbGRWYWx1ZSwgdmFsdWU6IHRoaXMudmFsdWUgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuQE5nTW9kdWxlKHtcbiAgICBkZWNsYXJhdGlvbnM6IFtcbiAgICAgICAgSWd4U2xpZGVyQ29tcG9uZW50LFxuICAgICAgICBJZ3hUaHVtYkZyb21UZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICAgICAgSWd4VGh1bWJUb1RlbXBsYXRlRGlyZWN0aXZlLFxuICAgICAgICBJZ3hTbGlkZXJUaHVtYkNvbXBvbmVudCxcbiAgICAgICAgSWd4VGh1bWJMYWJlbENvbXBvbmVudF0sXG4gICAgZXhwb3J0czogW1xuICAgICAgICBJZ3hTbGlkZXJDb21wb25lbnQsXG4gICAgICAgIElneFRodW1iRnJvbVRlbXBsYXRlRGlyZWN0aXZlLFxuICAgICAgICBJZ3hUaHVtYlRvVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgICAgIElneFNsaWRlclRodW1iQ29tcG9uZW50LFxuICAgICAgICBJZ3hUaHVtYkxhYmVsQ29tcG9uZW50XSxcbiAgICBpbXBvcnRzOiBbQ29tbW9uTW9kdWxlXVxufSlcbmV4cG9ydCBjbGFzcyBJZ3hTbGlkZXJNb2R1bGUge1xufVxuIl19