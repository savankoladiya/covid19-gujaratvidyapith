/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { transition, trigger, useAnimation } from '@angular/animations';
import { Component, ContentChild, forwardRef, HostBinding, HostListener, Input, ViewChild, ElementRef, ViewChildren, QueryList } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { fadeIn, scaleInCenter, slideInLeft, slideInRight } from '../animations/main';
import { IgxCalendarHeaderTemplateDirective, IgxCalendarSubheaderTemplateDirective } from './calendar.directives';
import { monthRange } from './calendar';
import { CalendarView, IgxMonthPickerBase } from './month-picker-base';
import { IgxMonthsViewComponent } from './months-view/months-view.component';
import { IgxYearsViewComponent } from './years-view/years-view.component';
import { IgxDaysViewComponent } from './days-view/days-view.component';
import { interval } from 'rxjs';
import { takeUntil, debounce, skipLast, switchMap } from 'rxjs/operators';
import { ScrollMonth } from './calendar-base';
/** @type {?} */
let NEXT_ID = 0;
/**
 * Calendar provides a way to display date information.
 *
 * \@igxModule IgxCalendarModule
 *
 * \@igxTheme igx-calendar-theme, igx-icon-theme
 *
 * \@igxKeywords calendar, datepicker, schedule, date
 *
 * \@igxGroup Scheduling
 *
 * \@remarks
 * The Ignite UI Calendar provides an easy way to display a calendar and allow users to select dates using single, multiple
 * or range selection.
 *
 * \@example:
 * ```html
 * <igx-calendar selection="range"></igx-calendar>
 * ```
 */
export class IgxCalendarComponent extends IgxMonthPickerBase {
    constructor() {
        super(...arguments);
        /**
         * Sets/gets the `id` of the calendar.
         *
         * \@remarks
         * If not set, the `id` will have value `"igx-calendar-0"`.
         *
         * \@example
         * ```html
         * <igx-calendar id="my-first-calendar"></igx-calendar>
         * ```
         * \@memberof IgxCalendarComponent
         */
        this.id = `igx-calendar-${NEXT_ID++}`;
        /**
         * Sets/gets whether the calendar has header.
         * Default value is `true`.
         *
         * \@example
         * ```html
         * <igx-calendar [hasHeader]="false"></igx-calendar>
         * ```
         */
        this.hasHeader = true;
        /**
         * Sets/gets whether the calendar header will be in vertical position.
         * Default value is `false`.
         *
         * \@example
         * ```html
         * <igx-calendar [vertical] = "true"></igx-calendar>
         * ```
         */
        this.vertical = false;
        /**
         * Apply the different states for the transitions of animateChange
         * @hidden
         * \@internal
         */
        this.animationAction = '';
        /**
         * Denote if the calendar view was changed with the keyboard
         *
         * @hidden
         * \@internal
         */
        this.isKeydownTrigger = false;
        /**
         * The default `tabindex` attribute for the component.
         *
         * @hidden
         * \@internal
         */
        this.tabindex = 0;
        /**
         * The default aria role attribute for the component.
         *
         * @hidden
         * \@internal
         */
        this.role = 'grid';
        /**
         * The default aria lebelled by attribute for the component.
         *
         * @hidden
         * \@internal
         */
        this.ariaLabelledBy = 'calendar';
        /**
         * The default css class applied to the component.
         *
         * @hidden
         * \@internal
         */
        this.styleClass = true;
        /**
         * @hidden
         * \@internal
         */
        this._monthsViewNumber = 1;
        /**
         * Continious navigation through the previous months
         * @hidden
         * \@internal
         */
        this.startPrevMonthScroll = (isKeydownTrigger = false) => {
            this.startMonthScroll$.next();
            this.monthScrollDirection = ScrollMonth.PREV;
            this.previousMonth(isKeydownTrigger);
        };
        /**
         * Continious navigation through the next months
         * @hidden
         * \@internal
         */
        this.startNextMonthScroll = (isKeydownTrigger = false) => {
            this.startMonthScroll$.next();
            this.monthScrollDirection = ScrollMonth.NEXT;
            this.nextMonth(isKeydownTrigger);
        };
        /**
         * Stop continuous navigation
         * @hidden
         * \@internal
         */
        this.stopMonthScroll = (event) => {
            event.stopPropagation();
            // generally the scrolling is built on the calendar component
            // and all start/stop scrolling methods are called on the calendar
            // if we change below lines to call stopMonthScroll$ on the calendar instead of on the views,
            // strange bug is introduced --> after changing number of months, continuous scrolling on mouse click does not happen
            this.daysView.stopMonthScroll$.next(true);
            this.daysView.stopMonthScroll$.complete();
            if (this.monthScrollDirection === ScrollMonth.PREV) {
                this.prevMonthBtn.nativeElement.focus();
            }
            else if (this.monthScrollDirection === ScrollMonth.NEXT) {
                this.nextMonthBtn.nativeElement.focus();
            }
            this.monthScrollDirection = ScrollMonth.NONE;
        };
    }
    /**
     * Sets/gets the number of month views displayed.
     * Default value is `1`.
     *
     * \@example
     * ```html
     * <igx-calendar [monthsViewNumber]="2"></igx-calendar>
     * ```
     * @return {?}
     */
    get monthsViewNumber() {
        return this._monthsViewNumber;
    }
    /**
     * @param {?} val
     * @return {?}
     */
    set monthsViewNumber(val) {
        if (val < 1) {
            return;
        }
        this._monthsViewNumber = val;
    }
    /**
     * The default css class applied to the component.
     *
     * @hidden
     * \@internal
     * @return {?}
     */
    get styleVerticalClass() {
        return this.vertical;
    }
    /**
     * Denote if the year view is active.
     * @hidden
     * \@internal
     * @return {?}
     */
    get isYearView() {
        return this.activeView === CalendarView.YEAR;
    }
    /**
     * Gets the header template.
     *
     * \@example
     * ```typescript
     * let headerTemplate =  this.calendar.headerTeamplate;
     * ```
     * \@memberof IgxCalendarComponent
     * @return {?}
     */
    get headerTemplate() {
        if (this.headerTemplateDirective) {
            return this.headerTemplateDirective.template;
        }
        return null;
    }
    /**
     * Sets the header template.
     *
     * \@example
     * ```html
     * <igx-calendar headerTemplateDirective = "igxCalendarHeader"></igx-calendar>
     * ```
     * \@memberof IgxCalendarComponent
     * @param {?} directive
     * @return {?}
     */
    set headerTemplate(directive) {
        this.headerTemplateDirective = directive;
    }
    /**
     * Gets the subheader template.
     *
     * \@example
     * ```typescript
     * let subheaderTemplate = this.calendar.subheaderTemplate;
     * ```
     * @return {?}
     */
    get subheaderTemplate() {
        if (this.subheaderTemplateDirective) {
            return this.subheaderTemplateDirective.template;
        }
        return null;
    }
    /**
     * Sets the subheader template.
     *
     * \@example
     * ```html
     * <igx-calendar subheaderTemplate = "igxCalendarSubheader"></igx-calendar>
     * ```
     * \@memberof IgxCalendarComponent
     * @param {?} directive
     * @return {?}
     */
    set subheaderTemplate(directive) {
        this.subheaderTemplateDirective = directive;
    }
    /**
     * Gets the context for the template marked with the `igxCalendarHeader` directive.
     *
     * \@example
     * ```typescript
     * let headerContext =  this.calendar.headerContext;
     * ```
     * @return {?}
     */
    get headerContext() {
        /** @type {?} */
        const date = this.headerDate;
        return this.generateContext(date);
    }
    /**
     * Gets the context for the template marked with either `igxCalendarSubHeaderMonth`
     * or `igxCalendarSubHeaderYear` directive.
     *
     * \@example
     * ```typescript
     * let context =  this.calendar.context;
     * ```
     * @return {?}
     */
    get context() {
        /** @type {?} */
        const date = this.viewDate;
        return this.generateContext(date);
    }
    /**
     * Date displayed in header
     *
     * @hidden
     * \@internal
     * @return {?}
     */
    get headerDate() {
        return this.selectedDates ? this.selectedDates : new Date();
    }
    /**
     * @return {?}
     */
    ngAfterViewInit() {
        this.setSiblingMonths(this.monthViews);
        this._monthViewsChanges$ = this.monthViews.changes.subscribe(c => {
            this.setSiblingMonths(c);
        });
        this.startMonthScroll$.pipe(takeUntil(this.stopMonthScroll$), switchMap(() => this.scrollMonth$.pipe(skipLast(1), debounce(() => interval(300)), takeUntil(this.stopMonthScroll$)))).subscribe(() => {
            switch (this.monthScrollDirection) {
                case ScrollMonth.PREV:
                    this.previousMonth();
                    break;
                case ScrollMonth.NEXT:
                    this.nextMonth();
                    break;
                case ScrollMonth.NONE:
                default:
                    break;
            }
        });
    }
    /**
     * Returns the locale representation of the month in the month view if enabled,
     * otherwise returns the default `Date.getMonth()` value.
     *
     * @hidden
     * \@internal
     * @param {?} value
     * @return {?}
     */
    formattedMonth(value) {
        if (this.formatViews.month) {
            return this.formatterMonth.format(value);
        }
        return `${value.getMonth()}`;
    }
    /**
     * Change to previous month
     *
     * @hidden
     * \@internal
     * @param {?=} isKeydownTrigger
     * @return {?}
     */
    previousMonth(isKeydownTrigger = false) {
        this.viewDate = this.calendarModel.getPrevMonth(this.viewDate);
        this.animationAction = ScrollMonth.PREV;
        this.isKeydownTrigger = isKeydownTrigger;
    }
    /**
     * Change to next month
     *
     * @hidden
     * \@internal
     * @param {?=} isKeydownTrigger
     * @return {?}
     */
    nextMonth(isKeydownTrigger = false) {
        this.viewDate = this.calendarModel.getNextMonth(this.viewDate);
        this.animationAction = ScrollMonth.NEXT;
        this.isKeydownTrigger = isKeydownTrigger;
    }
    /**
     * @hidden
     * \@internal
     * @param {?} args
     * @param {?} activeViewIdx
     * @return {?}
     */
    onActiveViewDecade(args, activeViewIdx) {
        super.activeViewDecade(activeViewIdx);
        requestAnimationFrame(() => {
            if (this.dacadeView) {
                this.dacadeView.date = args;
                this.dacadeView.el.nativeElement.focus();
            }
        });
    }
    /**
     * @hidden
     * \@internal
     * @param {?} event
     * @param {?} args
     * @param {?} activeViewIdx
     * @return {?}
     */
    onActiveViewDecadeKB(event, args, activeViewIdx) {
        super.activeViewDecadeKB(event, activeViewIdx);
        requestAnimationFrame(() => {
            if (this.dacadeView) {
                this.dacadeView.date = args;
                this.dacadeView.el.nativeElement.focus();
            }
        });
    }
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    getFormattedDate() {
        /** @type {?} */
        const date = this.headerDate;
        return {
            monthday: this.formatterMonthday.format(date),
            weekday: this.formatterWeekday.format(date),
        };
    }
    /**
     * Handles invoked on date selection
     * @hidden
     * \@internal
     * @param {?} instance
     * @return {?}
     */
    childClicked(instance) {
        if (instance.isPrevMonth) {
            this.previousMonth();
        }
        if (instance.isNextMonth) {
            this.nextMonth();
        }
        this.selectDateFromClient(instance.date);
        if (this.selection === 'multi') {
            this.deselectDateInMonthViews(instance.date);
        }
        this.onSelection.emit(this.selectedDates);
    }
    /**
     * @hidden
     * \@internal
     * @param {?} args
     * @return {?}
     */
    viewChanging(args) {
        this.animationAction = args.monthAction;
        this.isKeydownTrigger = true;
        this.nextDate = args.nextDate;
        this.callback = (next) => {
            /** @type {?} */
            const day = this.daysView.dates.find((item) => item.date.date.getTime() === next.getTime());
            if (day) {
                this.daysView.daysNavService.focusNextDate(day.nativeElement, args.key, true);
            }
        };
        this.viewDate = this.nextDate;
    }
    /**
     * @hidden
     * \@intenal
     * @param {?} event
     * @return {?}
     */
    changeMonth(event) {
        this.viewDate = this.calendarModel.getFirstViewDate(event, 'month', this.activeViewIdx);
        this.activeView = CalendarView.DEFAULT;
        requestAnimationFrame(() => {
            /** @type {?} */
            const elem = this.monthsBtns.find((e, idx) => idx === this.activeViewIdx);
            if (elem) {
                elem.nativeElement.focus();
            }
        });
    }
    /**
     * @hidden
     * \@internal
     * @param {?} args
     * @param {?} activeViewIdx
     * @param {?=} event
     * @return {?}
     */
    onActiveViewYear(args, activeViewIdx, event) {
        this.activeView = CalendarView.YEAR;
        this.activeViewIdx = activeViewIdx;
        requestAnimationFrame(() => {
            this.monthsView.date = args;
            this.focusMonth(event.target);
        });
    }
    /**
     * @private
     * @param {?} target
     * @return {?}
     */
    focusMonth(target) {
        /** @type {?} */
        const month = this.monthsView.monthsRef.find((e) => e.index === parseInt(target.parentElement.attributes['data-month'].value, 10));
        if (month) {
            month.nativeElement.focus();
        }
    }
    /**
     * @hidden
     * \@internal
     * @param {?} args
     * @param {?} event
     * @param {?} activeViewIdx
     * @return {?}
     */
    onActiveViewYearKB(args, event, activeViewIdx) {
        if (event.key === " " /* SPACE */ || event.key === "Spacebar" /* SPACE_IE */ || event.key === "Enter" /* ENTER */) {
            event.preventDefault();
            this.onActiveViewYear(args, activeViewIdx, event);
        }
    }
    /**
     * Deselects date(s) (based on the selection type).
     *
     * \@example
     * ```typescript
     * this.calendar.deselectDate(new Date(`2018-06-12`));
     * ````
     * @param {?=} value
     * @return {?}
     */
    deselectDate(value) {
        super.deselectDate(value);
        this.monthViews.forEach((view) => {
            view.selectedDates = this.selectedDates;
            view.rangeStarted = false;
        });
        this._onChangeCallback(this.selectedDates);
    }
    /**
     * Helper method that does deselection for all month views when selection is "multi"
     * If not called, selection in other month views stays
     * @hidden
     * \@internal
     * @private
     * @param {?} value
     * @return {?}
     */
    deselectDateInMonthViews(value) {
        this.monthViews.forEach(m => {
            m.deselectMultipleInMonth(value);
        });
    }
    /**
     * @hidden
     * \@internal
     * @param {?} i
     * @return {?}
     */
    getViewDate(i) {
        /** @type {?} */
        const date = this.calendarModel.timedelta(this.viewDate, 'month', i);
        return date;
    }
    /**
     * Getter for the context object inside the calendar templates.
     * @hidden
     * \@internal
     * @param {?} i
     * @return {?}
     */
    getContext(i) {
        /** @type {?} */
        const date = this.getViewDate(i);
        return this.generateContext(date, i);
    }
    /**
     * @hidden
     * \@internal
     * @param {?} event
     * @return {?}
     */
    animationDone(event) {
        if (this.monthScrollDirection !== ScrollMonth.NONE) {
            this.scrollMonth$.next();
        }
        if (this.activeView !== CalendarView.DEFAULT) {
            return;
        }
        /** @type {?} */
        let monthView = (/** @type {?} */ (this.daysView));
        /** @type {?} */
        let date = monthView.dates.find((d) => d.selected);
        while (!date && monthView.nextMonthView) {
            monthView = monthView.nextMonthView;
            date = monthView.dates.find((d) => d.selected);
        }
        if (date && date.isFocusable && !this.isKeydownTrigger) {
            setTimeout(() => {
                date.nativeElement.focus();
            }, parseInt(slideInRight.options.params.duration, 10));
        }
        else if (this.callback && (event.toState === ScrollMonth.NEXT || event.toState === ScrollMonth.PREV)) {
            this.callback(this.nextDate);
        }
        this.animationAction = ScrollMonth.NONE;
    }
    /**
     * Keyboard navigation of the calendar
     * @hidden
     * \@internal
     * @param {?} event
     * @return {?}
     */
    onKeydownPageDown(event) {
        event.preventDefault();
        if (this.activeView !== CalendarView.DEFAULT) {
            return;
        }
        /** @type {?} */
        const isPageDown = event.key === 'PageDown';
        /** @type {?} */
        const step = isPageDown ? 1 : -1;
        /** @type {?} */
        let monthView = (/** @type {?} */ (this.daysView));
        /** @type {?} */
        let activeDate;
        while (!activeDate && monthView) {
            activeDate = monthView.dates.find((date) => date.nativeElement === document.activeElement);
            monthView = monthView.nextMonthView;
        }
        if (activeDate) {
            this.nextDate = new Date(activeDate.date.date);
            /** @type {?} */
            let year = this.nextDate.getFullYear();
            /** @type {?} */
            let month = this.nextDate.getMonth() + step;
            if (isPageDown) {
                if (month > 11) {
                    month = 0;
                    year += step;
                }
            }
            else {
                if (month < 0) {
                    month = 11;
                    year += step;
                }
            }
            /** @type {?} */
            const range = monthRange(this.nextDate.getFullYear(), month);
            /** @type {?} */
            let day = this.nextDate.getDate();
            if (day > range[1]) {
                day = range[1];
            }
            this.nextDate.setDate(day);
            this.nextDate.setMonth(month);
            this.nextDate.setFullYear(year);
            this.callback = (next) => {
                monthView = (/** @type {?} */ (this.daysView));
                /** @type {?} */
                let dayItem;
                while ((!dayItem && monthView) || (dayItem && !dayItem.isCurrentMonth)) {
                    dayItem = monthView.dates.find((d) => d.date.date.getTime() === next.getTime());
                    monthView = monthView.nextMonthView;
                }
                if (dayItem && dayItem.isFocusable) {
                    dayItem.nativeElement.focus();
                }
            };
        }
        if (isPageDown) {
            this.nextMonth(true);
        }
        else {
            this.previousMonth(true);
        }
    }
    /**
     * Keyboard navigation of the calendar
     * @hidden
     * \@internal
     * @param {?} event
     * @return {?}
     */
    onKeydownShiftPageUp(event) {
        event.preventDefault();
        if (this.activeView !== CalendarView.DEFAULT) {
            return;
        }
        /** @type {?} */
        const isPageDown = event.key === 'PageDown';
        /** @type {?} */
        const step = isPageDown ? 1 : -1;
        this.viewDate = this.calendarModel.timedelta(this.viewDate, 'year', step);
        this.animationAction = isPageDown ? ScrollMonth.NEXT : ScrollMonth.PREV;
        this.isKeydownTrigger = true;
        /** @type {?} */
        let monthView = (/** @type {?} */ (this.daysView));
        /** @type {?} */
        let activeDate;
        while (!activeDate && monthView) {
            activeDate = monthView.dates.find((date) => date.nativeElement === document.activeElement);
            monthView = monthView.nextMonthView;
        }
        if (activeDate) {
            this.nextDate = new Date(activeDate.date.date);
            /** @type {?} */
            const year = this.nextDate.getFullYear() + step;
            /** @type {?} */
            const range = monthRange(year, this.nextDate.getMonth());
            /** @type {?} */
            let day = this.nextDate.getDate();
            if (day > range[1]) {
                day = range[1];
            }
            this.nextDate.setDate(day);
            this.nextDate.setFullYear(year);
            this.callback = (next) => {
                monthView = (/** @type {?} */ (this.daysView));
                /** @type {?} */
                let dayItem;
                while ((!dayItem && monthView) || (dayItem && !dayItem.isCurrentMonth)) {
                    dayItem = monthView.dates.find((d) => d.date.date.getTime() === next.getTime());
                    monthView = monthView.nextMonthView;
                }
                if (dayItem && dayItem.isFocusable) {
                    dayItem.nativeElement.focus();
                }
            };
        }
    }
    /**
     * Keyboard navigation of the calendar
     * @hidden
     * \@internal
     * @param {?} event
     * @return {?}
     */
    onKeydownHome(event) {
        if (this.daysView) {
            this.daysView.onKeydownHome(event);
        }
    }
    /**
     * Keyboard navigation of the calendar
     * @hidden
     * \@internal
     * @param {?} event
     * @return {?}
     */
    onKeydownEnd(event) {
        if (this.daysView) {
            this.daysView.onKeydownEnd(event);
        }
    }
    /**
     * Stop continuous navigation on mouseup event
     * @hidden
     * \@internal
     * @param {?} event
     * @return {?}
     */
    onMouseUp(event) {
        if (this.monthScrollDirection !== ScrollMonth.NONE) {
            this.stopMonthScroll(event);
        }
    }
    /**
     * @hidden
     * \@internal
     * @return {?}
     */
    ngOnDestroy() {
        if (this._monthViewsChanges$) {
            this._monthViewsChanges$.unsubscribe();
        }
    }
    /**
     * Helper method building and returning the context object inside
     * the calendar templates.
     * @hidden
     * \@internal
     * @private
     * @param {?} value
     * @param {?=} i
     * @return {?}
     */
    generateContext(value, i) {
        /** @type {?} */
        const formatObject = Object.assign({ index: i, monthView: () => this.onActiveViewYear(value, i), yearView: () => this.onActiveViewDecade(value, i) }, this.calendarModel.formatToParts(value, this.locale, this.formatOptions, ['era', 'year', 'month', 'day', 'weekday']));
        return { $implicit: formatObject };
    }
    /**
     * Helper method that sets references for prev/next months for each month in the view
     * @hidden
     * \@internal
     * @private
     * @param {?} monthViews
     * @return {?}
     */
    setSiblingMonths(monthViews) {
        monthViews.forEach((item, index) => {
            /** @type {?} */
            const prevMonthView = this.getMonthView(index - 1);
            /** @type {?} */
            const nextMonthView = this.getMonthView(index + 1);
            item.nextMonthView = nextMonthView;
            item.prevMonthView = prevMonthView;
        });
    }
    /**
     * Helper method returning previous/next day views
     * @hidden
     * \@internal
     * @private
     * @param {?} index
     * @return {?}
     */
    getMonthView(index) {
        if (index === -1 || index === this.monthViews.length) {
            return null;
        }
        else {
            return this.monthViews.toArray()[index];
        }
    }
}
IgxCalendarComponent.decorators = [
    { type: Component, args: [{
                providers: [
                    {
                        multi: true,
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: IgxCalendarComponent
                    }
                ],
                animations: [
                    trigger('animateView', [
                        transition('void => 0', useAnimation(fadeIn)),
                        transition('void => *', useAnimation(scaleInCenter, {
                            params: {
                                duration: '.2s',
                                fromScale: .9
                            }
                        }))
                    ]),
                    trigger('animateChange', [
                        transition('* => prev', useAnimation(slideInLeft, {
                            params: {
                                fromPosition: 'translateX(-30%)'
                            }
                        })),
                        transition('* => next', useAnimation(slideInRight, {
                            params: {
                                fromPosition: 'translateX(30%)'
                            }
                        }))
                    ])
                ],
                selector: 'igx-calendar',
                template: "<ng-template let-result #defaultHeader>\n    <span>{{ getFormattedDate().weekday }},&nbsp;</span>\n    <span>{{ getFormattedDate().monthday }}</span>\n</ng-template>\n\n<ng-template let-result #defaultMonth let-obj>\n    <span tabindex=\"0\" #monthsBtn (keydown)=\"onActiveViewYearKB(getViewDate(obj.index), $event, obj.index)\" (click)=\"onActiveViewYear(getViewDate(obj.index), obj.index, $event)\"\n        class=\"igx-calendar-picker__date\">\n        {{ formattedMonth(getViewDate(obj.index)) }}\n    </span>\n    <span tabindex=\"0\" #yearsBtn (keydown)=\"onActiveViewDecadeKB($event, getViewDate(obj.index), obj.index)\" (click)=\"onActiveViewDecade(getViewDate(obj.index), obj.index)\"\n        class=\"igx-calendar-picker__date\">\n        {{ formattedYear(getViewDate(obj.index)) }}\n    </span>\n</ng-template>\n\n<div *ngIf=\"selection === 'single' && hasHeader\" class=\"igx-calendar__header\">\n    <h5 class=\"igx-calendar__header-year\">{{ formattedYear(headerDate) }}</h5>\n    <h2 class=\"igx-calendar__header-date\">\n        <ng-container *ngTemplateOutlet=\"headerTemplate ? headerTemplate : defaultHeader; context: headerContext\">\n        </ng-container>\n    </h2>\n</div>\n\n<div *ngIf=\"isDefaultView\" class=\"igx-calendar__body\" [@animateView]=\"activeView\" (swiperight)=\"previousMonth()\"\n    (swipeleft)=\"nextMonth()\">\n    <div class=\"igx-calendar-picker\">\n        <div tabindex=\"0\" class=\"igx-calendar-picker__prev\" #prevMonthBtn\n            igxCalendarScrollMonth [startScroll]=\"startPrevMonthScroll\" [stopScroll]=\"stopMonthScroll\"  [ngStyle]=\"{\n                    'min-width.%': 100/(monthsViewNumber*7)\n                }\">\n            <igx-icon fontSet=\"material\">keyboard_arrow_left</igx-icon>\n        </div>\n        <div class=\"igx-calendar-picker__dates\" *ngFor=\"let view of monthsViewNumber | IgxMonthViewSlots; index as i;\" [style.width.%]=\"100/monthsViewNumber\" [attr.data-month]=\"i | IgxGetViewDate:viewDate:false\">\n            <ng-container *ngTemplateOutlet=\"subheaderTemplate ? subheaderTemplate : defaultMonth; context: getContext(i)\">\n            </ng-container>\n        </div>\n        <div tabindex=\"0\" class=\"igx-calendar-picker__next\" #nextMonthBtn\n            igxCalendarScrollMonth [startScroll]=\"startNextMonthScroll\" [stopScroll]=\"stopMonthScroll\" [ngStyle]=\"{\n                    'min-width.%': 100/(monthsViewNumber*7)\n                }\">\n            <igx-icon fontSet=\"material\">keyboard_arrow_right</igx-icon>\n        </div>\n    </div>\n\n    <div style=\"display: flex\"\n        [@animateChange]=\"animationAction\"\n        (@animateChange.done)=\"animationDone($event)\">\n        <igx-days-view *ngFor=\"let view of monthsViewNumber | IgxMonthViewSlots; index as i;\" [changeDaysView]=\"true\" #days\n                [selection]=\"selection\"\n                [locale]=\"locale\"\n                [value]=\"value\"\n                [viewDate]=\"i | IgxGetViewDate:viewDate\"\n                [weekStart]=\"weekStart\"\n                [formatOptions]=\"formatOptions\"\n                [formatViews]=\"formatViews\"\n                [disabledDates]=\"disabledDates\"\n                [specialDates]=\"specialDates\"\n                [hideOutsideDays]=\"hideOutsideDays\"\n                (onViewChanging)=\"viewChanging($event)\"\n                (onDateSelection)=\"childClicked($event)\">\n        </igx-days-view>\n    </div>\n</div>\n\n<igx-months-view *ngIf=\"isYearView\" [@animateView]=\"activeView\" #months\n                 [date]=\"viewDate\"\n                 [locale]=\"locale\"\n                 [formatView]=\"formatViews.month\"\n                 [monthFormat]=\"formatOptions.month\"\n                 (onSelection)=\"changeMonth($event)\">\n</igx-months-view>\n\n<igx-years-view *ngIf=\"isDecadeView\" [@animateView]=\"activeView\" #decade\n                [date]=\"viewDate\"\n                [locale]=\"locale\"\n                [formatView]=\"formatViews.year\"\n                [yearFormat]=\"formatOptions.year\"\n                (onSelection)=\"changeYear($event)\">\n</igx-years-view>\n"
            }] }
];
IgxCalendarComponent.propDecorators = {
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    hasHeader: [{ type: Input }],
    vertical: [{ type: Input }],
    monthsViewNumber: [{ type: Input }],
    animationAction: [{ type: Input }],
    tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    ariaLabelledBy: [{ type: HostBinding, args: ['attr.aria-labelledby',] }],
    styleVerticalClass: [{ type: HostBinding, args: ['class.igx-calendar--vertical',] }],
    styleClass: [{ type: HostBinding, args: ['class.igx-calendar',] }],
    monthsView: [{ type: ViewChild, args: ['months', { read: IgxMonthsViewComponent, static: false },] }],
    monthsBtns: [{ type: ViewChildren, args: ['monthsBtn',] }],
    dacadeView: [{ type: ViewChild, args: ['decade', { read: IgxYearsViewComponent, static: false },] }],
    daysView: [{ type: ViewChild, args: ['days', { read: IgxDaysViewComponent, static: false },] }],
    monthViews: [{ type: ViewChildren, args: ['days', { read: IgxDaysViewComponent },] }],
    prevMonthBtn: [{ type: ViewChild, args: ['prevMonthBtn', { static: false },] }],
    nextMonthBtn: [{ type: ViewChild, args: ['nextMonthBtn', { static: false },] }],
    headerTemplateDirective: [{ type: ContentChild, args: [forwardRef(() => IgxCalendarHeaderTemplateDirective), { read: IgxCalendarHeaderTemplateDirective, static: true },] }],
    subheaderTemplateDirective: [{ type: ContentChild, args: [forwardRef(() => IgxCalendarSubheaderTemplateDirective), { read: IgxCalendarSubheaderTemplateDirective, static: true },] }],
    onKeydownPageDown: [{ type: HostListener, args: ['keydown.pagedown', ['$event'],] }, { type: HostListener, args: ['keydown.pageup', ['$event'],] }],
    onKeydownShiftPageUp: [{ type: HostListener, args: ['keydown.shift.pageup', ['$event'],] }, { type: HostListener, args: ['keydown.shift.pagedown', ['$event'],] }],
    onKeydownHome: [{ type: HostListener, args: ['keydown.home', ['$event'],] }],
    onKeydownEnd: [{ type: HostListener, args: ['keydown.end', ['$event'],] }],
    onMouseUp: [{ type: HostListener, args: ['document:mouseup', ['$event'],] }]
};
if (false) {
    /**
     * Sets/gets the `id` of the calendar.
     *
     * \@remarks
     * If not set, the `id` will have value `"igx-calendar-0"`.
     *
     * \@example
     * ```html
     * <igx-calendar id="my-first-calendar"></igx-calendar>
     * ```
     * \@memberof IgxCalendarComponent
     * @type {?}
     */
    IgxCalendarComponent.prototype.id;
    /**
     * Sets/gets whether the calendar has header.
     * Default value is `true`.
     *
     * \@example
     * ```html
     * <igx-calendar [hasHeader]="false"></igx-calendar>
     * ```
     * @type {?}
     */
    IgxCalendarComponent.prototype.hasHeader;
    /**
     * Sets/gets whether the calendar header will be in vertical position.
     * Default value is `false`.
     *
     * \@example
     * ```html
     * <igx-calendar [vertical] = "true"></igx-calendar>
     * ```
     * @type {?}
     */
    IgxCalendarComponent.prototype.vertical;
    /**
     * Apply the different states for the transitions of animateChange
     * @hidden
     * \@internal
     * @type {?}
     */
    IgxCalendarComponent.prototype.animationAction;
    /**
     * Used to apply the active date when the calendar view is changed
     *
     * @hidden
     * \@internal
     * @type {?}
     */
    IgxCalendarComponent.prototype.nextDate;
    /**
     * Denote if the calendar view was changed with the keyboard
     *
     * @hidden
     * \@internal
     * @type {?}
     */
    IgxCalendarComponent.prototype.isKeydownTrigger;
    /**
     * @hidden
     * \@internal
     * @type {?}
     */
    IgxCalendarComponent.prototype.callback;
    /**
     * The default `tabindex` attribute for the component.
     *
     * @hidden
     * \@internal
     * @type {?}
     */
    IgxCalendarComponent.prototype.tabindex;
    /**
     * The default aria role attribute for the component.
     *
     * @hidden
     * \@internal
     * @type {?}
     */
    IgxCalendarComponent.prototype.role;
    /**
     * The default aria lebelled by attribute for the component.
     *
     * @hidden
     * \@internal
     * @type {?}
     */
    IgxCalendarComponent.prototype.ariaLabelledBy;
    /**
     * The default css class applied to the component.
     *
     * @hidden
     * \@internal
     * @type {?}
     */
    IgxCalendarComponent.prototype.styleClass;
    /**
     * ViewChild that represents the months view.
     *
     * @hidden
     * \@internal
     * @type {?}
     */
    IgxCalendarComponent.prototype.monthsView;
    /**
     * Month button, that displays the months view.
     * @hidden
     * \@internal
     * @type {?}
     */
    IgxCalendarComponent.prototype.monthsBtns;
    /**
     * ViewChild that represents the decade view.
     *
     * @hidden
     * \@internal
     * @type {?}
     */
    IgxCalendarComponent.prototype.dacadeView;
    /**
     * ViewChild that represents the days view.
     *
     * @hidden
     * \@internal
     * @type {?}
     */
    IgxCalendarComponent.prototype.daysView;
    /**
     * ViewChildrenden representing all of the rendered days views.
     * @hidden
     * \@internal
     * @type {?}
     */
    IgxCalendarComponent.prototype.monthViews;
    /**
     * Button for previous month.
     *
     * @hidden
     * \@internal
     * @type {?}
     */
    IgxCalendarComponent.prototype.prevMonthBtn;
    /**
     * Button for next month.
     *
     * @hidden
     * \@internal
     * @type {?}
     */
    IgxCalendarComponent.prototype.nextMonthBtn;
    /**
     * @hidden
     * \@internal
     * @type {?}
     * @private
     */
    IgxCalendarComponent.prototype.headerTemplateDirective;
    /**
     * @hidden
     * \@internal
     * @type {?}
     * @private
     */
    IgxCalendarComponent.prototype.subheaderTemplateDirective;
    /**
     * @hidden
     * \@internal
     * @type {?}
     * @private
     */
    IgxCalendarComponent.prototype._monthsViewNumber;
    /**
     * @hidden
     * \@internal
     * @type {?}
     * @private
     */
    IgxCalendarComponent.prototype._monthViewsChanges$;
    /**
     * Continious navigation through the previous months
     * @hidden
     * \@internal
     * @type {?}
     */
    IgxCalendarComponent.prototype.startPrevMonthScroll;
    /**
     * Continious navigation through the next months
     * @hidden
     * \@internal
     * @type {?}
     */
    IgxCalendarComponent.prototype.startNextMonthScroll;
    /**
     * Stop continuous navigation
     * @hidden
     * \@internal
     * @type {?}
     */
    IgxCalendarComponent.prototype.stopMonthScroll;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FsZW5kYXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vaWduaXRldWktYW5ndWxhci8iLCJzb3VyY2VzIjpbImxpYi9jYWxlbmRhci9jYWxlbmRhci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ3hFLE9BQU8sRUFDSCxTQUFTLEVBQ1QsWUFBWSxFQUNaLFVBQVUsRUFDVixXQUFXLEVBQ1gsWUFBWSxFQUNaLEtBQUssRUFDTCxTQUFTLEVBQ1QsVUFBVSxFQUVWLFlBQVksRUFDWixTQUFTLEVBRVosTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDbkQsT0FBTyxFQUFFLE1BQU0sRUFBRSxhQUFhLEVBQUUsV0FBVyxFQUFFLFlBQVksRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQ3RGLE9BQU8sRUFDSCxrQ0FBa0MsRUFDbEMscUNBQXFDLEVBQ3hDLE1BQU0sdUJBQXVCLENBQUM7QUFFL0IsT0FBTyxFQUFpQixVQUFVLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFDdkQsT0FBTyxFQUFFLFlBQVksRUFBRSxrQkFBa0IsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQ3ZFLE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLHFDQUFxQyxDQUFDO0FBQzdFLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLG1DQUFtQyxDQUFDO0FBQzFFLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxNQUFNLGlDQUFpQyxDQUFDO0FBQ3ZFLE9BQU8sRUFBRSxRQUFRLEVBQWdCLE1BQU0sTUFBTSxDQUFDO0FBQzlDLE9BQU8sRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUMxRSxPQUFPLEVBQUUsV0FBVyxFQUFF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QUUsQ0FBQyxRQUFRLENBQUM7MkJBWXZDLFlBQVksU0FBQyxhQUFhLEVBQUUsQ0FBQyxRQUFRLENBQUM7d0JBWXRDLFlBQVksU0FBQyxrQkFBa0IsRUFBRSxDQUFDLFFBQVEsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7OztJQTV3QjVDLGtDQUV3Qzs7Ozs7Ozs7Ozs7SUFXeEMseUNBQ3dCOzs7Ozs7Ozs7OztJQVd4Qix3Q0FDd0I7Ozs7Ozs7SUE2QnhCLCtDQUNpQzs7Ozs7Ozs7SUFRakMsd0NBQXNCOzs7Ozs7OztJQVF0QixnREFBZ0M7Ozs7OztJQU1oQyx3Q0FBZ0M7Ozs7Ozs7O0lBUWhDLHdDQUNvQjs7Ozs7Ozs7SUFRcEIsb0NBQ3FCOzs7Ozs7OztJQVFyQiw4Q0FDbUM7Ozs7Ozs7O0lBbUJuQywwQ0FDeUI7Ozs7Ozs7O0lBUXpCLDBDQUMwQzs7Ozs7OztJQU8xQywwQ0FDeUM7Ozs7Ozs7O0lBUXpDLDBDQUN5Qzs7Ozs7Ozs7SUFRekMsd0NBQ3NDOzs7Ozs7O0lBT3RDLDBDQUNtRDs7Ozs7Ozs7SUFRbkQsNENBQ2dDOzs7Ozs7OztJQVFoQyw0Q0FDZ0M7Ozs7Ozs7SUE2R2hDLHVEQUNvRTs7Ozs7OztJQU9wRSwwREFDMEU7Ozs7Ozs7SUFNMUUsaURBQThCOzs7Ozs7O0lBTTlCLG1EQUEwQzs7Ozs7OztJQXdFMUMsb0RBS0M7Ozs7Ozs7SUFPRCxvREFLQzs7Ozs7OztJQU9ELCtDQWtCQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHRyYW5zaXRpb24sIHRyaWdnZXIsIHVzZUFuaW1hdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHtcbiAgICBDb21wb25lbnQsXG4gICAgQ29udGVudENoaWxkLFxuICAgIGZvcndhcmRSZWYsXG4gICAgSG9zdEJpbmRpbmcsXG4gICAgSG9zdExpc3RlbmVyLFxuICAgIElucHV0LFxuICAgIFZpZXdDaGlsZCxcbiAgICBFbGVtZW50UmVmLFxuICAgIEFmdGVyVmlld0luaXQsXG4gICAgVmlld0NoaWxkcmVuLFxuICAgIFF1ZXJ5TGlzdCxcbiAgICBPbkRlc3Ryb3lcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOR19WQUxVRV9BQ0NFU1NPUiB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IGZhZGVJbiwgc2NhbGVJbkNlbnRlciwgc2xpZGVJbkxlZnQsIHNsaWRlSW5SaWdodCB9IGZyb20gJy4uL2FuaW1hdGlvbnMvbWFpbic7XG5pbXBvcnQge1xuICAgIElneENhbGVuZGFySGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgSWd4Q2FsZW5kYXJTdWJoZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZVxufSBmcm9tICcuL2NhbGVuZGFyLmRpcmVjdGl2ZXMnO1xuaW1wb3J0IHsgS0VZUyB9IGZyb20gJy4uL2NvcmUvdXRpbHMnO1xuaW1wb3J0IHsgSUNhbGVuZGFyRGF0ZSwgbW9udGhSYW5nZSB9IGZyb20gJy4vY2FsZW5kYXInO1xuaW1wb3J0IHsgQ2FsZW5kYXJWaWV3LCBJZ3hNb250aFBpY2tlckJhc2UgfSBmcm9tICcuL21vbnRoLXBpY2tlci1iYXNlJztcbmltcG9ydCB7IElneE1vbnRoc1ZpZXdDb21wb25lbnQgfSBmcm9tICcuL21vbnRocy12aWV3L21vbnRocy12aWV3LmNvbXBvbmVudCc7XG5pbXBvcnQgeyBJZ3hZZWFyc1ZpZXdDb21wb25lbnQgfSBmcm9tICcuL3llYXJzLXZpZXcveWVhcnMtdmlldy5jb21wb25lbnQnO1xuaW1wb3J0IHsgSWd4RGF5c1ZpZXdDb21wb25lbnQgfSBmcm9tICcuL2RheXMtdmlldy9kYXlzLXZpZXcuY29tcG9uZW50JztcbmltcG9ydCB7IGludGVydmFsLCBTdWJzY3JpcHRpb24gfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRha2VVbnRpbCwgZGVib3VuY2UsIHNraXBMYXN0LCBzd2l0Y2hNYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTY3JvbGxNb250aCB9IGZyb20gJy4vY2FsZW5kYXItYmFzZSc7XG5pbXBvcnQgeyBJVmlld0NoYW5naW5nRXZlbnRBcmdzIH0gZnJvbSAnLi9kYXlzLXZpZXcvZGF5cy12aWV3LmludGVyZmFjZSc7XG5cbmxldCBORVhUX0lEID0gMDtcblxuLyoqXG4gKiBDYWxlbmRhciBwcm92aWRlcyBhIHdheSB0byBkaXNwbGF5IGRhdGUgaW5mb3JtYXRpb24uXG4gKlxuICogQGlneE1vZHVsZSBJZ3hDYWxlbmRhck1vZHVsZVxuICpcbiAqIEBpZ3hUaGVtZSBpZ3gtY2FsZW5kYXItdGhlbWUsIGlneC1pY29uLXRoZW1lXG4gKlxuICogQGlneEtleXdvcmRzIGNhbGVuZGFyLCBkYXRlcGlja2VyLCBzY2hlZHVsZSwgZGF0ZVxuICpcbiAqIEBpZ3hHcm91cCBTY2hlZHVsaW5nXG4gKlxuICogQHJlbWFya3NcbiAqIFRoZSBJZ25pdGUgVUkgQ2FsZW5kYXIgcHJvdmlkZXMgYW4gZWFzeSB3YXkgdG8gZGlzcGxheSBhIGNhbGVuZGFyIGFuZCBhbGxvdyB1c2VycyB0byBzZWxlY3QgZGF0ZXMgdXNpbmcgc2luZ2xlLCBtdWx0aXBsZVxuICogb3IgcmFuZ2Ugc2VsZWN0aW9uLlxuICpcbiAqIEBleGFtcGxlOlxuICogYGBgaHRtbFxuICogPGlneC1jYWxlbmRhciBzZWxlY3Rpb249XCJyYW5nZVwiPjwvaWd4LWNhbGVuZGFyPlxuICogYGBgXG4gKi9cbkBDb21wb25lbnQoe1xuICAgIHByb3ZpZGVyczogW1xuICAgICAgICB7XG4gICAgICAgICAgICBtdWx0aTogdHJ1ZSxcbiAgICAgICAgICAgIHByb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLFxuICAgICAgICAgICAgdXNlRXhpc3Rpbmc6IElneENhbGVuZGFyQ29tcG9uZW50XG4gICAgICAgIH1cbiAgICBdLFxuICAgIGFuaW1hdGlvbnM6IFtcbiAgICAgICAgdHJpZ2dlcignYW5pbWF0ZVZpZXcnLCBbXG4gICAgICAgICAgICB0cmFuc2l0aW9uKCd2b2lkID0+IDAnLCB1c2VBbmltYXRpb24oZmFkZUluKSksXG4gICAgICAgICAgICB0cmFuc2l0aW9uKCd2b2lkID0+IConLCB1c2VBbmltYXRpb24oc2NhbGVJbkNlbnRlciwge1xuICAgICAgICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogJy4ycycsXG4gICAgICAgICAgICAgICAgICAgIGZyb21TY2FsZTogLjlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgXSksXG4gICAgICAgIHRyaWdnZXIoJ2FuaW1hdGVDaGFuZ2UnLCBbXG4gICAgICAgICAgICB0cmFuc2l0aW9uKCcqID0+IHByZXYnLCB1c2VBbmltYXRpb24oc2xpZGVJbkxlZnQsIHtcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbVBvc2l0aW9uOiAndHJhbnNsYXRlWCgtMzAlKSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSksXG4gICAgICAgICAgICB0cmFuc2l0aW9uKCcqID0+IG5leHQnLCB1c2VBbmltYXRpb24oc2xpZGVJblJpZ2h0LCB7XG4gICAgICAgICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICAgICAgICAgIGZyb21Qb3NpdGlvbjogJ3RyYW5zbGF0ZVgoMzAlKSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSlcbiAgICAgICAgXSlcbiAgICBdLFxuICAgIHNlbGVjdG9yOiAnaWd4LWNhbGVuZGFyJyxcbiAgICB0ZW1wbGF0ZVVybDogJ2NhbGVuZGFyLmNvbXBvbmVudC5odG1sJ1xufSlcbmV4cG9ydCBjbGFzcyBJZ3hDYWxlbmRhckNvbXBvbmVudCBleHRlbmRzIElneE1vbnRoUGlja2VyQmFzZSBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSB7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgdGhlIGBpZGAgb2YgdGhlIGNhbGVuZGFyLlxuICAgICAqXG4gICAgICogQHJlbWFya3NcbiAgICAgKiBJZiBub3Qgc2V0LCB0aGUgYGlkYCB3aWxsIGhhdmUgdmFsdWUgYFwiaWd4LWNhbGVuZGFyLTBcImAuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNhbGVuZGFyIGlkPVwibXktZmlyc3QtY2FsZW5kYXJcIj48L2lneC1jYWxlbmRhcj5cbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q2FsZW5kYXJDb21wb25lbnRcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuaWQnKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGlkID0gYGlneC1jYWxlbmRhci0ke05FWFRfSUQrK31gO1xuXG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHdoZXRoZXIgdGhlIGNhbGVuZGFyIGhhcyBoZWFkZXIuXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgdHJ1ZWAuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNhbGVuZGFyIFtoYXNIZWFkZXJdPVwiZmFsc2VcIj48L2lneC1jYWxlbmRhcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBoYXNIZWFkZXIgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHdoZXRoZXIgdGhlIGNhbGVuZGFyIGhlYWRlciB3aWxsIGJlIGluIHZlcnRpY2FsIHBvc2l0aW9uLlxuICAgICAqIERlZmF1bHQgdmFsdWUgaXMgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtY2FsZW5kYXIgW3ZlcnRpY2FsXSA9IFwidHJ1ZVwiPjwvaWd4LWNhbGVuZGFyPlxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHZlcnRpY2FsID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgdGhlIG51bWJlciBvZiBtb250aCB2aWV3cyBkaXNwbGF5ZWQuXG4gICAgICogRGVmYXVsdCB2YWx1ZSBpcyBgMWAuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNhbGVuZGFyIFttb250aHNWaWV3TnVtYmVyXT1cIjJcIj48L2lneC1jYWxlbmRhcj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIGdldCBtb250aHNWaWV3TnVtYmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbW9udGhzVmlld051bWJlcjtcbiAgICB9XG5cbiAgICBzZXQgbW9udGhzVmlld051bWJlcih2YWw6IG51bWJlcikge1xuICAgICAgICBpZiAodmFsIDwgMSApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX21vbnRoc1ZpZXdOdW1iZXIgPSB2YWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbHkgdGhlIGRpZmZlcmVudCBzdGF0ZXMgZm9yIHRoZSB0cmFuc2l0aW9ucyBvZiBhbmltYXRlQ2hhbmdlXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGFuaW1hdGlvbkFjdGlvbjogYW55ID0gJyc7XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGFwcGx5IHRoZSBhY3RpdmUgZGF0ZSB3aGVuIHRoZSBjYWxlbmRhciB2aWV3IGlzIGNoYW5nZWRcbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgbmV4dERhdGU6IERhdGU7XG5cbiAgICAvKipcbiAgICAgKiBEZW5vdGUgaWYgdGhlIGNhbGVuZGFyIHZpZXcgd2FzIGNoYW5nZWQgd2l0aCB0aGUga2V5Ym9hcmRcbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgaXNLZXlkb3duVHJpZ2dlciA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBjYWxsYmFjazogKG5leHQpID0+IHZvaWQ7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBgdGFiaW5kZXhgIGF0dHJpYnV0ZSBmb3IgdGhlIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIudGFiaW5kZXgnKVxuICAgIHB1YmxpYyB0YWJpbmRleCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBhcmlhIHJvbGUgYXR0cmlidXRlIGZvciB0aGUgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5yb2xlJylcbiAgICBwdWJsaWMgcm9sZSA9ICdncmlkJztcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGFyaWEgbGViZWxsZWQgYnkgYXR0cmlidXRlIGZvciB0aGUgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnYXR0ci5hcmlhLWxhYmVsbGVkYnknKVxuICAgIHB1YmxpYyBhcmlhTGFiZWxsZWRCeSA9ICdjYWxlbmRhcic7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGVmYXVsdCBjc3MgY2xhc3MgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIEBIb3N0QmluZGluZygnY2xhc3MuaWd4LWNhbGVuZGFyLS12ZXJ0aWNhbCcpXG4gICAgZ2V0IHN0eWxlVmVydGljYWxDbGFzcygpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmVydGljYWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGRlZmF1bHQgY3NzIGNsYXNzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2NsYXNzLmlneC1jYWxlbmRhcicpXG4gICAgcHVibGljIHN0eWxlQ2xhc3MgPSB0cnVlO1xuXG4gICAgLyoqXG4gICAgICogVmlld0NoaWxkIHRoYXQgcmVwcmVzZW50cyB0aGUgbW9udGhzIHZpZXcuXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgnbW9udGhzJywgeyByZWFkOiBJZ3hNb250aHNWaWV3Q29tcG9uZW50LCBzdGF0aWM6IGZhbHNlIH0pXG4gICAgcHVibGljIG1vbnRoc1ZpZXc6IElneE1vbnRoc1ZpZXdDb21wb25lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBNb250aCBidXR0b24sIHRoYXQgZGlzcGxheXMgdGhlIG1vbnRocyB2aWV3LlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBAVmlld0NoaWxkcmVuKCdtb250aHNCdG4nKVxuICAgIHB1YmxpYyBtb250aHNCdG5zOiBRdWVyeUxpc3Q8RWxlbWVudFJlZj47XG5cbiAgICAvKipcbiAgICAgKiBWaWV3Q2hpbGQgdGhhdCByZXByZXNlbnRzIHRoZSBkZWNhZGUgdmlldy5cbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBAVmlld0NoaWxkKCdkZWNhZGUnLCB7IHJlYWQ6IElneFllYXJzVmlld0NvbXBvbmVudCwgc3RhdGljOiBmYWxzZSB9KVxuICAgIHB1YmxpYyBkYWNhZGVWaWV3OiBJZ3hZZWFyc1ZpZXdDb21wb25lbnQ7XG5cbiAgICAvKipcbiAgICAgKiBWaWV3Q2hpbGQgdGhhdCByZXByZXNlbnRzIHRoZSBkYXlzIHZpZXcuXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgnZGF5cycsIHsgcmVhZDogSWd4RGF5c1ZpZXdDb21wb25lbnQsIHN0YXRpYzogZmFsc2UgfSlcbiAgICBwdWJsaWMgZGF5c1ZpZXc6IElneERheXNWaWV3Q29tcG9uZW50O1xuXG4gICAgLyoqXG4gICAgICogVmlld0NoaWxkcmVuZGVuIHJlcHJlc2VudGluZyBhbGwgb2YgdGhlIHJlbmRlcmVkIGRheXMgdmlld3MuXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGRyZW4oJ2RheXMnLCB7IHJlYWQ6IElneERheXNWaWV3Q29tcG9uZW50IH0pXG4gICAgcHVibGljIG1vbnRoVmlld3M6IFF1ZXJ5TGlzdDxJZ3hEYXlzVmlld0NvbXBvbmVudD47XG5cbiAgICAvKipcbiAgICAgKiBCdXR0b24gZm9yIHByZXZpb3VzIG1vbnRoLlxuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGQoJ3ByZXZNb250aEJ0bicsIHsgc3RhdGljOiBmYWxzZSB9KVxuICAgIHB1YmxpYyBwcmV2TW9udGhCdG46IEVsZW1lbnRSZWY7XG5cbiAgICAvKipcbiAgICAgKiBCdXR0b24gZm9yIG5leHQgbW9udGguXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgQFZpZXdDaGlsZCgnbmV4dE1vbnRoQnRuJywgeyBzdGF0aWM6IGZhbHNlIH0pXG4gICAgcHVibGljIG5leHRNb250aEJ0bjogRWxlbWVudFJlZjtcblxuICAgIC8qKlxuICAgICAqIERlbm90ZSBpZiB0aGUgeWVhciB2aWV3IGlzIGFjdGl2ZS5cbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZ2V0IGlzWWVhclZpZXcoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGl2ZVZpZXcgPT09IENhbGVuZGFyVmlldy5ZRUFSO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGhlYWRlciB0ZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBoZWFkZXJUZW1wbGF0ZSA9ICB0aGlzLmNhbGVuZGFyLmhlYWRlclRlYW1wbGF0ZTtcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgSWd4Q2FsZW5kYXJDb21wb25lbnRcbiAgICAgKi9cbiAgICBnZXQgaGVhZGVyVGVtcGxhdGUoKTogYW55IHtcbiAgICAgICAgaWYgKHRoaXMuaGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhlYWRlclRlbXBsYXRlRGlyZWN0aXZlLnRlbXBsYXRlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGhlYWRlciB0ZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqICBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNhbGVuZGFyIGhlYWRlclRlbXBsYXRlRGlyZWN0aXZlID0gXCJpZ3hDYWxlbmRhckhlYWRlclwiPjwvaWd4LWNhbGVuZGFyPlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDYWxlbmRhckNvbXBvbmVudFxuICAgICAqL1xuICAgIHNldCBoZWFkZXJUZW1wbGF0ZShkaXJlY3RpdmU6IGFueSkge1xuICAgICAgICB0aGlzLmhlYWRlclRlbXBsYXRlRGlyZWN0aXZlID0gZGlyZWN0aXZlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHN1YmhlYWRlciB0ZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBzdWJoZWFkZXJUZW1wbGF0ZSA9IHRoaXMuY2FsZW5kYXIuc3ViaGVhZGVyVGVtcGxhdGU7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IHN1YmhlYWRlclRlbXBsYXRlKCk6IGFueSB7XG4gICAgICAgIGlmICh0aGlzLnN1YmhlYWRlclRlbXBsYXRlRGlyZWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdWJoZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZS50ZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzdWJoZWFkZXIgdGVtcGxhdGUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LWNhbGVuZGFyIHN1YmhlYWRlclRlbXBsYXRlID0gXCJpZ3hDYWxlbmRhclN1YmhlYWRlclwiPjwvaWd4LWNhbGVuZGFyPlxuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBJZ3hDYWxlbmRhckNvbXBvbmVudFxuICAgICAqL1xuICAgIHNldCBzdWJoZWFkZXJUZW1wbGF0ZShkaXJlY3RpdmU6IGFueSkge1xuICAgICAgICB0aGlzLnN1YmhlYWRlclRlbXBsYXRlRGlyZWN0aXZlID0gZGlyZWN0aXZlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGNvbnRleHQgZm9yIHRoZSB0ZW1wbGF0ZSBtYXJrZWQgd2l0aCB0aGUgYGlneENhbGVuZGFySGVhZGVyYCBkaXJlY3RpdmUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgaGVhZGVyQ29udGV4dCA9ICB0aGlzLmNhbGVuZGFyLmhlYWRlckNvbnRleHQ7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZ2V0IGhlYWRlckNvbnRleHQoKSB7XG4gICAgICAgIGNvbnN0IGRhdGU6IERhdGUgPSB0aGlzLmhlYWRlckRhdGU7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlQ29udGV4dChkYXRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjb250ZXh0IGZvciB0aGUgdGVtcGxhdGUgbWFya2VkIHdpdGggZWl0aGVyIGBpZ3hDYWxlbmRhclN1YkhlYWRlck1vbnRoYFxuICAgICAqIG9yIGBpZ3hDYWxlbmRhclN1YkhlYWRlclllYXJgIGRpcmVjdGl2ZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBjb250ZXh0ID0gIHRoaXMuY2FsZW5kYXIuY29udGV4dDtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBnZXQgY29udGV4dCgpIHtcbiAgICAgICAgY29uc3QgZGF0ZTogRGF0ZSA9IHRoaXMudmlld0RhdGU7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlQ29udGV4dChkYXRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEYXRlIGRpc3BsYXllZCBpbiBoZWFkZXJcbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBnZXQgaGVhZGVyRGF0ZSgpOiBEYXRlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWREYXRlcyA/IHRoaXMuc2VsZWN0ZWREYXRlcyA6IG5ldyBEYXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIEBDb250ZW50Q2hpbGQoZm9yd2FyZFJlZigoKSA9PiBJZ3hDYWxlbmRhckhlYWRlclRlbXBsYXRlRGlyZWN0aXZlKSwgeyByZWFkOiBJZ3hDYWxlbmRhckhlYWRlclRlbXBsYXRlRGlyZWN0aXZlLCBzdGF0aWM6IHRydWUgIH0pXG4gICAgcHJpdmF0ZSBoZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZTogSWd4Q2FsZW5kYXJIZWFkZXJUZW1wbGF0ZURpcmVjdGl2ZTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LWxpbmUtbGVuZ3RoXG4gICAgQENvbnRlbnRDaGlsZChmb3J3YXJkUmVmKCgpID0+IElneENhbGVuZGFyU3ViaGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUpLCB7IHJlYWQ6IElneENhbGVuZGFyU3ViaGVhZGVyVGVtcGxhdGVEaXJlY3RpdmUsIHN0YXRpYzogdHJ1ZSAgfSlcbiAgICBwcml2YXRlIHN1YmhlYWRlclRlbXBsYXRlRGlyZWN0aXZlOiBJZ3hDYWxlbmRhclN1YmhlYWRlclRlbXBsYXRlRGlyZWN0aXZlO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHByaXZhdGUgX21vbnRoc1ZpZXdOdW1iZXIgPSAxO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHByaXZhdGUgX21vbnRoVmlld3NDaGFuZ2VzJDogU3Vic2NyaXB0aW9uO1xuXG4gICAgcHVibGljIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgdGhpcy5zZXRTaWJsaW5nTW9udGhzKHRoaXMubW9udGhWaWV3cyk7XG4gICAgICAgIHRoaXMuX21vbnRoVmlld3NDaGFuZ2VzJCA9IHRoaXMubW9udGhWaWV3cy5jaGFuZ2VzLnN1YnNjcmliZShjID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0U2libGluZ01vbnRocyhjKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5zdGFydE1vbnRoU2Nyb2xsJC5waXBlKFxuICAgICAgICAgICAgdGFrZVVudGlsKHRoaXMuc3RvcE1vbnRoU2Nyb2xsJCksXG4gICAgICAgICAgICBzd2l0Y2hNYXAoKCkgPT4gdGhpcy5zY3JvbGxNb250aCQucGlwZShcbiAgICAgICAgICAgICAgICBza2lwTGFzdCgxKSxcbiAgICAgICAgICAgICAgICBkZWJvdW5jZSgoKSA9PiBpbnRlcnZhbCgzMDApKSxcbiAgICAgICAgICAgICAgICB0YWtlVW50aWwodGhpcy5zdG9wTW9udGhTY3JvbGwkKVxuICAgICAgICAgICAgKSkpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLm1vbnRoU2Nyb2xsRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU2Nyb2xsTW9udGguUFJFVjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJldmlvdXNNb250aCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU2Nyb2xsTW9udGguTkVYVDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dE1vbnRoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBTY3JvbGxNb250aC5OT05FOlxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsb2NhbGUgcmVwcmVzZW50YXRpb24gb2YgdGhlIG1vbnRoIGluIHRoZSBtb250aCB2aWV3IGlmIGVuYWJsZWQsXG4gICAgICogb3RoZXJ3aXNlIHJldHVybnMgdGhlIGRlZmF1bHQgYERhdGUuZ2V0TW9udGgoKWAgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGZvcm1hdHRlZE1vbnRoKHZhbHVlOiBEYXRlKTogc3RyaW5nIHtcbiAgICAgICAgaWYgKHRoaXMuZm9ybWF0Vmlld3MubW9udGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdHRlck1vbnRoLmZvcm1hdCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke3ZhbHVlLmdldE1vbnRoKCl9YDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgdG8gcHJldmlvdXMgbW9udGhcbiAgICAgKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgcHJldmlvdXNNb250aChpc0tleWRvd25UcmlnZ2VyID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy52aWV3RGF0ZSA9IHRoaXMuY2FsZW5kYXJNb2RlbC5nZXRQcmV2TW9udGgodGhpcy52aWV3RGF0ZSk7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uQWN0aW9uID0gU2Nyb2xsTW9udGguUFJFVjtcbiAgICAgICAgdGhpcy5pc0tleWRvd25UcmlnZ2VyID0gaXNLZXlkb3duVHJpZ2dlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgdG8gbmV4dCBtb250aFxuICAgICAqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBuZXh0TW9udGgoaXNLZXlkb3duVHJpZ2dlciA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMudmlld0RhdGUgPSB0aGlzLmNhbGVuZGFyTW9kZWwuZ2V0TmV4dE1vbnRoKHRoaXMudmlld0RhdGUpO1xuICAgICAgICB0aGlzLmFuaW1hdGlvbkFjdGlvbiA9IFNjcm9sbE1vbnRoLk5FWFQ7XG4gICAgICAgIHRoaXMuaXNLZXlkb3duVHJpZ2dlciA9IGlzS2V5ZG93blRyaWdnZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udGluaW91cyBuYXZpZ2F0aW9uIHRocm91Z2ggdGhlIHByZXZpb3VzIG1vbnRoc1xuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgc3RhcnRQcmV2TW9udGhTY3JvbGwgPSAoaXNLZXlkb3duVHJpZ2dlciA9IGZhbHNlKSA9PiB7XG4gICAgICAgIHRoaXMuc3RhcnRNb250aFNjcm9sbCQubmV4dCgpO1xuICAgICAgICB0aGlzLm1vbnRoU2Nyb2xsRGlyZWN0aW9uID0gU2Nyb2xsTW9udGguUFJFVjtcblxuICAgICAgICB0aGlzLnByZXZpb3VzTW9udGgoaXNLZXlkb3duVHJpZ2dlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udGluaW91cyBuYXZpZ2F0aW9uIHRocm91Z2ggdGhlIG5leHQgbW9udGhzXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBzdGFydE5leHRNb250aFNjcm9sbCA9IChpc0tleWRvd25UcmlnZ2VyID0gZmFsc2UpID0+IHtcbiAgICAgICAgdGhpcy5zdGFydE1vbnRoU2Nyb2xsJC5uZXh0KCk7XG4gICAgICAgIHRoaXMubW9udGhTY3JvbGxEaXJlY3Rpb24gPSBTY3JvbGxNb250aC5ORVhUO1xuXG4gICAgICAgIHRoaXMubmV4dE1vbnRoKGlzS2V5ZG93blRyaWdnZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3AgY29udGludW91cyBuYXZpZ2F0aW9uXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBzdG9wTW9udGhTY3JvbGwgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgLy8gZ2VuZXJhbGx5IHRoZSBzY3JvbGxpbmcgaXMgYnVpbHQgb24gdGhlIGNhbGVuZGFyIGNvbXBvbmVudFxuICAgICAgICAvLyBhbmQgYWxsIHN0YXJ0L3N0b3Agc2Nyb2xsaW5nIG1ldGhvZHMgYXJlIGNhbGxlZCBvbiB0aGUgY2FsZW5kYXJcbiAgICAgICAgLy8gaWYgd2UgY2hhbmdlIGJlbG93IGxpbmVzIHRvIGNhbGwgc3RvcE1vbnRoU2Nyb2xsJCBvbiB0aGUgY2FsZW5kYXIgaW5zdGVhZCBvZiBvbiB0aGUgdmlld3MsXG4gICAgICAgIC8vIHN0cmFuZ2UgYnVnIGlzIGludHJvZHVjZWQgLS0+IGFmdGVyIGNoYW5naW5nIG51bWJlciBvZiBtb250aHMsIGNvbnRpbnVvdXMgc2Nyb2xsaW5nIG9uIG1vdXNlIGNsaWNrIGRvZXMgbm90IGhhcHBlblxuICAgICAgICB0aGlzLmRheXNWaWV3LnN0b3BNb250aFNjcm9sbCQubmV4dCh0cnVlKTtcbiAgICAgICAgdGhpcy5kYXlzVmlldy5zdG9wTW9udGhTY3JvbGwkLmNvbXBsZXRlKCk7XG5cblxuICAgICAgICBpZiAodGhpcy5tb250aFNjcm9sbERpcmVjdGlvbiA9PT0gU2Nyb2xsTW9udGguUFJFVikge1xuICAgICAgICAgICAgdGhpcy5wcmV2TW9udGhCdG4ubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubW9udGhTY3JvbGxEaXJlY3Rpb24gPT09IFNjcm9sbE1vbnRoLk5FWFQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dE1vbnRoQnRuLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubW9udGhTY3JvbGxEaXJlY3Rpb24gPSBTY3JvbGxNb250aC5OT05FO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgb25BY3RpdmVWaWV3RGVjYWRlKGFyZ3M6IERhdGUsIGFjdGl2ZVZpZXdJZHg6IG51bWJlcikge1xuICAgICAgICBzdXBlci5hY3RpdmVWaWV3RGVjYWRlKGFjdGl2ZVZpZXdJZHgpO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGFjYWRlVmlldykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGFjYWRlVmlldy5kYXRlID0gYXJncztcbiAgICAgICAgICAgICAgICB0aGlzLmRhY2FkZVZpZXcuZWwubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIG9uQWN0aXZlVmlld0RlY2FkZUtCKGV2ZW50LCBhcmdzOiBEYXRlLCBhY3RpdmVWaWV3SWR4OiBudW1iZXIpIHtcbiAgICAgICAgc3VwZXIuYWN0aXZlVmlld0RlY2FkZUtCKGV2ZW50LCBhY3RpdmVWaWV3SWR4KTtcblxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGFjYWRlVmlldykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGFjYWRlVmlldy5kYXRlID0gYXJncztcbiAgICAgICAgICAgICAgICB0aGlzLmRhY2FkZVZpZXcuZWwubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGdldEZvcm1hdHRlZERhdGUoKTogeyB3ZWVrZGF5OiBzdHJpbmcsIG1vbnRoZGF5OiBzdHJpbmcgfSB7XG5cbiAgICAgICAgY29uc3QgZGF0ZSA9IHRoaXMuaGVhZGVyRGF0ZTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbW9udGhkYXk6IHRoaXMuZm9ybWF0dGVyTW9udGhkYXkuZm9ybWF0KGRhdGUpLFxuICAgICAgICAgICAgd2Vla2RheTogdGhpcy5mb3JtYXR0ZXJXZWVrZGF5LmZvcm1hdChkYXRlKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGludm9rZWQgb24gZGF0ZSBzZWxlY3Rpb25cbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGNoaWxkQ2xpY2tlZChpbnN0YW5jZTogSUNhbGVuZGFyRGF0ZSkge1xuICAgICAgICBpZiAoaW5zdGFuY2UuaXNQcmV2TW9udGgpIHtcbiAgICAgICAgICAgIHRoaXMucHJldmlvdXNNb250aCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluc3RhbmNlLmlzTmV4dE1vbnRoKSB7XG4gICAgICAgICAgICB0aGlzLm5leHRNb250aCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZWxlY3REYXRlRnJvbUNsaWVudChpbnN0YW5jZS5kYXRlKTtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0aW9uID09PSAnbXVsdGknKSB7XG4gICAgICAgICAgICB0aGlzLmRlc2VsZWN0RGF0ZUluTW9udGhWaWV3cyhpbnN0YW5jZS5kYXRlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uU2VsZWN0aW9uLmVtaXQodGhpcy5zZWxlY3RlZERhdGVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIHZpZXdDaGFuZ2luZyhhcmdzOiBJVmlld0NoYW5naW5nRXZlbnRBcmdzKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0aW9uQWN0aW9uID0gYXJncy5tb250aEFjdGlvbjtcbiAgICAgICAgdGhpcy5pc0tleWRvd25UcmlnZ2VyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5uZXh0RGF0ZSA9IGFyZ3MubmV4dERhdGU7XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSAobmV4dCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGF5ID0gdGhpcy5kYXlzVmlldy5kYXRlcy5maW5kKChpdGVtKSA9PiBpdGVtLmRhdGUuZGF0ZS5nZXRUaW1lKCkgPT09IG5leHQuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgIGlmIChkYXkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRheXNWaWV3LmRheXNOYXZTZXJ2aWNlLmZvY3VzTmV4dERhdGUoZGF5Lm5hdGl2ZUVsZW1lbnQsIGFyZ3Mua2V5LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy52aWV3RGF0ZSA9IHRoaXMubmV4dERhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlbmFsXG4gICAgICovXG4gICAgcHVibGljIGNoYW5nZU1vbnRoKGV2ZW50OiBEYXRlKSB7XG4gICAgICAgIHRoaXMudmlld0RhdGUgPSB0aGlzLmNhbGVuZGFyTW9kZWwuZ2V0Rmlyc3RWaWV3RGF0ZShldmVudCwgJ21vbnRoJywgdGhpcy5hY3RpdmVWaWV3SWR4KTtcbiAgICAgICAgdGhpcy5hY3RpdmVWaWV3ID0gQ2FsZW5kYXJWaWV3LkRFRkFVTFQ7XG5cbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW0gPSB0aGlzLm1vbnRoc0J0bnMuZmluZCgoZTogRWxlbWVudFJlZiwgaWR4OiBudW1iZXIpID0+IGlkeCA9PT0gdGhpcy5hY3RpdmVWaWV3SWR4KTtcbiAgICAgICAgICAgIGlmIChlbGVtKSB7IGVsZW0ubmF0aXZlRWxlbWVudC5mb2N1cygpOyB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgb25BY3RpdmVWaWV3WWVhcihhcmdzOiBEYXRlLCBhY3RpdmVWaWV3SWR4OiBudW1iZXIsIGV2ZW50Pyk6IHZvaWQge1xuICAgICAgICB0aGlzLmFjdGl2ZVZpZXcgPSBDYWxlbmRhclZpZXcuWUVBUjtcbiAgICAgICAgdGhpcy5hY3RpdmVWaWV3SWR4ID0gYWN0aXZlVmlld0lkeDtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMubW9udGhzVmlldy5kYXRlID0gYXJncztcbiAgICAgICAgICAgIHRoaXMuZm9jdXNNb250aChldmVudC50YXJnZXQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGZvY3VzTW9udGgodGFyZ2V0OiBIVE1MRWxlbWVudCkge1xuICAgICAgICBjb25zdCBtb250aCA9IHRoaXMubW9udGhzVmlldy5tb250aHNSZWYuZmluZCgoZSkgPT5cbiAgICAgICAgICAgIGUuaW5kZXggPT09IHBhcnNlSW50KHRhcmdldC5wYXJlbnRFbGVtZW50LmF0dHJpYnV0ZXNbJ2RhdGEtbW9udGgnXS52YWx1ZSwgMTApKTtcbiAgICAgICAgaWYgKG1vbnRoKSB7IG1vbnRoLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTsgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgb25BY3RpdmVWaWV3WWVhcktCKGFyZ3M6IERhdGUsIGV2ZW50LCBhY3RpdmVWaWV3SWR4OiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gS0VZUy5TUEFDRSB8fCBldmVudC5rZXkgPT09IEtFWVMuU1BBQ0VfSUUgfHwgZXZlbnQua2V5ID09PSBLRVlTLkVOVEVSKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5vbkFjdGl2ZVZpZXdZZWFyKGFyZ3MsIGFjdGl2ZVZpZXdJZHgsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc2VsZWN0cyBkYXRlKHMpIChiYXNlZCBvbiB0aGUgc2VsZWN0aW9uIHR5cGUpLlxuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKmBgYHR5cGVzY3JpcHRcbiAgICAgKiB0aGlzLmNhbGVuZGFyLmRlc2VsZWN0RGF0ZShuZXcgRGF0ZShgMjAxOC0wNi0xMmApKTtcbiAgICAgKmBgYGBcbiAgICAgKi9cbiAgICBwdWJsaWMgZGVzZWxlY3REYXRlKHZhbHVlPzogRGF0ZSB8IERhdGVbXSkge1xuICAgICAgICBzdXBlci5kZXNlbGVjdERhdGUodmFsdWUpO1xuXG4gICAgICAgIHRoaXMubW9udGhWaWV3cy5mb3JFYWNoKCh2aWV3KSA9PiB7XG4gICAgICAgICAgICB2aWV3LnNlbGVjdGVkRGF0ZXMgPSB0aGlzLnNlbGVjdGVkRGF0ZXM7XG4gICAgICAgICAgICB2aWV3LnJhbmdlU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fb25DaGFuZ2VDYWxsYmFjayh0aGlzLnNlbGVjdGVkRGF0ZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhlbHBlciBtZXRob2QgdGhhdCBkb2VzIGRlc2VsZWN0aW9uIGZvciBhbGwgbW9udGggdmlld3Mgd2hlbiBzZWxlY3Rpb24gaXMgXCJtdWx0aVwiXG4gICAgICogSWYgbm90IGNhbGxlZCwgc2VsZWN0aW9uIGluIG90aGVyIG1vbnRoIHZpZXdzIHN0YXlzXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHByaXZhdGUgZGVzZWxlY3REYXRlSW5Nb250aFZpZXdzKHZhbHVlOiBEYXRlKSB7XG4gICAgICAgIHRoaXMubW9udGhWaWV3cy5mb3JFYWNoKG0gPT4ge1xuICAgICAgICAgICAgbS5kZXNlbGVjdE11bHRpcGxlSW5Nb250aCh2YWx1ZSk7XG4gICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHVibGljIGdldFZpZXdEYXRlKGk6IG51bWJlcik6IERhdGUge1xuICAgICAgICBjb25zdCBkYXRlID0gdGhpcy5jYWxlbmRhck1vZGVsLnRpbWVkZWx0YSh0aGlzLnZpZXdEYXRlLCAnbW9udGgnLCBpKTtcbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0dGVyIGZvciB0aGUgY29udGV4dCBvYmplY3QgaW5zaWRlIHRoZSBjYWxlbmRhciB0ZW1wbGF0ZXMuXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBnZXRDb250ZXh0KGk6IG51bWJlcikge1xuICAgICAgICBjb25zdCBkYXRlID0gdGhpcy5nZXRWaWV3RGF0ZShpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2VuZXJhdGVDb250ZXh0KGRhdGUsIGkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwdWJsaWMgYW5pbWF0aW9uRG9uZShldmVudCkge1xuICAgICAgICBpZiAodGhpcy5tb250aFNjcm9sbERpcmVjdGlvbiAhPT0gU2Nyb2xsTW9udGguTk9ORSkge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxNb250aCQubmV4dCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlVmlldyAhPT0gQ2FsZW5kYXJWaWV3LkRFRkFVTFQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBtb250aFZpZXcgPSB0aGlzLmRheXNWaWV3IGFzIElneERheXNWaWV3Q29tcG9uZW50O1xuICAgICAgICBsZXQgZGF0ZSA9IG1vbnRoVmlldy5kYXRlcy5maW5kKChkKSA9PiBkLnNlbGVjdGVkKTtcblxuICAgICAgICB3aGlsZSAoIWRhdGUgJiYgbW9udGhWaWV3Lm5leHRNb250aFZpZXcpIHtcbiAgICAgICAgICAgIG1vbnRoVmlldyA9IG1vbnRoVmlldy5uZXh0TW9udGhWaWV3O1xuICAgICAgICAgICAgZGF0ZSA9IG1vbnRoVmlldy5kYXRlcy5maW5kKChkKSA9PiBkLnNlbGVjdGVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0ZSAmJiBkYXRlLmlzRm9jdXNhYmxlICYmICF0aGlzLmlzS2V5ZG93blRyaWdnZXIpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGRhdGUubmF0aXZlRWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgICAgfSwgcGFyc2VJbnQoc2xpZGVJblJpZ2h0Lm9wdGlvbnMucGFyYW1zLmR1cmF0aW9uLCAxMCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY2FsbGJhY2sgJiYgKGV2ZW50LnRvU3RhdGUgPT09IFNjcm9sbE1vbnRoLk5FWFQgfHwgZXZlbnQudG9TdGF0ZSA9PT0gU2Nyb2xsTW9udGguUFJFVikpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2sodGhpcy5uZXh0RGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbmltYXRpb25BY3Rpb24gPSBTY3JvbGxNb250aC5OT05FO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEtleWJvYXJkIG5hdmlnYXRpb24gb2YgdGhlIGNhbGVuZGFyXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24ucGFnZWRvd24nLCBbJyRldmVudCddKVxuICAgIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24ucGFnZXVwJywgWyckZXZlbnQnXSlcbiAgICBwdWJsaWMgb25LZXlkb3duUGFnZURvd24oZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBpZiAodGhpcy5hY3RpdmVWaWV3ICE9PSBDYWxlbmRhclZpZXcuREVGQVVMVCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaXNQYWdlRG93biA9IGV2ZW50LmtleSA9PT0gJ1BhZ2VEb3duJztcbiAgICAgICAgY29uc3Qgc3RlcCA9IGlzUGFnZURvd24gPyAxIDogLTE7XG4gICAgICAgIGxldCBtb250aFZpZXcgPSB0aGlzLmRheXNWaWV3IGFzIElneERheXNWaWV3Q29tcG9uZW50O1xuICAgICAgICBsZXQgYWN0aXZlRGF0ZTtcblxuICAgICAgICB3aGlsZSAoIWFjdGl2ZURhdGUgJiYgbW9udGhWaWV3KSB7XG4gICAgICAgICAgICBhY3RpdmVEYXRlID0gbW9udGhWaWV3LmRhdGVzLmZpbmQoKGRhdGUpID0+IGRhdGUubmF0aXZlRWxlbWVudCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCk7XG4gICAgICAgICAgICBtb250aFZpZXcgPSBtb250aFZpZXcubmV4dE1vbnRoVmlldztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhY3RpdmVEYXRlKSB7XG4gICAgICAgICAgICB0aGlzLm5leHREYXRlID0gbmV3IERhdGUoYWN0aXZlRGF0ZS5kYXRlLmRhdGUpO1xuXG4gICAgICAgICAgICBsZXQgeWVhciA9IHRoaXMubmV4dERhdGUuZ2V0RnVsbFllYXIoKTtcblxuICAgICAgICAgICAgbGV0IG1vbnRoID0gdGhpcy5uZXh0RGF0ZS5nZXRNb250aCgpICsgc3RlcDtcbiAgICAgICAgICAgIGlmIChpc1BhZ2VEb3duKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vbnRoID4gMTEpIHsgbW9udGggPSAwOyB5ZWFyICs9IHN0ZXA7IH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKG1vbnRoIDwgMCkgeyBtb250aCA9IDExOyB5ZWFyICs9IHN0ZXA7IH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBtb250aFJhbmdlKHRoaXMubmV4dERhdGUuZ2V0RnVsbFllYXIoKSwgbW9udGgpO1xuXG4gICAgICAgICAgICBsZXQgZGF5ID0gdGhpcy5uZXh0RGF0ZS5nZXREYXRlKCk7XG4gICAgICAgICAgICBpZiAoZGF5ID4gcmFuZ2VbMV0pIHsgZGF5ID0gcmFuZ2VbMV07IH1cblxuICAgICAgICAgICAgdGhpcy5uZXh0RGF0ZS5zZXREYXRlKGRheSk7XG4gICAgICAgICAgICB0aGlzLm5leHREYXRlLnNldE1vbnRoKG1vbnRoKTtcbiAgICAgICAgICAgIHRoaXMubmV4dERhdGUuc2V0RnVsbFllYXIoeWVhcik7XG5cbiAgICAgICAgICAgIHRoaXMuY2FsbGJhY2sgPSAobmV4dCkgPT4ge1xuICAgICAgICAgICAgICAgIG1vbnRoVmlldyA9IHRoaXMuZGF5c1ZpZXcgYXMgSWd4RGF5c1ZpZXdDb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgbGV0IGRheUl0ZW07XG4gICAgICAgICAgICAgICAgd2hpbGUgKCghZGF5SXRlbSAmJiBtb250aFZpZXcpIHx8IChkYXlJdGVtICYmICFkYXlJdGVtLmlzQ3VycmVudE1vbnRoKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXlJdGVtID0gbW9udGhWaWV3LmRhdGVzLmZpbmQoKGQpID0+IGQuZGF0ZS5kYXRlLmdldFRpbWUoKSA9PT0gbmV4dC5nZXRUaW1lKCkpO1xuICAgICAgICAgICAgICAgICAgICBtb250aFZpZXcgPSBtb250aFZpZXcubmV4dE1vbnRoVmlldztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRheUl0ZW0gJiYgZGF5SXRlbS5pc0ZvY3VzYWJsZSkgeyBkYXlJdGVtLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTsgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1BhZ2VEb3duKSB7IHRoaXMubmV4dE1vbnRoKHRydWUpOyB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wcmV2aW91c01vbnRoKHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogS2V5Ym9hcmQgbmF2aWdhdGlvbiBvZiB0aGUgY2FsZW5kYXJcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgQEhvc3RMaXN0ZW5lcigna2V5ZG93bi5zaGlmdC5wYWdldXAnLCBbJyRldmVudCddKVxuICAgIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24uc2hpZnQucGFnZWRvd24nLCBbJyRldmVudCddKVxuICAgIHB1YmxpYyBvbktleWRvd25TaGlmdFBhZ2VVcChldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZVZpZXcgIT09IENhbGVuZGFyVmlldy5ERUZBVUxUKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpc1BhZ2VEb3duID0gZXZlbnQua2V5ID09PSAnUGFnZURvd24nO1xuICAgICAgICBjb25zdCBzdGVwID0gaXNQYWdlRG93biA/IDEgOiAtMTtcbiAgICAgICAgdGhpcy52aWV3RGF0ZSA9IHRoaXMuY2FsZW5kYXJNb2RlbC50aW1lZGVsdGEodGhpcy52aWV3RGF0ZSwgJ3llYXInLCBzdGVwKTtcblxuICAgICAgICB0aGlzLmFuaW1hdGlvbkFjdGlvbiA9IGlzUGFnZURvd24gPyBTY3JvbGxNb250aC5ORVhUIDogU2Nyb2xsTW9udGguUFJFVjtcbiAgICAgICAgdGhpcy5pc0tleWRvd25UcmlnZ2VyID0gdHJ1ZTtcblxuICAgICAgICBsZXQgbW9udGhWaWV3ID0gdGhpcy5kYXlzVmlldyBhcyBJZ3hEYXlzVmlld0NvbXBvbmVudDtcbiAgICAgICAgbGV0IGFjdGl2ZURhdGU7XG5cbiAgICAgICAgd2hpbGUgKCFhY3RpdmVEYXRlICYmIG1vbnRoVmlldykge1xuICAgICAgICAgICAgYWN0aXZlRGF0ZSA9IG1vbnRoVmlldy5kYXRlcy5maW5kKChkYXRlKSA9PiBkYXRlLm5hdGl2ZUVsZW1lbnQgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpO1xuICAgICAgICAgICAgbW9udGhWaWV3ID0gbW9udGhWaWV3Lm5leHRNb250aFZpZXc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWN0aXZlRGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5uZXh0RGF0ZSA9IG5ldyBEYXRlKGFjdGl2ZURhdGUuZGF0ZS5kYXRlKTtcblxuICAgICAgICAgICAgY29uc3QgeWVhciA9IHRoaXMubmV4dERhdGUuZ2V0RnVsbFllYXIoKSArIHN0ZXA7XG5cbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gbW9udGhSYW5nZSh5ZWFyLCB0aGlzLm5leHREYXRlLmdldE1vbnRoKCkpO1xuXG4gICAgICAgICAgICBsZXQgZGF5ID0gdGhpcy5uZXh0RGF0ZS5nZXREYXRlKCk7XG4gICAgICAgICAgICBpZiAoZGF5ID4gcmFuZ2VbMV0pIHsgZGF5ID0gcmFuZ2VbMV07IH1cblxuICAgICAgICAgICAgdGhpcy5uZXh0RGF0ZS5zZXREYXRlKGRheSk7XG4gICAgICAgICAgICB0aGlzLm5leHREYXRlLnNldEZ1bGxZZWFyKHllYXIpO1xuXG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrID0gKG5leHQpID0+IHtcbiAgICAgICAgICAgICAgICBtb250aFZpZXcgPSB0aGlzLmRheXNWaWV3IGFzIElneERheXNWaWV3Q29tcG9uZW50O1xuICAgICAgICAgICAgICAgIGxldCBkYXlJdGVtO1xuICAgICAgICAgICAgICAgIHdoaWxlICgoIWRheUl0ZW0gJiYgbW9udGhWaWV3KSB8fCAoZGF5SXRlbSAmJiAhZGF5SXRlbS5pc0N1cnJlbnRNb250aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF5SXRlbSA9IG1vbnRoVmlldy5kYXRlcy5maW5kKChkKSA9PiBkLmRhdGUuZGF0ZS5nZXRUaW1lKCkgPT09IG5leHQuZ2V0VGltZSgpKTtcbiAgICAgICAgICAgICAgICAgICAgbW9udGhWaWV3ID0gbW9udGhWaWV3Lm5leHRNb250aFZpZXc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChkYXlJdGVtICYmIGRheUl0ZW0uaXNGb2N1c2FibGUpIHsgZGF5SXRlbS5uYXRpdmVFbGVtZW50LmZvY3VzKCk7IH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBLZXlib2FyZCBuYXZpZ2F0aW9uIG9mIHRoZSBjYWxlbmRhclxuICAgICAqIEBoaWRkZW5cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBASG9zdExpc3RlbmVyKCdrZXlkb3duLmhvbWUnLCBbJyRldmVudCddKVxuICAgIHB1YmxpYyBvbktleWRvd25Ib21lKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRheXNWaWV3KSB7XG4gICAgICAgICAgICB0aGlzLmRheXNWaWV3Lm9uS2V5ZG93bkhvbWUoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogS2V5Ym9hcmQgbmF2aWdhdGlvbiBvZiB0aGUgY2FsZW5kYXJcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgQEhvc3RMaXN0ZW5lcigna2V5ZG93bi5lbmQnLCBbJyRldmVudCddKVxuICAgIHB1YmxpYyBvbktleWRvd25FbmQoZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF5c1ZpZXcpIHtcbiAgICAgICAgICAgIHRoaXMuZGF5c1ZpZXcub25LZXlkb3duRW5kKGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0b3AgY29udGludW91cyBuYXZpZ2F0aW9uIG9uIG1vdXNldXAgZXZlbnRcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgQEhvc3RMaXN0ZW5lcignZG9jdW1lbnQ6bW91c2V1cCcsIFsnJGV2ZW50J10pXG4gICAgcHVibGljIG9uTW91c2VVcChldmVudDogS2V5Ym9hcmRFdmVudCkge1xuICAgICAgICBpZiAodGhpcy5tb250aFNjcm9sbERpcmVjdGlvbiAhPT0gU2Nyb2xsTW9udGguTk9ORSkge1xuICAgICAgICAgICAgdGhpcy5zdG9wTW9udGhTY3JvbGwoZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHB1YmxpYyBuZ09uRGVzdHJveSgpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuX21vbnRoVmlld3NDaGFuZ2VzJCkge1xuICAgICAgICAgICAgdGhpcy5fbW9udGhWaWV3c0NoYW5nZXMkLnVuc3Vic2NyaWJlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIGJ1aWxkaW5nIGFuZCByZXR1cm5pbmcgdGhlIGNvbnRleHQgb2JqZWN0IGluc2lkZVxuICAgICAqIHRoZSBjYWxlbmRhciB0ZW1wbGF0ZXMuXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHByaXZhdGUgZ2VuZXJhdGVDb250ZXh0KHZhbHVlOiBEYXRlLCBpPzogbnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IGZvcm1hdE9iamVjdCA9IHtcbiAgICAgICAgICAgIGluZGV4OiBpLFxuICAgICAgICAgICAgbW9udGhWaWV3OiAoKSA9PiB0aGlzLm9uQWN0aXZlVmlld1llYXIodmFsdWUsIGkpLFxuICAgICAgICAgICAgeWVhclZpZXc6ICgpID0+IHRoaXMub25BY3RpdmVWaWV3RGVjYWRlKHZhbHVlLCBpKSxcbiAgICAgICAgICAgIC4uLnRoaXMuY2FsZW5kYXJNb2RlbC5mb3JtYXRUb1BhcnRzKHZhbHVlLCB0aGlzLmxvY2FsZSwgdGhpcy5mb3JtYXRPcHRpb25zLFxuICAgICAgICAgICAgICAgIFsnZXJhJywgJ3llYXInLCAnbW9udGgnLCAnZGF5JywgJ3dlZWtkYXknXSlcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHsgJGltcGxpY2l0OiBmb3JtYXRPYmplY3QgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgbWV0aG9kIHRoYXQgc2V0cyByZWZlcmVuY2VzIGZvciBwcmV2L25leHQgbW9udGhzIGZvciBlYWNoIG1vbnRoIGluIHRoZSB2aWV3XG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHByaXZhdGUgc2V0U2libGluZ01vbnRocyhtb250aFZpZXdzOiBRdWVyeUxpc3Q8SWd4RGF5c1ZpZXdDb21wb25lbnQ+KSB7XG4gICAgICAgIG1vbnRoVmlld3MuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByZXZNb250aFZpZXcgPSB0aGlzLmdldE1vbnRoVmlldyhpbmRleCAtIDEpO1xuICAgICAgICAgICAgY29uc3QgbmV4dE1vbnRoVmlldyA9IHRoaXMuZ2V0TW9udGhWaWV3KGluZGV4ICsgMSk7XG4gICAgICAgICAgICBpdGVtLm5leHRNb250aFZpZXcgPSBuZXh0TW9udGhWaWV3O1xuICAgICAgICAgICAgaXRlbS5wcmV2TW9udGhWaWV3ID0gcHJldk1vbnRoVmlldztcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIG1ldGhvZCByZXR1cm5pbmcgcHJldmlvdXMvbmV4dCBkYXkgdmlld3NcbiAgICAgKiBAaGlkZGVuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcHJpdmF0ZSBnZXRNb250aFZpZXcoaW5kZXg6IG51bWJlcik6IElneERheXNWaWV3Q29tcG9uZW50IHtcbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSB8fCBpbmRleCA9PT0gdGhpcy5tb250aFZpZXdzLmxlbmd0aCApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9udGhWaWV3cy50b0FycmF5KClbaW5kZXhdO1xuICAgICAgICB9XG4gICAgfVxufVxuIl19