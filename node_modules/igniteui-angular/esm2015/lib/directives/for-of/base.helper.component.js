/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { HostListener, ElementRef, ChangeDetectorRef, Directive } from '@angular/core';
export class VirtualHelperBaseDirective {
    /**
     * @param {?} elementRef
     * @param {?} cdr
     */
    constructor(elementRef, cdr) {
        this.elementRef = elementRef;
        this.cdr = cdr;
        this.scrollAmount = 0;
        this._size = 0;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    onScroll(event) {
        this.scrollAmount = event.target.scrollTop || event.target.scrollLeft;
    }
    /**
     * @return {?}
     */
    get nativeElement() {
        return this.elementRef.nativeElement;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.destroyed = true;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set size(value) {
        if (this.destroyed) {
            return;
        }
        this._size = value;
        this.cdr.detectChanges();
    }
    /**
     * @return {?}
     */
    get size() {
        return this._size;
    }
}
VirtualHelperBaseDirective.decorators = [
    { type: Directive, args: [{
                selector: '[igxVirtualHelperBase]'
            },] }
];
/** @nocollapse */
VirtualHelperBaseDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ChangeDetectorRef }
];
VirtualHelperBaseDirective.propDecorators = {
    onScroll: [{ type: HostListener, args: ['scroll', ['$event'],] }]
};
if (false) {
    /** @type {?} */
    VirtualHelperBaseDirective.prototype.scrollAmount;
    /** @type {?} */
    VirtualHelperBaseDirective.prototype._size;
    /** @type {?} */
    VirtualHelperBaseDirective.prototype.destroyed;
    /** @type {?} */
    VirtualHelperBaseDirective.prototype.elementRef;
    /** @type {?} */
    VirtualHelperBaseDirective.prototype.cdr;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZS5oZWxwZXIuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vaWduaXRldWktYW5ndWxhci8iLCJzb3VyY2VzIjpbImxpYi9kaXJlY3RpdmVzL2Zvci1vZi9iYXNlLmhlbHBlci5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFHSCxZQUFZLEVBQ1osVUFBVSxFQUNWLGlCQUFpQixFQUVqQixTQUFTLEVBQ1osTUFBTSxlQUFlLENBQUM7QUFLdkIsTUFBTSxPQUFPLDBCQUEwQjs7Ozs7SUFXbkMsWUFBbUIsVUFBc0IsRUFBUyxHQUFzQjtRQUFyRCxlQUFVLEdBQVYsVUFBVSxDQUFZO1FBQVMsUUFBRyxHQUFILEdBQUcsQ0FBbUI7UUFWakUsaUJBQVksR0FBRyxDQUFDLENBQUM7UUFFakIsVUFBSyxHQUFHLENBQUMsQ0FBQztJQVEyRCxDQUFDOzs7OztJQUg3RSxRQUFRLENBQUMsS0FBSztRQUNWLElBQUksQ0FBQyxZQUFZLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxTQUFTLElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUM7SUFDMUUsQ0FBQzs7OztJQUdELElBQUksYUFBYTtRQUNiLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxhQUFhLENBQUM7SUFDekMsQ0FBQzs7OztJQUVNLFdBQVc7UUFDZCxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQztJQUMxQixDQUFDOzs7OztJQUVELElBQVcsSUFBSSxDQUFDLEtBQUs7UUFDakIsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFO1lBQ2hCLE9BQU87U0FDVjtRQUNELElBQUksQ0FBQyxLQUFLLEdBQUcsS0FBSyxDQUFDO1FBQ25CLElBQUksQ0FBQyxHQUFHLENBQUMsYUFBYSxFQUFFLENBQUM7SUFDN0IsQ0FBQzs7OztJQUVELElBQVcsSUFBSTtRQUNYLE9BQU8sSUFBSSxDQUFDLEtBQUssQ0FBQztJQUN0QixDQUFDOzs7WUFsQ0osU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSx3QkFBd0I7YUFDckM7Ozs7WUFSRyxVQUFVO1lBQ1YsaUJBQWlCOzs7dUJBZWhCLFlBQVksU0FBQyxRQUFRLEVBQUUsQ0FBQyxRQUFRLENBQUM7Ozs7SUFObEMsa0RBQXdCOztJQUV4QiwyQ0FBaUI7O0lBRWpCLCtDQUFpQjs7SUFNTCxnREFBNkI7O0lBQUUseUNBQTZCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgT3V0cHV0LFxuICAgIEhvc3RMaXN0ZW5lcixcbiAgICBFbGVtZW50UmVmLFxuICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgIE9uRGVzdHJveSxcbiAgICBEaXJlY3RpdmVcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW2lneFZpcnR1YWxIZWxwZXJCYXNlXSdcbn0pXG5leHBvcnQgY2xhc3MgVmlydHVhbEhlbHBlckJhc2VEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkRlc3Ryb3kge1xuICAgIHB1YmxpYyBzY3JvbGxBbW91bnQgPSAwO1xuXG4gICAgcHVibGljIF9zaXplID0gMDtcblxuICAgIHB1YmxpYyBkZXN0cm95ZWQ7XG5cbiAgICBASG9zdExpc3RlbmVyKCdzY3JvbGwnLCBbJyRldmVudCddKVxuICAgIG9uU2Nyb2xsKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsQW1vdW50ID0gZXZlbnQudGFyZ2V0LnNjcm9sbFRvcCB8fCBldmVudC50YXJnZXQuc2Nyb2xsTGVmdDtcbiAgICB9XG4gICAgY29uc3RydWN0b3IocHVibGljIGVsZW1lbnRSZWY6IEVsZW1lbnRSZWYsIHB1YmxpYyBjZHI6IENoYW5nZURldGVjdG9yUmVmKSB7IH1cblxuICAgIGdldCBuYXRpdmVFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgcHVibGljIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcHVibGljIHNldCBzaXplKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NpemUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5jZHIuZGV0ZWN0Q2hhbmdlcygpO1xuICAgIH1cblxuICAgIHB1YmxpYyBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NpemU7XG4gICAgfVxufVxuIl19