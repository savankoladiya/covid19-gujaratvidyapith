/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ElementRef, HostBinding, Input, ViewChild, ComponentFactoryResolver } from '@angular/core';
import { GridBaseAPIService } from '.././api.service';
import { IgxRowIslandComponent } from './row-island.component';
import { IgxGridComponent } from '../grid/grid.component';
import { takeUntil } from 'rxjs/operators';
export class IgxChildGridRowComponent {
    /**
     * @param {?} gridAPI
     * @param {?} element
     * @param {?} resolver
     * @param {?} cdr
     */
    constructor(gridAPI, element, resolver, cdr) {
        this.gridAPI = gridAPI;
        this.element = element;
        this.cdr = cdr;
        /**
         * Returns whether the row is expanded.
         * ```typescript
         * const RowExpanded = this.grid1.rowList.first.expanded;
         * ```
         */
        this.expanded = false;
        /**
         *  The data passed to the row component.
         *
         * ```typescript
         * // get the row data for the first selected row
         * let selectedRowData = this.grid.selectedRows[0].rowData;
         * ```
         */
        this.rowData = [];
        /**
         * @hidden
         */
        this.tabindex = 0;
        /**
         * @hidden
         */
        this.role = 'row';
        this.resolver = resolver;
    }
    /**
     * @hidden
     * @return {?}
     */
    get parentHasScroll() {
        return !this.parentGrid.verticalScrollContainer.dc.instance.notVirtual;
    }
    /**
     * Get a reference to the grid that contains the selected row.
     *
     * ```typescript
     * handleRowSelection(event) {
     *  // the grid on which the onRowSelectionChange event was triggered
     *  const grid = event.row.grid;
     * }
     * ```
     *
     * ```html
     *  <igx-grid
     *    [data]="data"
     *    (onRowSelectionChange)="handleRowSelection($event)">
     *  </igx-grid>
     * ```
     * @return {?}
     */
    // TODO: Refactor
    get parentGrid() {
        return this.gridAPI.grid;
    }
    /**
     * @return {?}
     */
    get level() {
        return this.layout.level;
    }
    /**
     * The native DOM element representing the row. Could be null in certain environments.
     *
     * ```typescript
     * // get the nativeElement of the second selected row
     * let selectedRowNativeElement = this.grid.selectedRows[1].nativeElement;
     * ```
     * @return {?}
     */
    get nativeElement() {
        return this.element.nativeElement;
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        this.layout.onLayoutChange.subscribe((ch) => {
            this._handleLayoutChanges(ch);
        });
        /** @type {?} */
        const changes = this.layout.initialChanges;
        changes.forEach(change => {
            this._handleLayoutChanges(change);
        });
        this.hGrid.parent = this.parentGrid;
        this.hGrid.parentIsland = this.layout;
        this.hGrid.childRow = this;
        // handler logic that re-emits hgrid events on the row island
        this.setupEventEmitters();
        this.layout.onGridCreated.emit({
            owner: this.layout,
            parentID: this.rowData.rowID,
            grid: this.hGrid
        });
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterViewInit() {
        this.hGrid.childLayoutList = this.layout.children;
        if (this.layout.childColumns.length > 0 && !this.hGrid.autoGenerate) {
            this.hGrid.createColumnsList(this.layout.childColumns.toArray());
        }
        /** @type {?} */
        const layouts = this.hGrid.childLayoutList.toArray();
        layouts.forEach((l) => this.hGrid.hgridAPI.registerChildRowIsland(l));
        this.parentGrid.hgridAPI.registerChildGrid(this.rowData.rowID, this.layout.key, this.hGrid);
        this.layout.rowIslandAPI.registerChildGrid(this.rowData.rowID, this.hGrid);
        this.hGrid.cdr.detectChanges();
    }
    /**
     * @private
     * @return {?}
     */
    setupEventEmitters() {
        /** @type {?} */
        const destructor = takeUntil(this.hGrid.destroy$);
        /** @type {?} */
        const factory = this.resolver.resolveComponentFactory(IgxGridComponent);
        // exclude outputs related to two-way binding functionality
        /** @type {?} */
        const inputNames = factory.inputs.map(input => input.propName);
        /** @type {?} */
        const outputs = factory.outputs.filter(o => {
            /** @type {?} */
            const matchingInputPropName = o.propName.slice(0, o.propName.indexOf('Change'));
            return inputNames.indexOf(matchingInputPropName) === -1;
        });
        outputs.forEach(output => {
            if (this.hGrid[output.propName]) {
                this.hGrid[output.propName].pipe(destructor).subscribe((args) => {
                    if (!args) {
                        args = {};
                    }
                    args.owner = this.hGrid;
                    this.layout[output.propName].emit(args);
                });
            }
        });
    }
    /**
     * @private
     * @param {?} changes
     * @return {?}
     */
    _handleLayoutChanges(changes) {
        for (const change in changes) {
            if (changes.hasOwnProperty(change)) {
                this.hGrid[change] = changes[change].currentValue;
            }
        }
    }
}
IgxChildGridRowComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-child-grid-row',
                template: "<div class=\"igx-grid__hierarchical-indent\" [ngClass]=\"{'igx-grid__hierarchical-indent--scroll': parentHasScroll}\">\n    <igx-hierarchical-grid #hgrid [data]='rowData.childGridsData[layout.key]'></igx-hierarchical-grid>\n</div>\n"
            }] }
];
/** @nocollapse */
IgxChildGridRowComponent.ctorParameters = () => [
    { type: GridBaseAPIService },
    { type: ElementRef },
    { type: ComponentFactoryResolver },
    { type: ChangeDetectorRef }
];
IgxChildGridRowComponent.propDecorators = {
    layout: [{ type: Input }],
    parentGridID: [{ type: Input }],
    rowData: [{ type: Input }],
    index: [{ type: Input }],
    hGrid: [{ type: ViewChild, args: ['hgrid', { static: true },] }],
    tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    role: [{ type: HostBinding, args: ['attr.role',] }],
    level: [{ type: HostBinding, args: ['attr.data-level',] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    IgxChildGridRowComponent.prototype.resolver;
    /**
     * Returns whether the row is expanded.
     * ```typescript
     * const RowExpanded = this.grid1.rowList.first.expanded;
     * ```
     * @type {?}
     */
    IgxChildGridRowComponent.prototype.expanded;
    /** @type {?} */
    IgxChildGridRowComponent.prototype.layout;
    /**
     * @hidden
     * @type {?}
     */
    IgxChildGridRowComponent.prototype.parentGridID;
    /**
     *  The data passed to the row component.
     *
     * ```typescript
     * // get the row data for the first selected row
     * let selectedRowData = this.grid.selectedRows[0].rowData;
     * ```
     * @type {?}
     */
    IgxChildGridRowComponent.prototype.rowData;
    /**
     * The index of the row.
     *
     * ```typescript
     * // get the index of the second selected row
     * let selectedRowIndex = this.grid.selectedRows[1].index;
     * ```
     * @type {?}
     */
    IgxChildGridRowComponent.prototype.index;
    /**
     * @type {?}
     * @private
     */
    IgxChildGridRowComponent.prototype.hGrid;
    /**
     * @hidden
     * @type {?}
     */
    IgxChildGridRowComponent.prototype.tabindex;
    /**
     * @hidden
     * @type {?}
     */
    IgxChildGridRowComponent.prototype.role;
    /** @type {?} */
    IgxChildGridRowComponent.prototype.gridAPI;
    /** @type {?} */
    IgxChildGridRowComponent.prototype.element;
    /** @type {?} */
    IgxChildGridRowComponent.prototype.cdr;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hpbGQtZ3JpZC1yb3cuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vaWduaXRldWktYW5ndWxhci8iLCJzb3VyY2VzIjpbImxpYi9ncmlkcy9oaWVyYXJjaGljYWwtZ3JpZC9jaGlsZC1ncmlkLXJvdy5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFDSCx1QkFBdUIsRUFDdkIsaUJBQWlCLEVBQ2pCLFNBQVMsRUFDVCxVQUFVLEVBQ1YsV0FBVyxFQUNYLEtBQUssRUFFTCxTQUFTLEVBR1Qsd0JBQXdCLEVBQzNCLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBQ3RELE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQy9ELE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQzFELE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQVEzQyxNQUFNLE9BQU8sd0JBQXdCOzs7Ozs7O0lBd0dqQyxZQUFtQixPQUF1RSxFQUMvRSxPQUFtQixFQUMxQixRQUFrQyxFQUMzQixHQUFzQjtRQUhkLFlBQU8sR0FBUCxPQUFPLENBQWdFO1FBQy9FLFlBQU8sR0FBUCxPQUFPLENBQVk7UUFFbkIsUUFBRyxHQUFILEdBQUcsQ0FBbUI7Ozs7Ozs7UUFsRzFCLGFBQVEsR0FBRyxLQUFLLENBQUM7Ozs7Ozs7OztRQTRCakIsWUFBTyxHQUFRLEVBQUUsQ0FBQzs7OztRQW9CbEIsYUFBUSxHQUFHLENBQUMsQ0FBQzs7OztRQU1iLFNBQUksR0FBRyxLQUFLLENBQUM7UUE2Q1osSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7SUFDakMsQ0FBQzs7Ozs7SUE1RkQsSUFBVyxlQUFlO1FBQ3RCLE9BQU8sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLHVCQUF1QixDQUFDLEVBQUUsQ0FBQyxRQUFR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SyxDQUFDLE1BQU0sQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxZQUFZLENBQUM7YUFDckQ7U0FDSjtJQUNMLENBQUM7OztZQTFMSixTQUFTLFNBQUM7Z0JBQ1AsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07Z0JBQy9DLG1CQUFtQixFQUFFLEtBQUs7Z0JBQzFCLFFBQVEsRUFBRSxvQkFBb0I7Z0JBQzlCLG9QQUE4QzthQUNqRDs7OztZQVZRLGtCQUFrQjtZQVR2QixVQUFVO1lBT1Ysd0JBQXdCO1lBVHhCLGlCQUFpQjs7O3FCQWlDaEIsS0FBSzsyQkFjTCxLQUFLO3NCQVdMLEtBQUs7b0JBV0wsS0FBSztvQkFHTCxTQUFTLFNBQUMsT0FBTyxFQUFFLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRTt1QkFNbkMsV0FBVyxTQUFDLGVBQWU7bUJBTTNCLFdBQVcsU0FBQyxXQUFXO29CQXlCdkIsV0FBVyxTQUFDLGlCQUFpQjs7Ozs7OztJQXRGbEMsNENBQWlCOzs7Ozs7OztJQVFiLDRDQUF3Qjs7SUFFeEIsMENBQzhCOzs7OztJQWE5QixnREFDNEI7Ozs7Ozs7Ozs7SUFVNUIsMkNBQ3lCOzs7Ozs7Ozs7O0lBVXpCLHlDQUNxQjs7Ozs7SUFFckIseUNBQzBEOzs7OztJQUsxRCw0Q0FDb0I7Ozs7O0lBS3BCLHdDQUNvQjs7SUF5Q1IsMkNBQThFOztJQUN0RiwyQ0FBMEI7O0lBRTFCLHVDQUE2QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gICAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gICAgQ29tcG9uZW50LFxuICAgIEVsZW1lbnRSZWYsXG4gICAgSG9zdEJpbmRpbmcsXG4gICAgSW5wdXQsXG4gICAgT25Jbml0LFxuICAgIFZpZXdDaGlsZCxcbiAgICBBZnRlclZpZXdJbml0LFxuICAgIFNpbXBsZUNoYW5nZXMsXG4gICAgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgR3JpZEJhc2VBUElTZXJ2aWNlIH0gZnJvbSAnLi4vLi9hcGkuc2VydmljZSc7XG5pbXBvcnQgeyBJZ3hSb3dJc2xhbmRDb21wb25lbnQgfSBmcm9tICcuL3Jvdy1pc2xhbmQuY29tcG9uZW50JztcbmltcG9ydCB7IElneEdyaWRDb21wb25lbnQgfSBmcm9tICcuLi9ncmlkL2dyaWQuY29tcG9uZW50JztcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuQENvbXBvbmVudCh7XG4gICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgcHJlc2VydmVXaGl0ZXNwYWNlczogZmFsc2UsXG4gICAgc2VsZWN0b3I6ICdpZ3gtY2hpbGQtZ3JpZC1yb3cnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9jaGlsZC1ncmlkLXJvdy5jb21wb25lbnQuaHRtbCdcbn0pXG5leHBvcnQgY2xhc3MgSWd4Q2hpbGRHcmlkUm93Q29tcG9uZW50IGltcGxlbWVudHMgQWZ0ZXJWaWV3SW5pdCwgT25Jbml0IHtcbnByaXZhdGUgcmVzb2x2ZXI7XG5cbiAgICAvKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgcm93IGlzIGV4cGFuZGVkLlxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgUm93RXhwYW5kZWQgPSB0aGlzLmdyaWQxLnJvd0xpc3QuZmlyc3QuZXhwYW5kZWQ7XG4gKiBgYGBcbiAqL1xuICAgIHB1YmxpYyBleHBhbmRlZCA9IGZhbHNlO1xuXG4gICAgQElucHV0KClcbiAgICBsYXlvdXQ6IElneFJvd0lzbGFuZENvbXBvbmVudDtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBwdWJsaWMgZ2V0IHBhcmVudEhhc1Njcm9sbCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLnBhcmVudEdyaWQudmVydGljYWxTY3JvbGxDb250YWluZXIuZGMuaW5zdGFuY2Uubm90VmlydHVhbDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICogQGhpZGRlblxuICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgcGFyZW50R3JpZElEOiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiAgVGhlIGRhdGEgcGFzc2VkIHRvIHRoZSByb3cgY29tcG9uZW50LlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIC8vIGdldCB0aGUgcm93IGRhdGEgZm9yIHRoZSBmaXJzdCBzZWxlY3RlZCByb3dcbiAgICAgKiBsZXQgc2VsZWN0ZWRSb3dEYXRhID0gdGhpcy5ncmlkLnNlbGVjdGVkUm93c1swXS5yb3dEYXRhO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIHJvd0RhdGE6IGFueSA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGluZGV4IG9mIHRoZSByb3cuXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgc2Vjb25kIHNlbGVjdGVkIHJvd1xuICAgICAqIGxldCBzZWxlY3RlZFJvd0luZGV4ID0gdGhpcy5ncmlkLnNlbGVjdGVkUm93c1sxXS5pbmRleDtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBpbmRleDogbnVtYmVyO1xuXG4gICAgQFZpZXdDaGlsZCgnaGdyaWQnLCB7IHN0YXRpYzogdHJ1ZSB9KVxuICAgIHByaXZhdGUgaEdyaWQ6IGFueS8qIFRPRE86IElneEhpZXJhcmNoaWNhbEdyaWRDb21wb25lbnQqLztcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIudGFiaW5kZXgnKVxuICAgIHB1YmxpYyB0YWJpbmRleCA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgQEhvc3RCaW5kaW5nKCdhdHRyLnJvbGUnKVxuICAgIHB1YmxpYyByb2xlID0gJ3Jvdyc7XG5cbiAgICAvKipcbiAgICAgKiBHZXQgYSByZWZlcmVuY2UgdG8gdGhlIGdyaWQgdGhhdCBjb250YWlucyB0aGUgc2VsZWN0ZWQgcm93LlxuICAgICAqXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGhhbmRsZVJvd1NlbGVjdGlvbihldmVudCkge1xuICAgICAqICAvLyB0aGUgZ3JpZCBvbiB3aGljaCB0aGUgb25Sb3dTZWxlY3Rpb25DaGFuZ2UgZXZlbnQgd2FzIHRyaWdnZXJlZFxuICAgICAqICBjb25zdCBncmlkID0gZXZlbnQucm93LmdyaWQ7XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogYGBgaHRtbFxuICAgICAqICA8aWd4LWdyaWRcbiAgICAgKiAgICBbZGF0YV09XCJkYXRhXCJcbiAgICAgKiAgICAob25Sb3dTZWxlY3Rpb25DaGFuZ2UpPVwiaGFuZGxlUm93U2VsZWN0aW9uKCRldmVudClcIj5cbiAgICAgKiAgPC9pZ3gtZ3JpZD5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICAvLyBUT0RPOiBSZWZhY3RvclxuICAgIGdldCBwYXJlbnRHcmlkKCk6IGFueS8qIFRPRE86IElneEhpZXJhcmNoaWNhbEdyaWRDb21wb25lbnQqLyB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWRBUEkuZ3JpZDtcbiAgICB9XG5cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuZGF0YS1sZXZlbCcpXG4gICAgZ2V0IGxldmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXlvdXQubGV2ZWw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG5hdGl2ZSBET00gZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIHJvdy4gQ291bGQgYmUgbnVsbCBpbiBjZXJ0YWluIGVudmlyb25tZW50cy5cbiAgICAgKlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAvLyBnZXQgdGhlIG5hdGl2ZUVsZW1lbnQgb2YgdGhlIHNlY29uZCBzZWxlY3RlZCByb3dcbiAgICAgKiBsZXQgc2VsZWN0ZWRSb3dOYXRpdmVFbGVtZW50ID0gdGhpcy5ncmlkLnNlbGVjdGVkUm93c1sxXS5uYXRpdmVFbGVtZW50O1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGdldCBuYXRpdmVFbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IocHVibGljIGdyaWRBUEk6IEdyaWRCYXNlQVBJU2VydmljZTxhbnkvKiBUT0RPOiBJZ3hIaWVyYXJjaGljYWxHcmlkQ29tcG9uZW50Ki8+LFxuICAgICAgICBwdWJsaWMgZWxlbWVudDogRWxlbWVudFJlZixcbiAgICAgICAgcmVzb2x2ZXI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcbiAgICAgICAgcHVibGljIGNkcjogQ2hhbmdlRGV0ZWN0b3JSZWYpIHtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZXIgPSByZXNvbHZlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMubGF5b3V0Lm9uTGF5b3V0Q2hhbmdlLnN1YnNjcmliZSgoY2gpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZUxheW91dENoYW5nZXMoY2gpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IHRoaXMubGF5b3V0LmluaXRpYWxDaGFuZ2VzO1xuICAgICAgICBjaGFuZ2VzLmZvckVhY2goY2hhbmdlID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZUxheW91dENoYW5nZXMoY2hhbmdlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaEdyaWQucGFyZW50ID0gdGhpcy5wYXJlbnRHcmlkO1xuICAgICAgICB0aGlzLmhHcmlkLnBhcmVudElzbGFuZCA9IHRoaXMubGF5b3V0O1xuICAgICAgICB0aGlzLmhHcmlkLmNoaWxkUm93ID0gIHRoaXM7XG4gICAgICAgIC8vIGhhbmRsZXIgbG9naWMgdGhhdCByZS1lbWl0cyBoZ3JpZCBldmVudHMgb24gdGhlIHJvdyBpc2xhbmRcbiAgICAgICAgdGhpcy5zZXR1cEV2ZW50RW1pdHRlcnMoKTtcbiAgICAgICAgdGhpcy5sYXlvdXQub25HcmlkQ3JlYXRlZC5lbWl0KHtcbiAgICAgICAgICAgIG93bmVyOiB0aGlzLmxheW91dCxcbiAgICAgICAgICAgIHBhcmVudElEOiB0aGlzLnJvd0RhdGEucm93SUQsXG4gICAgICAgICAgICBncmlkOiB0aGlzLmhHcmlkXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIHRoaXMuaEdyaWQuY2hpbGRMYXlvdXRMaXN0ID0gdGhpcy5sYXlvdXQuY2hpbGRyZW47XG4gICAgICAgIGlmICh0aGlzLmxheW91dC5jaGlsZENvbHVtbnMubGVuZ3RoID4gMCAmJiAhdGhpcy5oR3JpZC5hdXRvR2VuZXJhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuaEdyaWQuY3JlYXRlQ29sdW1uc0xpc3QodGhpcy5sYXlvdXQuY2hpbGRDb2x1bW5zLnRvQXJyYXkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGF5b3V0cyA9IHRoaXMuaEdyaWQuY2hpbGRMYXlvdXRMaXN0LnRvQXJyYXkoKTtcbiAgICAgICAgbGF5b3V0cy5mb3JFYWNoKChsKSA9PiB0aGlzLmhHcmlkLmhncmlkQVBJLnJlZ2lzdGVyQ2hpbGRSb3dJc2xhbmQobCkpO1xuICAgICAgICB0aGlzLnBhcmVudEdyaWQuaGdyaWRBUEkucmVnaXN0ZXJDaGlsZEdyaWQodGhpcy5yb3dEYXRhLnJvd0lELCB0aGlzLmxheW91dC5rZXksIHRoaXMuaEdyaWQpO1xuICAgICAgICB0aGlzLmxheW91dC5yb3dJc2xhbmRBUEkucmVnaXN0ZXJDaGlsZEdyaWQodGhpcy5yb3dEYXRhLnJvd0lELCB0aGlzLmhHcmlkKTtcblxuICAgICAgICB0aGlzLmhHcmlkLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBzZXR1cEV2ZW50RW1pdHRlcnMoKSB7XG4gICAgICAgIGNvbnN0IGRlc3RydWN0b3IgPSB0YWtlVW50aWwodGhpcy5oR3JpZC5kZXN0cm95JCk7XG5cbiAgICAgICAgY29uc3QgZmFjdG9yeSA9IHRoaXMucmVzb2x2ZXIucmVzb2x2ZUNvbXBvbmVudEZhY3RvcnkoSWd4R3JpZENvbXBvbmVudCk7XG4gICAgICAgIC8vIGV4Y2x1ZGUgb3V0cHV0cyByZWxhdGVkIHRvIHR3by13YXkgYmluZGluZyBmdW5jdGlvbmFsaXR5XG4gICAgICAgIGNvbnN0IGlucHV0TmFtZXMgPSBmYWN0b3J5LmlucHV0cy5tYXAoaW5wdXQgPT4gaW5wdXQucHJvcE5hbWUpO1xuICAgICAgICBjb25zdCBvdXRwdXRzID0gZmFjdG9yeS5vdXRwdXRzLmZpbHRlcihvID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nSW5wdXRQcm9wTmFtZSA9IG8ucHJvcE5hbWUuc2xpY2UoMCwgby5wcm9wTmFtZS5pbmRleE9mKCdDaGFuZ2UnKSk7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXROYW1lcy5pbmRleE9mKG1hdGNoaW5nSW5wdXRQcm9wTmFtZSkgPT09IC0xO1xuICAgICAgICB9KTtcbiAgICAgICAgb3V0cHV0cy5mb3JFYWNoKG91dHB1dCA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5oR3JpZFtvdXRwdXQucHJvcE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oR3JpZFtvdXRwdXQucHJvcE5hbWVdLnBpcGUoZGVzdHJ1Y3Rvcikuc3Vic2NyaWJlKChhcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFyZ3Mub3duZXIgPSB0aGlzLmhHcmlkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxheW91dFtvdXRwdXQucHJvcE5hbWVdLmVtaXQoYXJncyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuXG4gICAgcHJpdmF0ZSBfaGFuZGxlTGF5b3V0Q2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2hhbmdlIGluIGNoYW5nZXMpIHtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VzLmhhc093blByb3BlcnR5KGNoYW5nZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhHcmlkW2NoYW5nZV0gPSBjaGFuZ2VzW2NoYW5nZV0uY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuIl19