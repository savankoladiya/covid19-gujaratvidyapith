/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { ChangeDetectionStrategy, Component, HostBinding, Input, Output, EventEmitter, forwardRef, TemplateRef, ContentChild, ViewChild } from '@angular/core';
import { IgxTreeGridAPIService } from './tree-grid-api.service';
import { IgxGridBaseComponent } from '../grid-base.component';
import { GridBaseAPIService } from '../api.service';
import { TransactionType } from '../../services/transaction/transaction';
import { IgxFilteringService } from '../filtering/grid-filtering.service';
import { IgxTreeGridNavigationService } from './tree-grid-navigation.service';
import { IgxGridSummaryService } from '../summaries/grid-summary.service';
import { IgxGridSelectionService, IgxGridCRUDService } from '../../core/grid-selection';
import { mergeObjects } from '../../core/utils';
import { first, takeUntil } from 'rxjs/operators';
import { IgxRowLoadingIndicatorTemplateDirective } from './tree-grid.directives';
import { IgxForOfSyncService, IgxForOfScrollSyncService } from '../../directives/for-of/for_of.sync.service';
import { IgxGridNavigationService } from '../grid-navigation.service';
import { IgxRowIslandAPIService } from '../hierarchical-grid/row-island-api.service';
/** @type {?} */
let NEXT_ID = 0;
/**
 * **Ignite UI for Angular Tree Grid** -
 * [Documentation](https://www.infragistics.com/products/ignite-ui-angular/angular/components/grid.html)
 *
 * The Ignite UI Tree Grid displays and manipulates hierarchical data with consistent schema formatted as a table and
 * provides features such as sorting, filtering, editing, column pinning, paging, column moving and hiding.
 *
 * Example:
 * ```html
 * <igx-tree-grid [data]="employeeData" primaryKey="employeeID" foreignKey="PID" autoGenerate="false">
 *   <igx-column field="first" header="First Name"></igx-column>
 *   <igx-column field="last" header="Last Name"></igx-column>
 *   <igx-column field="role" header="Role"></igx-column>
 * </igx-tree-grid>
 * ```
 */
export class IgxTreeGridComponent extends IgxGridBaseComponent {
    constructor() {
        super(...arguments);
        this._id = `igx-tree-grid-${NEXT_ID++}`;
        /**
         * Returns a map of all `ITreeGridRecord`s.
         * ```typescript
         * // gets the record with primaryKey=2
         * const states = this.grid.records.get(2);
         * ```
         * \@memberof IgxTreeGridComponent
         */
        this.records = new Map();
        /**
         * Returns a map of all processed (filtered and sorted) `ITreeGridRecord`s.
         * ```typescript
         * // gets the processed record with primaryKey=2
         * const states = this.grid.processedRecords.get(2);
         * ```
         * \@memberof IgxTreeGridComponent
         */
        this.processedRecords = new Map();
        /**
         * An \@Input property indicating whether child records should be deleted when their parent gets deleted.
         * By default it is set to true and deletes all children along with the parent.
         * ```html
         * <igx-tree-grid [data]="employeeData" [primaryKey]="'employeeID'" [foreignKey]="'parentID'" cascadeOnDelete="false">
         * </igx-tree-grid>
         * ```
         * \@memberof IgxTreeGridComponent
         */
        this.cascadeOnDelete = true;
        this._expansionDepth = Infinity;
        this._expansionStates = new Map();
        /**
         * @hidden
         */
        this.expansionStatesChange = new EventEmitter();
        /**
         * Emitted when the expanded state of a row gets changed.
         * ```typescript
         * rowToggle(event: IRowToggleEventArgs){
         *  // the id of the row
         *  const rowID = event.rowID;
         *  // the new expansion state
         *  const newExpandedState = event.expanded;
         *  // the original event that triggered onRowToggle
         *  const originalEvent = event.event;
         *  // whether the event should be cancelled
         *  event.cancel = true;
         * }
         * ```
         * ```html
         * <igx-tree-grid [data]="employeeData" (onRowToggle)="rowToggle($event)" [autoGenerate]="true"></igx-tree-grid>
         * ```
         * \@memberof IgxTreeGridComponent
         */
        this.onRowToggle = new EventEmitter();
        /**
         * @hidden
         */
        this.loadingRows = new Set();
        this._filteredData = null;
    }
    /**
     * An \@Input property that sets the value of the `id` attribute. If not provided it will be automatically generated.
     * ```html
     * <igx-tree-grid [id]="'igx-tree-grid-1'"></igx-tree-grid>
     * ```
     * \@memberof IgxTreeGridComponent
     * @return {?}
     */
    get id() {
        return this._id;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set id(value) {
        this._id = value;
    }
    /**
     * An \@Input property that lets you fill the `IgxTreeGridComponent` with an array of data.
     * ```html
     * <igx-tree-grid [data]="Data" [autoGenerate]="true"></igx-tree-grid>
     * ```
     * \@memberof IgxTreeGridComponent
     * @return {?}
     */
    get data() {
        return this._data;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set data(value) {
        this._data = value || [];
        this.summaryService.clearSummaryCache();
        if (this.shouldGenerate) {
            this.setupColumns();
        }
        this.cdr.markForCheck();
    }
    /**
     * Returns an array of objects containing the filtered data in the `IgxGridComponent`.
     * ```typescript
     * let filteredData = this.grid.filteredData;
     * ```
     * \@memberof IgxTreeGridComponent
     * @return {?}
     */
    get filteredData() {
        return this._filteredData;
    }
    /**
     * Sets an array of objects containing the filtered data in the `IgxGridComponent`.
     * ```typescript
     * this.grid.filteredData = [{
     *       ID: 1,
     *       Name: "A"
     * }];
     * ```
     * \@memberof IgxTreeGridComponent
     * @param {?} value
     * @return {?}
     */
    set filteredData(value) {
        this._filteredData = value;
    }
    /**
     * Get transactions service for the grid.
     * \@experimental \@hidden
     * @return {?}
     */
    get transactions() {
        return this._transactions;
    }
    /**
     * An \@Input property that sets the count of levels to be expanded in the `IgxTreeGridComponent`. By default it is
     * set to `Infinity` which means all levels would be expanded.
     * ```html
     * <igx-tree-grid #grid [data]="employeeData" [childDataKey]="'employees'" expansionDepth="1" [autoGenerate]="true"></igx-tree-grid>
     * ```
     * \@memberof IgxTreeGridComponent
     * @return {?}
     */
    get expansionDepth() {
        return this._expansionDepth;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set expansionDepth(value) {
        this._expansionDepth = value;
        this.notifyChanges();
    }
    /**
     * Returns a list of key-value pairs [row ID, expansion state]. Includes only states that differ from the default one.
     * ```typescript
     * const expansionStates = this.grid.expansionStates;
     * ```
     * \@memberof IgxTreeGridComponent
     * @return {?}
     */
    get expansionStates() {
        return this._expansionStates;
    }
    /**
     * Sets a list of key-value pairs [row ID, expansion state].
     * ```typescript
     * const states = new Map<any, boolean>();
     * states.set(1, true);
     * this.grid.expansionStates = states;
     * ```
     *
     * Two-way data binding.
     * ```html
     * <igx-tree-grid #grid [data]="employeeData" [childDataKey]="'employees'" [(expansionStates)]="model.expansionStates">
     * </igx-tree-grid>
     * ```
     * \@memberof IgxTreeGridComponent
     * @param {?} value
     * @return {?}
     */
    set expansionStates(value) {
        this._expansionStates = this.cloneMap(value);
        this.expansionStatesChange.emit(this._expansionStates);
        if (this.gridAPI.grid) {
            this.cdr.detectChanges();
        }
    }
    /**
     * An \@Input property that provides a template for the row loading indicator when load on demand is enabled.
     * ```html
     * <ng-template #rowLoadingTemplate>
     *     <igx-icon fontSet="material">loop</igx-icon>
     * </ng-template>
     *
     * <igx-tree-grid #grid [data]="employeeData" [primaryKey]="'ID'" [foreignKey]="'parentID'"
     *                [loadChildrenOnDemand]="loadChildren"
     *                [rowLoadingIndicatorTemplate]="rowLoadingTemplate">
     * </igx-tree-grid>
     * ```
     * \@memberof IgxTreeGridComponent
     * @return {?}
     */
    get rowLoadingIndicatorTemplate() {
        return this._rowLoadingIndicatorTemplate;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set rowLoadingIndicatorTemplate(value) {
        this._rowLoadingIndicatorTemplate = value;
        this.notifyChanges();
    }
    // Kind of stupid
    /**
     * @private
     * @return {?}
     */
    get _gridAPI() {
        return (/** @type {?} */ (this.gridAPI));
    }
    /**
     * @hidden
     * @return {?}
     */
    ngOnInit() {
        super.ngOnInit();
        this.onRowToggle.pipe(takeUntil(this.destroy$)).subscribe((args) => {
            this.loadChildrenOnRowExpansion(args);
        });
    }
    /**
     * @return {?}
     */
    ngDoCheck() {
        super.ngDoCheck();
    }
    /**
     * @hidden
     * @return {?}
     */
    ngAfterContentInit() {
        if (this.rowLoadingTemplate) {
            this._rowLoadingIndicatorTemplate = this.rowLoadingTemplate.template;
        }
        super.ngAfterContentInit();
    }
    /**
     * @private
     * @param {?} args
     * @return {?}
     */
    loadChildrenOnRowExpansion(args) {
        if (this.loadChildrenOnDemand) {
            /** @type {?} */
            const parentID = args.rowID;
            if (args.expanded && !this._expansionStates.has(parentID)) {
                this.loadingRows.add(parentID);
                this.loadChildrenOnDemand(parentID, children => {
                    this.loadingRows.delete(parentID);
                    this.addChildRows(children, parentID);
                    this.notifyChanges();
                    requestAnimationFrame(() => {
                        /** @type {?} */
                        const cellID = this.selectionService.activeElement;
                        if (cellID) {
                            /** @type {?} */
                            const cell = this._gridAPI.get_cell_by_index(cellID.row, cellID.column);
                            if (cell) {
                                cell.nativeElement.focus();
                            }
                        }
                    });
                });
            }
        }
    }
    /**
     * @private
     * @param {?} children
     * @param {?} parentID
     * @return {?}
     */
    addChildRows(children, parentID) {
        if (this.primaryKey && this.foreignKey) {
            for (const child of children) {
                child[this.foreignKey] = parentID;
            }
            this.data.push(...children);
        }
        else if (this.childDataKey) {
            /** @type {?} */
            let parent = this.records.get(parentID);
            /** @type {?} */
            let parentData = parent.data;
            if (this.transactions.enabled && this.transactions.getAggregatedChanges(true).length) {
                /** @type {?} */
                const path = [];
                while (parent) {
                    path.push(parent.rowID);
                    parent = parent.parent;
                }
                /** @type {?} */
                let collection = this.data;
                /** @type {?} */
                let record;
                for (let i = path.length - 1; i >= 0; i--) {
                    /** @type {?} */
                    const pid = path[i];
                    record = collection.find(r => r[this.primaryKey] === pid);
                    if (!record) {
                        break;
                    }
                    collection = record[this.childDataKey];
                }
                if (record) {
                    parentData = record;
                }
            }
            parentData[this.childDataKey] = children;
        }
        this.selectionService.clearHeaderCBState();
        this._pipeTrigger++;
    }
    /**
     * @private
     * @param {?} mapIn
     * @return {?}
     */
    cloneMap(mapIn) {
        /** @type {?} */
        const mapCloned = new Map();
        mapIn.forEach((value, key, mapObj) => {
            mapCloned.set(key, value);
        });
        return mapCloned;
    }
    /**
     * Expands the `IgxTreeGridRowComponent` with the specified rowID.
     * \@memberof IgxTreeGridComponent
     * @param {?} rowID The identifier of the row to be expanded.
     * ```typescript
     * this.grid.expandRow(2);
     * ```
     * @return {?}
     */
    expandRow(rowID) {
        this._gridAPI.expand_row(rowID);
    }
    /**
     * Collapses the `IgxTreeGridRowComponent` with the specified rowID.
     * \@memberof IgxTreeGridComponent
     * @param {?} rowID The identifier of the row to be collapsed.
     * ```typescript
     * this.grid.collapseRow(2);
     * ```
     * @return {?}
     */
    collapseRow(rowID) {
        this._gridAPI.collapse_row(rowID);
    }
    /**
     * Toggles the expansion state of the `IgxTreeGridRowComponent` with the specified rowID.
     * \@memberof IgxTreeGridComponent
     * @param {?} rowID The identifier of the row to be toggled.
     * ```typescript
     * this.grid.toggleRow(2);
     * ```
     * @return {?}
     */
    toggleRow(rowID) {
        this._gridAPI.toggle_row_expansion(rowID);
    }
    /**
     * Expands all rows.
     * ```typescript
     * this.grid.expandAll();
     * ```
     * \@memberof IgxTreeGridComponent
     * @return {?}
     */
    expandAll() {
        this._expansionDepth = Infinity;
        this.expansionStates = new Map();
    }
    /**
     * Collapses all rows.
     * ```typescript
     * this.grid.collapseAll();
     * ```
     * \@memberof IgxTreeGridComponent
     * @return {?}
     */
    collapseAll() {
        this._expansionDepth = 0;
        this.expansionStates = new Map();
    }
    /**
     * Creates a new `IgxTreeGridRowComponent` with the given data. If a parentRowID is not specified, the newly created
     * row would be added at the root level. Otherwise, it would be added as a child of the row whose primaryKey matches
     * the specified parentRowID. If the parentRowID does not exist, an error would be thrown.
     * ```typescript
     * const record = {
     *     ID: this.grid.data[this.grid1.data.length - 1].ID + 1,
     *     Name: this.newRecord
     * };
     * this.grid.addRow(record, 1); // Adds a new child row to the row with ID=1.
     * ```
     * \@memberof IgxTreeGridComponent
     * @param {?} data
     * @param {?=} parentRowID
     * @return {?}
     */
    addRow(data, parentRowID) {
        if (parentRowID !== undefined && parentRowID !== null) {
            super.endEdit(true);
            /** @type {?} */
            const state = this.transactions.getState(parentRowID);
            // we should not allow adding of rows as child of deleted row
            if (state && state.type === TransactionType.DELETE) {
                throw Error(`Cannot add child row to deleted parent row`);
            }
            /** @type {?} */
            const parentRecord = this.records.get(parentRowID);
            if (!parentRecord) {
                throw Error('Invalid parent row ID!');
            }
            this.summaryService.clearSummaryCache({ rowID: parentRecord.rowID });
            if (this.primaryKey && this.foreignKey) {
                data[this.foreignKey] = parentRowID;
                super.addRow(data);
            }
            else {
                /** @type {?} */
                const parentData = parentRecord.data;
                /** @type {?} */
                const childKey = this.childDataKey;
                if (this.transactions.enabled) {
                    /** @type {?} */
                    const rowId = this.primaryKey ? data[this.primaryKey] : data;
                    /** @type {?} */
                    const path = [];
                    path.push(...this.generateRowPath(parentRowID));
                    path.push(parentRowID);
                    this.transactions.add((/** @type {?} */ ({
                        id: rowId,
                        path: path,
                        newValue: data,
                        type: TransactionType.ADD
                    })), null);
                }
                else {
                    if (!parentData[childKey]) {
                        parentData[childKey] = [];
                    }
                    parentData[childKey].push(data);
                }
                this.onRowAdded.emit({ data });
                this._pipeTrigger++;
                this.notifyChanges();
            }
        }
        else {
            if (this.primaryKey && this.foreignKey) {
                /** @type {?} */
                const rowID = data[this.foreignKey];
                this.summaryService.clearSummaryCache({ rowID: rowID });
            }
            super.addRow(data);
        }
    }
    /**
     * @hidden
     * @param {?} rowId
     * @return {?}
     */
    deleteRowById(rowId) {
        //  if this is flat self-referencing data, and CascadeOnDelete is set to true
        //  and if we have transactions we should start pending transaction. This allows
        //  us in case of delete action to delete all child rows as single undo action
        this._gridAPI.deleteRowById(rowId);
    }
    /**
     * @hidden
     * @param {?} rowId
     * @return {?}
     */
    generateRowPath(rowId) {
        /** @type {?} */
        const path = [];
        /** @type {?} */
        let record = this.records.get(rowId);
        while (record.parent) {
            path.push(record.parent.rowID);
            record = record.parent;
        }
        return path.reverse();
    }
    /**
     * @hidden \@internal
     * @protected
     * @return {?}
     */
    getDataBasedBodyHeight() {
        return !this.flatData || (this.flatData.length < this._defaultTargetRecordNumber) ?
            0 : this.defaultTargetBodyHeight;
    }
    /**
     * @hidden
     * @protected
     * @param {?} row
     * @param {?} column
     * @return {?}
     */
    scrollTo(row, column) {
        /** @type {?} */
        let delayScrolling = false;
        /** @type {?} */
        let record;
        if (typeof (row) !== 'number') {
            /** @type {?} */
            const rowData = row;
            /** @type {?} */
            const rowID = this._gridAPI.get_row_id(rowData);
            record = this.processedRecords.get(rowID);
            this._gridAPI.expand_path_to_record(record);
            if (this.paging) {
                /** @type {?} */
                const rowIndex = this.processedExpandedFlatData.indexOf(rowData);
                /** @type {?} */
                const page = Math.floor(rowIndex / this.perPage);
                if (this.page !== page) {
                    delayScrolling = true;
                    this.page = page;
                }
            }
        }
        if (delayScrolling) {
            this.verticalScrollContainer.onDataChanged.pipe(first()).subscribe(() => {
                this.scrollDirective(this.verticalScrollContainer, typeof (row) === 'number' ? row : this.dataView.indexOf(record));
            });
        }
        else {
            this.scrollDirective(this.verticalScrollContainer, typeof (row) === 'number' ? row : this.dataView.indexOf(record));
        }
        this.scrollToHorizontally(column);
    }
    /**
     * @hidden
     * @param {?} rowData
     * @param {?} rowIndex
     * @return {?}
     */
    getContext(rowData, rowIndex) {
        return {
            $implicit: rowData,
            index: rowIndex,
            templateID: this.isSummaryRow(rowData) ? 'summaryRow' : 'dataRow'
        };
    }
    /**
     * \@inheritdoc
     * @param {?=} formatters
     * @param {?=} headers
     * @return {?}
     */
    getSelectedData(formatters = false, headers = false) {
        /** @type {?} */
        const source = [];
        /** @type {?} */
        const process = (record) => {
            if (record.summaries) {
                source.push(null);
                return;
            }
            source.push(record.data);
        };
        this.dataView.forEach(process);
        return this.extractDataFromSelection(source, formatters, headers);
    }
    /**
     * @hidden
     * @return {?}
     */
    get template() {
        if (this.filteredData && this.filteredData.length === 0) {
            return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyFilteredGridTemplate;
        }
        if (this.isLoading && (!this.data || this.dataLength === 0)) {
            return this.loadingGridTemplate ? this.loadingGridTemplate : this.loadingGridDefaultTemplate;
        }
        if (this.dataLength === 0) {
            return this.emptyGridTemplate ? this.emptyGridTemplate : this.emptyGridDefaultTemplate;
        }
    }
    /**
     * @protected
     * @param {?} rowIndex
     * @param {?} value
     * @return {?}
     */
    writeToData(rowIndex, value) {
        mergeObjects(this.flatData[rowIndex], value);
    }
    /**
     * @hidden
     * @protected
     * @param {?} collection
     * @param {?=} cb
     * @return {?}
     */
    initColumns(collection, cb = null) {
        if (this.hasColumnLayouts) {
            // invalid configuration - tree grid should not allow column layouts
            // remove column layouts
            /** @type {?} */
            const nonColumnLayoutColumns = this.columnList.filter((col) => !col.columnLayout && !col.columnLayoutChild);
            this.columnList.reset(nonColumnLayoutColumns);
        }
        super.initColumns(collection, cb);
    }
}
IgxTreeGridComponent.decorators = [
    { type: Component, args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                selector: 'igx-tree-grid',
                template: "<igx-grid-toolbar role=\"rowgroup\" [style.flex-basis.px]='outerWidth' *ngIf=\"showToolbar\" [gridID]=\"id\"\n    [displayDensity]=\"displayDensity\" #toolbar>\n</igx-grid-toolbar>\n\n<div class=\"igx-grid__thead\">\n    <div class=\"igx-grid__thead-wrapper\" role=\"rowgroup\" [style.width.px]='calcWidth' #theadRow>\n        <div class=\"igx-grid__tr\" [style.width.px]='calcWidth' role=\"row\">\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-left\" [style.left.px]=\"featureColumnsWidth\"></span>\n            <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n                [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n                class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n            <ng-container *ngIf=\"rowDraggable\">\n                <div class=\"igx-grid__drag-indicator\" #headerDragContainer>\n                    <div style=\"visibility: hidden;\">\n                        <ng-container\n                            *ngTemplateOutlet=\"this.dragIndicatorIconTemplate ? this.dragIndicatorIconTemplate : this.dragIndicatorIconBase\">\n                        </ng-container>\n                    </div>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"showRowSelectors\">\n                <div class=\"igx-grid__cbx-selection\" (click)=\"onHeaderSelectorClick($event)\" #headerSelectorContainer [ngClass]=\"{\n                    'igx-grid__cbx-selection--push': filteringService.isFilterRowVisible }\">\n                    <ng-template #headSelector\n                        *ngTemplateOutlet=\"\n                        this.headSelectorTemplate ? this.headSelectorTemplate : headSelectorBaseTemplate;\n                        context: { $implicit: {\n                                        selectedCount: this.selectionService.filteredSelectedRowIds.length,\n                                        totalCount: this.totalRowsCountAfterFilter }}\">\n                    </ng-template>\n                </div>\n            </ng-container>\n            <ng-container *ngIf=\"pinnedColumns.length > 0\">\n                <ng-template ngFor let-col [ngForOf]=\"pinnedColumns | igxTopLevel\">\n                    <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width.px]=\"getHeaderGroupWidth(col)\"\n                        [style.flex-basis.px]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n                </ng-template>\n            </ng-container>\n            <ng-template igxGridFor let-col [igxGridForOf]=\"unpinnedColumns | igxTopLevel\"\n                [igxForScrollOrientation]=\"'horizontal'\" [igxForScrollContainer]=\"parentVirtDir\"\n                [igxForContainerSize]='unpinnedWidth' [igxForTrackBy]='trackColumnChanges'\n                [igxForSizePropName]=\"'calcPixelWidth'\" #hContainer>\n                <igx-grid-header-group [column]=\"col\" [gridID]=\"id\" [style.min-width.px]=\"getHeaderGroupWidth(col)\"\n                    [style.flex-basis.px]=\"getHeaderGroupWidth(col)\"></igx-grid-header-group>\n            </ng-template>\n        </div>\n        <igx-grid-filtering-row #filteringRow *ngIf=\"filteringService.isFilterRowVisible\"\n            [column]=\"filteringService.filteredColumn\"></igx-grid-filtering-row>\n    </div>\n    <div class=\"igx-grid__thead-thumb\" [hidden]='!hasVerticalSroll()' [style.width.px]=\"scrollWidth\"></div>\n    <div [style.display]=\"shouldOverlayLoading ? 'flex' : 'none'\" #loadingOverlay>\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n</div>\n\n<div igxGridBody (keydown.control.c)=\"copyHandlerIE()\" (copy)=\"copyHandler($event)\" class=\"igx-grid__tbody\">\n    <div class=\"igx-grid__tbody-content\" role=\"rowgroup\" (onDragStop)=\"selectionService.dragMode = $event\"\n        (onDragScroll)=\"dragScroll($event)\" [igxGridDragSelect]=\"selectionService.dragMode\"\n        [style.height.px]='calcHeight' [style.width.px]='calcWidth' #tbody (scroll)='scrollHandler($event)'\n        (wheel)=\"wheelHandler()\">\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length <= 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-left\"></span>\n        <span *ngIf=\"hasMovableColumns && draggedColumn && pinnedColumns.length > 0\"\n            [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\" id=\"left\"\n            class=\"igx-grid__scroll-on-drag-pinned\" [style.left.px]=\"pinnedWidth\"></span>\n        <ng-template igxGridFor let-rowData\n            [igxGridForOf]=\"data\n        | treeGridTransaction:id:pipeTrigger\n        | visibleColumns:hasVisibleColumns\n        | treeGridHierarchizing:primaryKey:foreignKey:childDataKey:id:pipeTrigger\n        | treeGridFiltering:filteringExpressionsTree:filterStrategy:advancedFilteringExpressionsTree:id:pipeTrigger:filteringPipeTrigger\n        | treeGridSorting:sortingExpressions:id:pipeTrigger\n        | treeGridFlattening:id:expansionDepth:expansionStates:pipeTrigger\n        | treeGridPaging:page:perPage:id:pipeTrigger\n        | treeGridSummary:hasSummarizedColumns:summaryCalculationMode:summaryPosition:id:pipeTrigger:summaryPipeTrigger\" let-rowIndex=\"index\"\n            [igxForScrollOrientation]=\"'vertical'\" [igxForScrollContainer]='verticalScroll'\n            [igxForContainerSize]='calcHeight' [igxForItemSize]=\"renderedRowHeight\" #verticalScrollContainer\n            (onChunkPreload)=\"dataLoading($event)\">\n            <ng-template #record_template>\n                <igx-tree-grid-row [gridID]=\"id\" [index]=\"rowIndex\" [treeRow]=\"rowData\" #row>\n                </igx-tree-grid-row>\n            </ng-template>\n            <ng-template #summary_template>\n                <igx-grid-summary-row [gridID]=\"id\" [summaries]=\"rowData.summaries\"\n                    [firstCellIndentation]=\"rowData.cellIndentation\" [index]=\"rowIndex\"\n                    class=\"igx-grid__summaries--body\" #summaryRow>\n                </igx-grid-summary-row>\n            </ng-template>\n\n            <ng-template [igxTemplateOutlet]='isSummaryRow(rowData) ? summary_template : record_template'\n                [igxTemplateOutletContext]='getContext(rowData, rowIndex)'\n                (onCachedViewLoaded)='cachedViewLoaded($event)'\n                (onBeforeViewDetach)='viewDetachHandler($event)'>\n            </ng-template>\n        </ng-template>\n        <ng-container *ngTemplateOutlet=\"template\"></ng-container>\n        <div class=\"igx-grid__row-editing-outlet\" igxOverlayOutlet #igxRowEditingOverlayOutlet></div>\n    </div>\n    <span *ngIf=\"hasMovableColumns && draggedColumn\" [igxColumnMovingDrop]=\"headerContainer\" [attr.droppable]=\"true\"\n        id=\"right\" class=\"igx-grid__scroll-on-drag-right\"></span>\n    <div [hidden]='!hasVerticalSroll()' class=\"igx-grid__tbody-scrollbar\" [style.width.px]=\"scrollWidth\"\n        [style.height.px]='calcHeight'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #verticalScrollHolder></ng-template>\n    </div>\n</div>\n\n<div class=\"igx-grid__tfoot\" role=\"rowgroup\" [style.height.px]='summariesHeight' #tfoot>\n    <igx-grid-summary-row [style.width.px]='calcWidth' [style.height.px]='summariesHeight'\n        *ngIf=\"hasSummarizedColumns && rootSummariesEnabled\" [gridID]=\"id\"\n        [summaries]=\"id | igxGridSummaryDataPipe:summaryService.retriggerRootPipe\" [index]=\"0\"\n        class=\"igx-grid__summaries\" #summaryRow>\n    </igx-grid-summary-row>\n    <div class=\"igx-grid__tfoot-thumb\" [hidden]='!hasVerticalSroll()' [style.height.px]='summariesHeight'\n        [style.width.px]=\"scrollWidth\"></div>\n</div>\n\n<div class=\"igx-grid__scroll\" [style.height]=\"'18px'\" #scr [hidden]=\"isHorizontalScrollHidden\">\n    <div class=\"igx-grid__scroll-start\" [style.width.px]='pinnedWidth' [hidden]=\"pinnedWidth === 0\"></div>\n    <div class=\"igx-grid__scroll-main\" [style.width.px]='unpinnedWidth'>\n        <ng-template igxGridFor [igxGridForOf]='[]' #scrollContainer>\n        </ng-template>\n    </div>\n</div>\n\n<div class=\"igx-grid__footer\" #footer>\n    <ng-content select=\"igx-grid-footer\"></ng-content>\n    <ng-container *ngIf=\"paging && totalRecords\">\n        <ng-container\n            *ngTemplateOutlet=\"paginationTemplate ? paginationTemplate : defaultPaginator; context: {$implicit: this}\">\n        </ng-container>\n    </ng-container>\n</div>\n\n<ng-template #defaultPaginator>\n    <igx-paginator [displayDensity]=\"displayDensity\" [(page)]=\"page\" [totalRecords]=\"processedExpandedFlatData.length\"\n        [(perPage)]=\"perPage\">\n    </igx-paginator>\n</ng-template>\n\n<ng-template #emptyFilteredGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyFilteredGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultEmptyGrid>\n    <span class=\"igx-grid__tbody-message\">{{emptyGridMessage}}</span>\n</ng-template>\n\n<ng-template #defaultLoadingGrid>\n    <div class=\"igx-grid__loading\">\n        <igx-circular-bar [indeterminate]=\"true\">\n        </igx-circular-bar>\n    </div>\n</ng-template>\n\n<div *ngIf=\"rowEditable\" igxToggle>\n    <div [className]=\"bannerClass\">\n        <ng-container\n            *ngTemplateOutlet=\"rowEditContainer; context: { rowChangesCount: rowChangesCount, endEdit: endEdit.bind(this) }\">\n        </ng-container>\n    </div>\n</div>\n\n<ng-template #defaultRowEditText>\n    You have {{ rowChangesCount }} changes in this row\n</ng-template>\n\n<ng-template #defaultRowEditActions>\n    <button igxButton igxRowEditTabStop (click)=\"endEdit(false, $event)\">Cancel</button>\n    <button igxButton igxRowEditTabStop (click)=\"endEdit(true, $event)\">Done</button>\n</ng-template>\n\n<ng-template #defaultRowEditTemplate>\n    <div class=\"igx-banner__message\">\n        <span class=\"igx-banner__text\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditText ? rowEditText : defaultRowEditText; context: { $implicit: rowChangesCount }\">\n            </ng-container>\n        </span>\n    </div>\n    <div class=\"igx-banner__actions\">\n        <div class=\"igx-banner__row\">\n            <ng-container\n                *ngTemplateOutlet=\"rowEditActions ? rowEditActions : defaultRowEditActions; context: { $implicit: endEdit.bind(this) }\">\n            </ng-container>\n        </div>\n    </div>\n</ng-template>\n\n<ng-template #dragIndicatorIconBase>\n    <igx-icon fontSet=\"material\">drag_indicator</igx-icon>\n</ng-template>\n\n<ng-template #headSelectorBaseTemplate igxHeadSelector let-context>\n    <div class=\"igx-grid__cbx-padding\">\n        <igx-checkbox\n            [checked]=\"context.selectedCount > 0 && context.totalCount === context.selectedCount\"\n            [ngStyle]=\"{'visibility': isMultiRowSelectionEnabled? 'visible' : 'hidden' }\"\n            [readonly]=\"true\"\n            disableRipple=\"true\"\n            [indeterminate]=\"context.selectedCount > 0 && context.selectedCount !== context.totalCount\"\n            [aria-label]=\"headSelectorBaseAriaLabel\"\n            #headerCheckbox>\n        </igx-checkbox>\n    </div>\n</ng-template>\n\n<igx-grid-column-resizer *ngIf=\"colResizingService.showResizer\"></igx-grid-column-resizer>\n<div class=\"igx-grid__loading-outlet\" #igxLoadingOverlayOutlet igxOverlayOutlet></div>\n<div class=\"igx-grid__outlet\" #igxFilteringOverlayOutlet igxOverlayOutlet (keydown)=\"gridOutletKeyboardHandler($event)\"></div>\n",
                providers: [
                    IgxGridSelectionService,
                    IgxGridCRUDService,
                    IgxGridSummaryService,
                    { provide: IgxGridNavigationService, useClass: IgxTreeGridNavigationService },
                    { provide: GridBaseAPIService, useClass: IgxTreeGridAPIService },
                    { provide: IgxGridBaseComponent, useExisting: forwardRef(() => IgxTreeGridComponent) },
                    IgxFilteringService,
                    IgxForOfSyncService,
                    IgxForOfScrollSyncService,
                    IgxRowIslandAPIService
                ]
            }] }
];
IgxTreeGridComponent.propDecorators = {
    id: [{ type: HostBinding, args: ['attr.id',] }, { type: Input }],
    data: [{ type: Input }],
    childDataKey: [{ type: Input }],
    foreignKey: [{ type: Input }],
    hasChildrenKey: [{ type: Input }],
    cascadeOnDelete: [{ type: Input }],
    expansionDepth: [{ type: Input }],
    expansionStates: [{ type: Input }],
    expansionStatesChange: [{ type: Output }],
    rowLoadingTemplate: [{ type: ContentChild, args: [IgxRowLoadingIndicatorTemplateDirective, { read: IgxRowLoadingIndicatorTemplateDirective, static: false },] }],
    rowLoadingIndicatorTemplate: [{ type: Input }],
    loadChildrenOnDemand: [{ type: Input }],
    onRowToggle: [{ type: Output }],
    dragIndicatorIconBase: [{ type: ViewChild, args: ['dragIndicatorIconBase', { read: TemplateRef, static: true },] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    IgxTreeGridComponent.prototype._id;
    /**
     * @type {?}
     * @private
     */
    IgxTreeGridComponent.prototype._data;
    /**
     * @type {?}
     * @private
     */
    IgxTreeGridComponent.prototype._rowLoadingIndicatorTemplate;
    /**
     * @type {?}
     * @protected
     */
    IgxTreeGridComponent.prototype._transactions;
    /**
     * @hidden
     * @type {?}
     */
    IgxTreeGridComponent.prototype.flatData;
    /**
     * @hidden
     * @type {?}
     */
    IgxTreeGridComponent.prototype.processedExpandedFlatData;
    /**
     * Returns an array of the root level `ITreeGridRecord`s.
     * ```typescript
     * // gets the root record with index=2
     * const states = this.grid.rootRecords[2];
     * ```
     * \@memberof IgxTreeGridComponent
     * @type {?}
     */
    IgxTreeGridComponent.prototype.rootRecords;
    /**
     * Returns a map of all `ITreeGridRecord`s.
     * ```typescript
     * // gets the record with primaryKey=2
     * const states = this.grid.records.get(2);
     * ```
     * \@memberof IgxTreeGridComponent
     * @type {?}
     */
    IgxTreeGridComponent.prototype.records;
    /**
     * Returns an array of processed (filtered and sorted) root `ITreeGridRecord`s.
     * ```typescript
     * // gets the processed root record with index=2
     * const states = this.grid.processedRootRecords[2];
     * ```
     * \@memberof IgxTreeGridComponent
     * @type {?}
     */
    IgxTreeGridComponent.prototype.processedRootRecords;
    /**
     * Returns a map of all processed (filtered and sorted) `ITreeGridRecord`s.
     * ```typescript
     * // gets the processed record with primaryKey=2
     * const states = this.grid.processedRecords.get(2);
     * ```
     * \@memberof IgxTreeGridComponent
     * @type {?}
     */
    IgxTreeGridComponent.prototype.processedRecords;
    /**
     * An \@Input property that sets the child data key of the `IgxTreeGridComponent`.
     * ```html
     * <igx-tree-grid #grid [data]="employeeData" [childDataKey]="'employees'" [autoGenerate]="true"></igx-tree-grid>
     * ```
     * \@memberof IgxTreeGridComponent
     * @type {?}
     */
    IgxTreeGridComponent.prototype.childDataKey;
    /**
     * An \@Input property that sets the foreign key of the `IgxTreeGridComponent`.
     * ```html
     * <igx-tree-grid #grid [data]="employeeData" [primaryKey]="'employeeID'" [foreignKey]="'parentID'" [autoGenerate]="true">
     * </igx-tree-grid>
     * ```
     * \@memberof IgxTreeGridComponent
     * @type {?}
     */
    IgxTreeGridComponent.prototype.foreignKey;
    /**
     * An \@Input property that sets the key indicating whether a row has children.
     * This property is only used for load on demand scenarios.
     * ```html
     * <igx-tree-grid #grid [data]="employeeData" [primaryKey]="'employeeID'" [foreignKey]="'parentID'"
     *                [loadChildrenOnDemand]="loadChildren"
     *                [hasChildrenKey]="'hasEmployees'">
     * </igx-tree-grid>
     * ```
     * \@memberof IgxTreeGridComponent
     * @type {?}
     */
    IgxTreeGridComponent.prototype.hasChildrenKey;
    /**
     * An \@Input property indicating whether child records should be deleted when their parent gets deleted.
     * By default it is set to true and deletes all children along with the parent.
     * ```html
     * <igx-tree-grid [data]="employeeData" [primaryKey]="'employeeID'" [foreignKey]="'parentID'" cascadeOnDelete="false">
     * </igx-tree-grid>
     * ```
     * \@memberof IgxTreeGridComponent
     * @type {?}
     */
    IgxTreeGridComponent.prototype.cascadeOnDelete;
    /**
     * @type {?}
     * @private
     */
    IgxTreeGridComponent.prototype._expansionDepth;
    /**
     * @type {?}
     * @private
     */
    IgxTreeGridComponent.prototype._expansionStates;
    /**
     * @hidden
     * @type {?}
     */
    IgxTreeGridComponent.prototype.expansionStatesChange;
    /**
     * @hidden
     * @type {?}
     * @protected
     */
    IgxTreeGridComponent.prototype.rowLoadingTemplate;
    /**
     * An \@Input property that provides a callback for loading child rows on demand.
     * ```html
     * <igx-tree-grid [data]="employeeData" [primaryKey]="'employeeID'" [foreignKey]="'parentID'" [loadChildrenOnDemand]="loadChildren">
     * </igx-tree-grid>
     * ```
     * ```typescript
     * public loadChildren = (parentID: any, done: (children: any[]) => void) => {
     *     this.dataService.getData(parentID, children => done(children));
     * }
     * ```
     * \@memberof IgxTreeGridComponent
     * @type {?}
     */
    IgxTreeGridComponent.prototype.loadChildrenOnDemand;
    /**
     * Emitted when the expanded state of a row gets changed.
     * ```typescript
     * rowToggle(event: IRowToggleEventArgs){
     *  // the id of the row
     *  const rowID = event.rowID;
     *  // the new expansion state
     *  const newExpandedState = event.expanded;
     *  // the original event that triggered onRowToggle
     *  const originalEvent = event.event;
     *  // whether the event should be cancelled
     *  event.cancel = true;
     * }
     * ```
     * ```html
     * <igx-tree-grid [data]="employeeData" (onRowToggle)="rowToggle($event)" [autoGenerate]="true"></igx-tree-grid>
     * ```
     * \@memberof IgxTreeGridComponent
     * @type {?}
     */
    IgxTreeGridComponent.prototype.onRowToggle;
    /**
     * @hidden
     * @type {?}
     */
    IgxTreeGridComponent.prototype.loadingRows;
    /**
     * @type {?}
     * @private
     */
    IgxTreeGridComponent.prototype._filteredData;
    /**
     * @hidden
     * \@internal
     * @type {?}
     */
    IgxTreeGridComponent.prototype.dragIndicatorIconBase;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS1ncmlkLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2lnbml0ZXVpLWFuZ3VsYXIvIiwic291cmNlcyI6WyJsaWIvZ3JpZHMvdHJlZS1ncmlkL3RyZWUtZ3JpZC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFDSCx1QkFBdUIsRUFDdkIsU0FBUyxFQUNULFdBQVcsRUFDWCxLQUFLLEVBQ0wsTUFBTSxFQUNOLFlBQVksRUFDWixVQUFVLEVBRVYsV0FBVyxFQUVYLFlBQVksRUFFWixTQUFTLEVBRVosTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0seUJBQXlCLENBQUM7QUFDaEUsT0FBTyxFQUFFLG9CQUFvQixFQUFxQixNQUFNLHdCQUF3QixDQUFDO0FBQ2pGLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBR3BELE9BQU8sRUFBOEMsZUFBZSxFQUFFLE1BQU0sd0NBQXdDLENBQUM7QUFFckgsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0scUNBQXFDLENBQUM7QUFDMUUsT0FBTyxFQUFFLDRCQUE0QixFQUFFLE1BQU0sZ0NBQWdDLENBQUM7QUFDOUUsT0FBTyxFQUFFLHFCQUFxQixFQUFFLE1BQU0sbUNBQW1DLENBQUM7QUFDMUUsT0FBTyxFQUFFLHVCQUF1QixFQUFFLGtCQUFrQixFQUFFLE1BQU0sMkJBQTJCLENBQUM7QUFDeEYsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGtCQUFrQixDQUFDO0FBRWhELE9BQU8sRUFBRSxLQUFLLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDbEQsT0FBTyxFQUFFLHVDQUF1QyxFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDakYsT0FBTyxFQUFFLG1CQUFtQixFQUFFLHlCQUF5QixFQUFFLE1BQU0sNkNBQTZDLENBQUM7QUFFN0csT0FBTyxFQUFFLHdCQUF3QixFQUFFLE1B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RSxFQUFFLElBQUksRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRTs7Ozs7OztJQS9UdkUsbUNBQTJDOzs7OztJQUMzQyxxQ0FBYzs7Ozs7SUFDZCw0REFBdUQ7Ozs7O0lBQ3ZELDZDQUF1Rzs7Ozs7SUE0RXZHLHdDQUF1Qjs7Ozs7SUFLdkIseURBQXdDOzs7Ozs7Ozs7O0lBVXhDLDJDQUFzQzs7Ozs7Ozs7OztJQVV0Qyx1Q0FBNEU7Ozs7Ozs7Ozs7SUFVNUUsb0RBQStDOzs7Ozs7Ozs7O0lBVS9DLGdEQUFxRjs7Ozs7Ozs7O0lBU3JGLDRDQUNvQjs7Ozs7Ozs7OztJQVVwQiwwQ0FDa0I7Ozs7Ozs7Ozs7Ozs7SUFhbEIsOENBQ3NCOzs7Ozs7Ozs7OztJQVd0QiwrQ0FDOEI7Ozs7O0lBRTlCLCtDQUFtQzs7Ozs7SUFvQm5DLGdEQUFzRTs7Ozs7SUF3Q3RFLHFEQUNxRTs7Ozs7O0lBS3JFLGtEQUNzRTs7Ozs7Ozs7Ozs7Ozs7O0lBdUN0RSxvREFDc0Y7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQXFCdEYsMkNBQzZEOzs7OztJQUs3RCwyQ0FBb0M7Ozs7O0lBTXBDLDZDQUE2Qjs7Ozs7O0lBTTdCLHFEQUMrQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gICAgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksXG4gICAgQ29tcG9uZW50LFxuICAgIEhvc3RCaW5kaW5nLFxuICAgIElucHV0LFxuICAgIE91dHB1dCxcbiAgICBFdmVudEVtaXR0ZXIsXG4gICAgZm9yd2FyZFJlZixcbiAgICBPbkluaXQsXG4gICAgVGVtcGxhdGVSZWYsXG4gICAgUXVlcnlMaXN0LFxuICAgIENvbnRlbnRDaGlsZCxcbiAgICBBZnRlckNvbnRlbnRJbml0LFxuICAgIFZpZXdDaGlsZCxcbiAgICBEb0NoZWNrXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSWd4VHJlZUdyaWRBUElTZXJ2aWNlIH0gZnJvbSAnLi90cmVlLWdyaWQtYXBpLnNlcnZpY2UnO1xuaW1wb3J0IHsgSWd4R3JpZEJhc2VDb21wb25lbnQsIElHcmlkRGF0YUJpbmRhYmxlIH0gZnJvbSAnLi4vZ3JpZC1iYXNlLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBHcmlkQmFzZUFQSVNlcnZpY2UgfSBmcm9tICcuLi9hcGkuc2VydmljZSc7XG5pbXBvcnQgeyBJVHJlZUdyaWRSZWNvcmQgfSBmcm9tICcuL3RyZWUtZ3JpZC5pbnRlcmZhY2VzJztcbmltcG9ydCB7IElSb3dUb2dnbGVFdmVudEFyZ3MgfSBmcm9tICcuL3RyZWUtZ3JpZC5pbnRlcmZhY2VzJztcbmltcG9ydCB7IEhpZXJhcmNoaWNhbFRyYW5zYWN0aW9uLCBIaWVyYXJjaGljYWxTdGF0ZSwgVHJhbnNhY3Rpb25UeXBlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvdHJhbnNhY3Rpb24vdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHsgSWd4SGllcmFyY2hpY2FsVHJhbnNhY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvaW5kZXgnO1xuaW1wb3J0IHsgSWd4RmlsdGVyaW5nU2VydmljZSB9IGZyb20gJy4uL2ZpbHRlcmluZy9ncmlkLWZpbHRlcmluZy5zZXJ2aWNlJztcbmltcG9ydCB7IElneFRyZWVHcmlkTmF2aWdhdGlvblNlcnZpY2UgfSBmcm9tICcuL3RyZWUtZ3JpZC1uYXZpZ2F0aW9uLnNlcnZpY2UnO1xuaW1wb3J0IHsgSWd4R3JpZFN1bW1hcnlTZXJ2aWNlIH0gZnJvbSAnLi4vc3VtbWFyaWVzL2dyaWQtc3VtbWFyeS5zZXJ2aWNlJztcbmltcG9ydCB7IElneEdyaWRTZWxlY3Rpb25TZXJ2aWNlLCBJZ3hHcmlkQ1JVRFNlcnZpY2UgfSBmcm9tICcuLi8uLi9jb3JlL2dyaWQtc2VsZWN0aW9uJztcbmltcG9ydCB7IG1lcmdlT2JqZWN0cyB9IGZyb20gJy4uLy4uL2NvcmUvdXRpbHMnO1xuaW1wb3J0IHsgSWd4Q29sdW1uQ29tcG9uZW50IH0gZnJvbSAnLi4vY29sdW1uLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBmaXJzdCwgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgSWd4Um93TG9hZGluZ0luZGljYXRvclRlbXBsYXRlRGlyZWN0aXZlIH0gZnJvbSAnLi90cmVlLWdyaWQuZGlyZWN0aXZlcyc7XG5pbXBvcnQgeyBJZ3hGb3JPZlN5bmNTZXJ2aWNlLCBJZ3hGb3JPZlNjcm9sbFN5bmNTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vZGlyZWN0aXZlcy9mb3Itb2YvZm9yX29mLnN5bmMuc2VydmljZSc7XG5pbXBvcnQgeyBJZ3hEcmFnSW5kaWNhdG9ySWNvbkRpcmVjdGl2ZSB9IGZyb20gJy4uL3Jvdy1kcmFnLmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBJZ3hHcmlkTmF2aWdhdGlvblNlcnZpY2UgfSBmcm9tICcuLi9ncmlkLW5hdmlnYXRpb24uc2VydmljZSc7XG5pbXBvcnQgeyBJZ3hSb3dJc2xhbmRBUElTZXJ2aWNlIH0gZnJvbSAnLi4vaGllcmFyY2hpY2FsLWdyaWQvcm93LWlzbGFuZC1hcGkuc2VydmljZSc7XG5cbmxldCBORVhUX0lEID0gMDtcblxuLyoqXG4gKiAqKklnbml0ZSBVSSBmb3IgQW5ndWxhciBUcmVlIEdyaWQqKiAtXG4gKiBbRG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly93d3cuaW5mcmFnaXN0aWNzLmNvbS9wcm9kdWN0cy9pZ25pdGUtdWktYW5ndWxhci9hbmd1bGFyL2NvbXBvbmVudHMvZ3JpZC5odG1sKVxuICpcbiAqIFRoZSBJZ25pdGUgVUkgVHJlZSBHcmlkIGRpc3BsYXlzIGFuZCBtYW5pcHVsYXRlcyBoaWVyYXJjaGljYWwgZGF0YSB3aXRoIGNvbnNpc3RlbnQgc2NoZW1hIGZvcm1hdHRlZCBhcyBhIHRhYmxlIGFuZFxuICogcHJvdmlkZXMgZmVhdHVyZXMgc3VjaCBhcyBzb3J0aW5nLCBmaWx0ZXJpbmcsIGVkaXRpbmcsIGNvbHVtbiBwaW5uaW5nLCBwYWdpbmcsIGNvbHVtbiBtb3ZpbmcgYW5kIGhpZGluZy5cbiAqXG4gKiBFeGFtcGxlOlxuICogYGBgaHRtbFxuICogPGlneC10cmVlLWdyaWQgW2RhdGFdPVwiZW1wbG95ZWVEYXRhXCIgcHJpbWFyeUtleT1cImVtcGxveWVlSURcIiBmb3JlaWduS2V5PVwiUElEXCIgYXV0b0dlbmVyYXRlPVwiZmFsc2VcIj5cbiAqICAgPGlneC1jb2x1bW4gZmllbGQ9XCJmaXJzdFwiIGhlYWRlcj1cIkZpcnN0IE5hbWVcIj48L2lneC1jb2x1bW4+XG4gKiAgIDxpZ3gtY29sdW1uIGZpZWxkPVwibGFzdFwiIGhlYWRlcj1cIkxhc3QgTmFtZVwiPjwvaWd4LWNvbHVtbj5cbiAqICAgPGlneC1jb2x1bW4gZmllbGQ9XCJyb2xlXCIgaGVhZGVyPVwiUm9sZVwiPjwvaWd4LWNvbHVtbj5cbiAqIDwvaWd4LXRyZWUtZ3JpZD5cbiAqIGBgYFxuICovXG5AQ29tcG9uZW50KHtcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICBwcmVzZXJ2ZVdoaXRlc3BhY2VzOiBmYWxzZSxcbiAgICBzZWxlY3RvcjogJ2lneC10cmVlLWdyaWQnLFxuICAgIHRlbXBsYXRlVXJsOiAndHJlZS1ncmlkLmNvbXBvbmVudC5odG1sJyxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAgSWd4R3JpZFNlbGVjdGlvblNlcnZpY2UsXG4gICAgICAgIElneEdyaWRDUlVEU2VydmljZSxcbiAgICAgICAgSWd4R3JpZFN1bW1hcnlTZXJ2aWNlLFxuICAgICAgICB7IHByb3ZpZGU6IElneEdyaWROYXZpZ2F0aW9uU2VydmljZSwgdXNlQ2xhc3M6IElneFRyZWVHcmlkTmF2aWdhdGlvblNlcnZpY2UgfSxcbiAgICAgICAgeyBwcm92aWRlOiBHcmlkQmFzZUFQSVNlcnZpY2UsIHVzZUNsYXNzOiBJZ3hUcmVlR3JpZEFQSVNlcnZpY2UgfSxcbiAgICAgICAgeyBwcm92aWRlOiBJZ3hHcmlkQmFzZUNvbXBvbmVudCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gSWd4VHJlZUdyaWRDb21wb25lbnQpIH0sXG4gICAgICAgIElneEZpbHRlcmluZ1NlcnZpY2UsXG4gICAgICAgIElneEZvck9mU3luY1NlcnZpY2UsXG4gICAgICAgIElneEZvck9mU2Nyb2xsU3luY1NlcnZpY2UsXG4gICAgICAgIElneFJvd0lzbGFuZEFQSVNlcnZpY2VcbiAgICBdXG59KVxuZXhwb3J0IGNsYXNzIElneFRyZWVHcmlkQ29tcG9uZW50IGV4dGVuZHMgSWd4R3JpZEJhc2VDb21wb25lbnQgaW1wbGVtZW50cyBJR3JpZERhdGFCaW5kYWJsZSwgT25Jbml0LCBEb0NoZWNrLCBBZnRlckNvbnRlbnRJbml0IHtcbiAgICBwcml2YXRlIF9pZCA9IGBpZ3gtdHJlZS1ncmlkLSR7TkVYVF9JRCsrfWA7XG4gICAgcHJpdmF0ZSBfZGF0YTtcbiAgICBwcml2YXRlIF9yb3dMb2FkaW5nSW5kaWNhdG9yVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT47XG4gICAgcHJvdGVjdGVkIF90cmFuc2FjdGlvbnM6IElneEhpZXJhcmNoaWNhbFRyYW5zYWN0aW9uU2VydmljZTxIaWVyYXJjaGljYWxUcmFuc2FjdGlvbiwgSGllcmFyY2hpY2FsU3RhdGU+O1xuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgdmFsdWUgb2YgdGhlIGBpZGAgYXR0cmlidXRlLiBJZiBub3QgcHJvdmlkZWQgaXQgd2lsbCBiZSBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC10cmVlLWdyaWQgW2lkXT1cIidpZ3gtdHJlZS1ncmlkLTEnXCI+PC9pZ3gtdHJlZS1ncmlkPlxuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4VHJlZUdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBASG9zdEJpbmRpbmcoJ2F0dHIuaWQnKVxuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBpZCgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5faWQ7XG4gICAgfVxuICAgIHB1YmxpYyBzZXQgaWQodmFsdWU6IHN0cmluZykge1xuICAgICAgICB0aGlzLl9pZCA9IHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFuIEBJbnB1dCBwcm9wZXJ0eSB0aGF0IGxldHMgeW91IGZpbGwgdGhlIGBJZ3hUcmVlR3JpZENvbXBvbmVudGAgd2l0aCBhbiBhcnJheSBvZiBkYXRhLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXRyZWUtZ3JpZCBbZGF0YV09XCJEYXRhXCIgW2F1dG9HZW5lcmF0ZV09XCJ0cnVlXCI+PC9pZ3gtdHJlZS1ncmlkPlxuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4VHJlZUdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgZGF0YSgpOiBhbnlbXSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgZGF0YSh2YWx1ZTogYW55W10pIHtcbiAgICAgICAgdGhpcy5fZGF0YSA9IHZhbHVlIHx8IFtdO1xuICAgICAgICB0aGlzLnN1bW1hcnlTZXJ2aWNlLmNsZWFyU3VtbWFyeUNhY2hlKCk7XG4gICAgICAgIGlmICh0aGlzLnNob3VsZEdlbmVyYXRlKSB7XG4gICAgICAgICAgICB0aGlzLnNldHVwQ29sdW1ucygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2RyLm1hcmtGb3JDaGVjaygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nIHRoZSBmaWx0ZXJlZCBkYXRhIGluIHRoZSBgSWd4R3JpZENvbXBvbmVudGAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBmaWx0ZXJlZERhdGEgPSB0aGlzLmdyaWQuZmlsdGVyZWREYXRhO1xuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4VHJlZUdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBnZXQgZmlsdGVyZWREYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmlsdGVyZWREYXRhO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgYW4gYXJyYXkgb2Ygb2JqZWN0cyBjb250YWluaW5nIHRoZSBmaWx0ZXJlZCBkYXRhIGluIHRoZSBgSWd4R3JpZENvbXBvbmVudGAuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuZ3JpZC5maWx0ZXJlZERhdGEgPSBbe1xuICAgICAqICAgICAgIElEOiAxLFxuICAgICAqICAgICAgIE5hbWU6IFwiQVwiXG4gICAgICogfV07XG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIHNldCBmaWx0ZXJlZERhdGEodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZmlsdGVyZWREYXRhID0gdmFsdWU7XG5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgdHJhbnNhY3Rpb25zIHNlcnZpY2UgZm9yIHRoZSBncmlkLlxuICAgICAqIEBleHBlcmltZW50YWwgQGhpZGRlblxuICAgICAqL1xuICAgIGdldCB0cmFuc2FjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFuc2FjdGlvbnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKi9cbiAgICBwdWJsaWMgZmxhdERhdGE6IGFueVtdO1xuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKi9cbiAgICBwdWJsaWMgcHJvY2Vzc2VkRXhwYW5kZWRGbGF0RGF0YTogYW55W107XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIHRoZSByb290IGxldmVsIGBJVHJlZUdyaWRSZWNvcmRgcy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gZ2V0cyB0aGUgcm9vdCByZWNvcmQgd2l0aCBpbmRleD0yXG4gICAgICogY29uc3Qgc3RhdGVzID0gdGhpcy5ncmlkLnJvb3RSZWNvcmRzWzJdO1xuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4VHJlZUdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgcm9vdFJlY29yZHM6IElUcmVlR3JpZFJlY29yZFtdO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG1hcCBvZiBhbGwgYElUcmVlR3JpZFJlY29yZGBzLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAvLyBnZXRzIHRoZSByZWNvcmQgd2l0aCBwcmltYXJ5S2V5PTJcbiAgICAgKiBjb25zdCBzdGF0ZXMgPSB0aGlzLmdyaWQucmVjb3Jkcy5nZXQoMik7XG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIHB1YmxpYyByZWNvcmRzOiBNYXA8YW55LCBJVHJlZUdyaWRSZWNvcmQ+ID0gbmV3IE1hcDxhbnksIElUcmVlR3JpZFJlY29yZD4oKTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgcHJvY2Vzc2VkIChmaWx0ZXJlZCBhbmQgc29ydGVkKSByb290IGBJVHJlZUdyaWRSZWNvcmRgcy5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogLy8gZ2V0cyB0aGUgcHJvY2Vzc2VkIHJvb3QgcmVjb3JkIHdpdGggaW5kZXg9MlxuICAgICAqIGNvbnN0IHN0YXRlcyA9IHRoaXMuZ3JpZC5wcm9jZXNzZWRSb290UmVjb3Jkc1syXTtcbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneFRyZWVHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIHByb2Nlc3NlZFJvb3RSZWNvcmRzOiBJVHJlZUdyaWRSZWNvcmRbXTtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBtYXAgb2YgYWxsIHByb2Nlc3NlZCAoZmlsdGVyZWQgYW5kIHNvcnRlZCkgYElUcmVlR3JpZFJlY29yZGBzLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAvLyBnZXRzIHRoZSBwcm9jZXNzZWQgcmVjb3JkIHdpdGggcHJpbWFyeUtleT0yXG4gICAgICogY29uc3Qgc3RhdGVzID0gdGhpcy5ncmlkLnByb2Nlc3NlZFJlY29yZHMuZ2V0KDIpO1xuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4VHJlZUdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgcHJvY2Vzc2VkUmVjb3JkczogTWFwPGFueSwgSVRyZWVHcmlkUmVjb3JkPiA9IG5ldyBNYXA8YW55LCBJVHJlZUdyaWRSZWNvcmQ+KCk7XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHRoZSBjaGlsZCBkYXRhIGtleSBvZiB0aGUgYElneFRyZWVHcmlkQ29tcG9uZW50YC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC10cmVlLWdyaWQgI2dyaWQgW2RhdGFdPVwiZW1wbG95ZWVEYXRhXCIgW2NoaWxkRGF0YUtleV09XCInZW1wbG95ZWVzJ1wiIFthdXRvR2VuZXJhdGVdPVwidHJ1ZVwiPjwvaWd4LXRyZWUtZ3JpZD5cbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneFRyZWVHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgY2hpbGREYXRhS2V5O1xuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IHRoYXQgc2V0cyB0aGUgZm9yZWlnbiBrZXkgb2YgdGhlIGBJZ3hUcmVlR3JpZENvbXBvbmVudGAuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtdHJlZS1ncmlkICNncmlkIFtkYXRhXT1cImVtcGxveWVlRGF0YVwiIFtwcmltYXJ5S2V5XT1cIidlbXBsb3llZUlEJ1wiIFtmb3JlaWduS2V5XT1cIidwYXJlbnRJRCdcIiBbYXV0b0dlbmVyYXRlXT1cInRydWVcIj5cbiAgICAgKiA8L2lneC10cmVlLWdyaWQ+XG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGZvcmVpZ25LZXk7XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHRoZSBrZXkgaW5kaWNhdGluZyB3aGV0aGVyIGEgcm93IGhhcyBjaGlsZHJlbi5cbiAgICAgKiBUaGlzIHByb3BlcnR5IGlzIG9ubHkgdXNlZCBmb3IgbG9hZCBvbiBkZW1hbmQgc2NlbmFyaW9zLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXRyZWUtZ3JpZCAjZ3JpZCBbZGF0YV09XCJlbXBsb3llZURhdGFcIiBbcHJpbWFyeUtleV09XCInZW1wbG95ZWVJRCdcIiBbZm9yZWlnbktleV09XCIncGFyZW50SUQnXCJcbiAgICAgKiAgICAgICAgICAgICAgICBbbG9hZENoaWxkcmVuT25EZW1hbmRdPVwibG9hZENoaWxkcmVuXCJcbiAgICAgKiAgICAgICAgICAgICAgICBbaGFzQ2hpbGRyZW5LZXldPVwiJ2hhc0VtcGxveWVlcydcIj5cbiAgICAgKiA8L2lneC10cmVlLWdyaWQ+XG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGhhc0NoaWxkcmVuS2V5O1xuXG4gICAgLyoqXG4gICAgICogQW4gQElucHV0IHByb3BlcnR5IGluZGljYXRpbmcgd2hldGhlciBjaGlsZCByZWNvcmRzIHNob3VsZCBiZSBkZWxldGVkIHdoZW4gdGhlaXIgcGFyZW50IGdldHMgZGVsZXRlZC5cbiAgICAgKiBCeSBkZWZhdWx0IGl0IGlzIHNldCB0byB0cnVlIGFuZCBkZWxldGVzIGFsbCBjaGlsZHJlbiBhbG9uZyB3aXRoIHRoZSBwYXJlbnQuXG4gICAgICogYGBgaHRtbFxuICAgICAqIDxpZ3gtdHJlZS1ncmlkIFtkYXRhXT1cImVtcGxveWVlRGF0YVwiIFtwcmltYXJ5S2V5XT1cIidlbXBsb3llZUlEJ1wiIFtmb3JlaWduS2V5XT1cIidwYXJlbnRJRCdcIiBjYXNjYWRlT25EZWxldGU9XCJmYWxzZVwiPlxuICAgICAqIDwvaWd4LXRyZWUtZ3JpZD5cbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneFRyZWVHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgY2FzY2FkZU9uRGVsZXRlID0gdHJ1ZTtcblxuICAgIHByaXZhdGUgX2V4cGFuc2lvbkRlcHRoID0gSW5maW5pdHk7XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBzZXRzIHRoZSBjb3VudCBvZiBsZXZlbHMgdG8gYmUgZXhwYW5kZWQgaW4gdGhlIGBJZ3hUcmVlR3JpZENvbXBvbmVudGAuIEJ5IGRlZmF1bHQgaXQgaXNcbiAgICAgKiBzZXQgdG8gYEluZmluaXR5YCB3aGljaCBtZWFucyBhbGwgbGV2ZWxzIHdvdWxkIGJlIGV4cGFuZGVkLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXRyZWUtZ3JpZCAjZ3JpZCBbZGF0YV09XCJlbXBsb3llZURhdGFcIiBbY2hpbGREYXRhS2V5XT1cIidlbXBsb3llZXMnXCIgZXhwYW5zaW9uRGVwdGg9XCIxXCIgW2F1dG9HZW5lcmF0ZV09XCJ0cnVlXCI+PC9pZ3gtdHJlZS1ncmlkPlxuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4VHJlZUdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgZXhwYW5zaW9uRGVwdGgoKTogbnVtYmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4cGFuc2lvbkRlcHRoO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgZXhwYW5zaW9uRGVwdGgodmFsdWU6IG51bWJlcikge1xuICAgICAgICB0aGlzLl9leHBhbnNpb25EZXB0aCA9IHZhbHVlO1xuICAgICAgICB0aGlzLm5vdGlmeUNoYW5nZXMoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9leHBhbnNpb25TdGF0ZXM6IE1hcDxhbnksIGJvb2xlYW4+ID0gbmV3IE1hcDxhbnksIGJvb2xlYW4+KCk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBrZXktdmFsdWUgcGFpcnMgW3JvdyBJRCwgZXhwYW5zaW9uIHN0YXRlXS4gSW5jbHVkZXMgb25seSBzdGF0ZXMgdGhhdCBkaWZmZXIgZnJvbSB0aGUgZGVmYXVsdCBvbmUuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGV4cGFuc2lvblN0YXRlcyA9IHRoaXMuZ3JpZC5leHBhbnNpb25TdGF0ZXM7XG4gICAgICogYGBgXG5cdCAqIEBtZW1iZXJvZiBJZ3hUcmVlR3JpZENvbXBvbmVudFxuICAgICAqL1xuICAgIEBJbnB1dCgpXG4gICAgcHVibGljIGdldCBleHBhbnNpb25TdGF0ZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9leHBhbnNpb25TdGF0ZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIGxpc3Qgb2Yga2V5LXZhbHVlIHBhaXJzIFtyb3cgSUQsIGV4cGFuc2lvbiBzdGF0ZV0uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IHN0YXRlcyA9IG5ldyBNYXA8YW55LCBib29sZWFuPigpO1xuICAgICAqIHN0YXRlcy5zZXQoMSwgdHJ1ZSk7XG4gICAgICogdGhpcy5ncmlkLmV4cGFuc2lvblN0YXRlcyA9IHN0YXRlcztcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFR3by13YXkgZGF0YSBiaW5kaW5nLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXRyZWUtZ3JpZCAjZ3JpZCBbZGF0YV09XCJlbXBsb3llZURhdGFcIiBbY2hpbGREYXRhS2V5XT1cIidlbXBsb3llZXMnXCIgWyhleHBhbnNpb25TdGF0ZXMpXT1cIm1vZGVsLmV4cGFuc2lvblN0YXRlc1wiPlxuICAgICAqIDwvaWd4LXRyZWUtZ3JpZD5cbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneFRyZWVHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIHNldCBleHBhbnNpb25TdGF0ZXModmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZXhwYW5zaW9uU3RhdGVzID0gdGhpcy5jbG9uZU1hcCh2YWx1ZSk7XG4gICAgICAgIHRoaXMuZXhwYW5zaW9uU3RhdGVzQ2hhbmdlLmVtaXQodGhpcy5fZXhwYW5zaW9uU3RhdGVzKTtcbiAgICAgICAgaWYgKHRoaXMuZ3JpZEFQSS5ncmlkKSB7XG4gICAgICAgICAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKkBoaWRkZW5cbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgZXhwYW5zaW9uU3RhdGVzQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxNYXA8YW55LCBib29sZWFuPj4oKTtcblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBAQ29udGVudENoaWxkKElneFJvd0xvYWRpbmdJbmRpY2F0b3JUZW1wbGF0ZURpcmVjdGl2ZSwgeyByZWFkOiBJZ3hSb3dMb2FkaW5nSW5kaWNhdG9yVGVtcGxhdGVEaXJlY3RpdmUsIHN0YXRpYzogZmFsc2UgfSlcbiAgICBwcm90ZWN0ZWQgcm93TG9hZGluZ1RlbXBsYXRlOiBJZ3hSb3dMb2FkaW5nSW5kaWNhdG9yVGVtcGxhdGVEaXJlY3RpdmU7XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBwcm92aWRlcyBhIHRlbXBsYXRlIGZvciB0aGUgcm93IGxvYWRpbmcgaW5kaWNhdG9yIHdoZW4gbG9hZCBvbiBkZW1hbmQgaXMgZW5hYmxlZC5cbiAgICAgKiBgYGBodG1sXG4gICAgICogPG5nLXRlbXBsYXRlICNyb3dMb2FkaW5nVGVtcGxhdGU+XG4gICAgICogICAgIDxpZ3gtaWNvbiBmb250U2V0PVwibWF0ZXJpYWxcIj5sb29wPC9pZ3gtaWNvbj5cbiAgICAgKiA8L25nLXRlbXBsYXRlPlxuICAgICAqXG4gICAgICogPGlneC10cmVlLWdyaWQgI2dyaWQgW2RhdGFdPVwiZW1wbG95ZWVEYXRhXCIgW3ByaW1hcnlLZXldPVwiJ0lEJ1wiIFtmb3JlaWduS2V5XT1cIidwYXJlbnRJRCdcIlxuICAgICAqICAgICAgICAgICAgICAgIFtsb2FkQ2hpbGRyZW5PbkRlbWFuZF09XCJsb2FkQ2hpbGRyZW5cIlxuICAgICAqICAgICAgICAgICAgICAgIFtyb3dMb2FkaW5nSW5kaWNhdG9yVGVtcGxhdGVdPVwicm93TG9hZGluZ1RlbXBsYXRlXCI+XG4gICAgICogPC9pZ3gtdHJlZS1ncmlkPlxuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4VHJlZUdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBASW5wdXQoKVxuICAgIHB1YmxpYyBnZXQgcm93TG9hZGluZ0luZGljYXRvclRlbXBsYXRlKCk6IFRlbXBsYXRlUmVmPGFueT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5fcm93TG9hZGluZ0luZGljYXRvclRlbXBsYXRlO1xuICAgIH1cblxuICAgIHB1YmxpYyBzZXQgcm93TG9hZGluZ0luZGljYXRvclRlbXBsYXRlKHZhbHVlOiBUZW1wbGF0ZVJlZjxhbnk+KSB7XG4gICAgICAgIHRoaXMuX3Jvd0xvYWRpbmdJbmRpY2F0b3JUZW1wbGF0ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLm5vdGlmeUNoYW5nZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbiBASW5wdXQgcHJvcGVydHkgdGhhdCBwcm92aWRlcyBhIGNhbGxiYWNrIGZvciBsb2FkaW5nIGNoaWxkIHJvd3Mgb24gZGVtYW5kLlxuICAgICAqIGBgYGh0bWxcbiAgICAgKiA8aWd4LXRyZWUtZ3JpZCBbZGF0YV09XCJlbXBsb3llZURhdGFcIiBbcHJpbWFyeUtleV09XCInZW1wbG95ZWVJRCdcIiBbZm9yZWlnbktleV09XCIncGFyZW50SUQnXCIgW2xvYWRDaGlsZHJlbk9uRGVtYW5kXT1cImxvYWRDaGlsZHJlblwiPlxuICAgICAqIDwvaWd4LXRyZWUtZ3JpZD5cbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogcHVibGljIGxvYWRDaGlsZHJlbiA9IChwYXJlbnRJRDogYW55LCBkb25lOiAoY2hpbGRyZW46IGFueVtdKSA9PiB2b2lkKSA9PiB7XG4gICAgICogICAgIHRoaXMuZGF0YVNlcnZpY2UuZ2V0RGF0YShwYXJlbnRJRCwgY2hpbGRyZW4gPT4gZG9uZShjaGlsZHJlbikpO1xuICAgICAqIH1cbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneFRyZWVHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgQElucHV0KClcbiAgICBwdWJsaWMgbG9hZENoaWxkcmVuT25EZW1hbmQ6IChwYXJlbnRJRDogYW55LCBkb25lOiAoY2hpbGRyZW46IGFueVtdKSA9PiB2b2lkKSA9PiB2b2lkO1xuXG4gICAgLyoqXG4gICAgICogRW1pdHRlZCB3aGVuIHRoZSBleHBhbmRlZCBzdGF0ZSBvZiBhIHJvdyBnZXRzIGNoYW5nZWQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHJvd1RvZ2dsZShldmVudDogSVJvd1RvZ2dsZUV2ZW50QXJncyl7XG4gICAgICogIC8vIHRoZSBpZCBvZiB0aGUgcm93XG4gICAgICogIGNvbnN0IHJvd0lEID0gZXZlbnQucm93SUQ7XG4gICAgICogIC8vIHRoZSBuZXcgZXhwYW5zaW9uIHN0YXRlXG4gICAgICogIGNvbnN0IG5ld0V4cGFuZGVkU3RhdGUgPSBldmVudC5leHBhbmRlZDtcbiAgICAgKiAgLy8gdGhlIG9yaWdpbmFsIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIG9uUm93VG9nZ2xlXG4gICAgICogIGNvbnN0IG9yaWdpbmFsRXZlbnQgPSBldmVudC5ldmVudDtcbiAgICAgKiAgLy8gd2hldGhlciB0aGUgZXZlbnQgc2hvdWxkIGJlIGNhbmNlbGxlZFxuICAgICAqICBldmVudC5jYW5jZWwgPSB0cnVlO1xuICAgICAqIH1cbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlneC10cmVlLWdyaWQgW2RhdGFdPVwiZW1wbG95ZWVEYXRhXCIgKG9uUm93VG9nZ2xlKT1cInJvd1RvZ2dsZSgkZXZlbnQpXCIgW2F1dG9HZW5lcmF0ZV09XCJ0cnVlXCI+PC9pZ3gtdHJlZS1ncmlkPlxuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4VHJlZUdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBAT3V0cHV0KClcbiAgICBwdWJsaWMgb25Sb3dUb2dnbGUgPSBuZXcgRXZlbnRFbWl0dGVyPElSb3dUb2dnbGVFdmVudEFyZ3M+KCk7XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIGxvYWRpbmdSb3dzID0gbmV3IFNldDxhbnk+KCk7XG5cbiAgICAvLyBLaW5kIG9mIHN0dXBpZFxuICAgIHByaXZhdGUgZ2V0IF9ncmlkQVBJKCk6IElneFRyZWVHcmlkQVBJU2VydmljZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWRBUEkgYXMgSWd4VHJlZUdyaWRBUElTZXJ2aWNlO1xuICAgIH1cbiAgICBwcml2YXRlIF9maWx0ZXJlZERhdGEgPSBudWxsO1xuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIEBWaWV3Q2hpbGQoJ2RyYWdJbmRpY2F0b3JJY29uQmFzZScsIHsgcmVhZDogVGVtcGxhdGVSZWYsIHN0YXRpYzogdHJ1ZSB9KVxuICAgIHB1YmxpYyBkcmFnSW5kaWNhdG9ySWNvbkJhc2U6IFRlbXBsYXRlUmVmPGFueT47XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nT25Jbml0KCkge1xuICAgICAgICBzdXBlci5uZ09uSW5pdCgpO1xuXG4gICAgICAgIHRoaXMub25Sb3dUb2dnbGUucGlwZSh0YWtlVW50aWwodGhpcy5kZXN0cm95JCkpLnN1YnNjcmliZSgoYXJncykgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2FkQ2hpbGRyZW5PblJvd0V4cGFuc2lvbihhcmdzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbmdEb0NoZWNrKCkge1xuICAgICAgICBzdXBlci5uZ0RvQ2hlY2soKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgcHVibGljIG5nQWZ0ZXJDb250ZW50SW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMucm93TG9hZGluZ1RlbXBsYXRlKSB7XG4gICAgICAgICAgICB0aGlzLl9yb3dMb2FkaW5nSW5kaWNhdG9yVGVtcGxhdGUgPSB0aGlzLnJvd0xvYWRpbmdUZW1wbGF0ZS50ZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5uZ0FmdGVyQ29udGVudEluaXQoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIGxvYWRDaGlsZHJlbk9uUm93RXhwYW5zaW9uKGFyZ3M6IElSb3dUb2dnbGVFdmVudEFyZ3MpIHtcbiAgICAgICAgaWYgKHRoaXMubG9hZENoaWxkcmVuT25EZW1hbmQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudElEID0gYXJncy5yb3dJRDtcblxuICAgICAgICAgICAgaWYgKGFyZ3MuZXhwYW5kZWQgJiYgIXRoaXMuX2V4cGFuc2lvblN0YXRlcy5oYXMocGFyZW50SUQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkaW5nUm93cy5hZGQocGFyZW50SUQpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkQ2hpbGRyZW5PbkRlbWFuZChwYXJlbnRJRCwgY2hpbGRyZW4gPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWRpbmdSb3dzLmRlbGV0ZShwYXJlbnRJRCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkQ2hpbGRSb3dzKGNoaWxkcmVuLCBwYXJlbnRJRCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5Q2hhbmdlcygpO1xuXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjZWxsSUQgPSB0aGlzLnNlbGVjdGlvblNlcnZpY2UuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZWxsSUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjZWxsID0gdGhpcy5fZ3JpZEFQSS5nZXRfY2VsbF9ieV9pbmRleChjZWxsSUQucm93LCBjZWxsSUQuY29sdW1uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZWxsLm5hdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBhZGRDaGlsZFJvd3MoY2hpbGRyZW46IGFueVtdLCBwYXJlbnRJRDogYW55KSB7XG4gICAgICAgIGlmICh0aGlzLnByaW1hcnlLZXkgJiYgdGhpcy5mb3JlaWduS2V5KSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIGNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgY2hpbGRbdGhpcy5mb3JlaWduS2V5XSA9IHBhcmVudElEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kYXRhLnB1c2goLi4uY2hpbGRyZW4pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY2hpbGREYXRhS2V5KSB7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gdGhpcy5yZWNvcmRzLmdldChwYXJlbnRJRCk7XG4gICAgICAgICAgICBsZXQgcGFyZW50RGF0YSA9IHBhcmVudC5kYXRhO1xuXG4gICAgICAgICAgICBpZiAodGhpcy50cmFuc2FjdGlvbnMuZW5hYmxlZCAmJiB0aGlzLnRyYW5zYWN0aW9ucy5nZXRBZ2dyZWdhdGVkQ2hhbmdlcyh0cnVlKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gW107XG4gICAgICAgICAgICAgICAgd2hpbGUgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnB1c2gocGFyZW50LnJvd0lEKTtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsZXQgY29sbGVjdGlvbiA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgICAgICBsZXQgcmVjb3JkOiBhbnk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHBhdGgubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGlkID0gcGF0aFtpXTtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkID0gY29sbGVjdGlvbi5maW5kKHIgPT4gclt0aGlzLnByaW1hcnlLZXldID09PSBwaWQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVjb3JkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0aW9uID0gcmVjb3JkW3RoaXMuY2hpbGREYXRhS2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlY29yZCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnREYXRhID0gcmVjb3JkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcGFyZW50RGF0YVt0aGlzLmNoaWxkRGF0YUtleV0gPSBjaGlsZHJlbjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbGVjdGlvblNlcnZpY2UuY2xlYXJIZWFkZXJDQlN0YXRlKCk7XG4gICAgICAgIHRoaXMuX3BpcGVUcmlnZ2VyKys7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBjbG9uZU1hcChtYXBJbjogTWFwPGFueSwgYm9vbGVhbj4pOiBNYXA8YW55LCBib29sZWFuPiB7XG4gICAgICAgIGNvbnN0IG1hcENsb25lZDogTWFwPGFueSwgYm9vbGVhbj4gPSBuZXcgTWFwPGFueSwgYm9vbGVhbj4oKTtcblxuICAgICAgICBtYXBJbi5mb3JFYWNoKCh2YWx1ZTogYm9vbGVhbiwga2V5OiBhbnksIG1hcE9iajogTWFwPGFueSwgYm9vbGVhbj4pID0+IHtcblxuICAgICAgICAgICAgbWFwQ2xvbmVkLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG1hcENsb25lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeHBhbmRzIHRoZSBgSWd4VHJlZUdyaWRSb3dDb21wb25lbnRgIHdpdGggdGhlIHNwZWNpZmllZCByb3dJRC5cbiAgICAgKiBAcGFyYW0gcm93SUQgVGhlIGlkZW50aWZpZXIgb2YgdGhlIHJvdyB0byBiZSBleHBhbmRlZC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5ncmlkLmV4cGFuZFJvdygyKTtcbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneFRyZWVHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIGV4cGFuZFJvdyhyb3dJRDogYW55KSB7XG4gICAgICAgIHRoaXMuX2dyaWRBUEkuZXhwYW5kX3Jvdyhyb3dJRCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29sbGFwc2VzIHRoZSBgSWd4VHJlZUdyaWRSb3dDb21wb25lbnRgIHdpdGggdGhlIHNwZWNpZmllZCByb3dJRC5cbiAgICAgKiBAcGFyYW0gcm93SUQgVGhlIGlkZW50aWZpZXIgb2YgdGhlIHJvdyB0byBiZSBjb2xsYXBzZWQuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuZ3JpZC5jb2xsYXBzZVJvdygyKTtcbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneFRyZWVHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIGNvbGxhcHNlUm93KHJvd0lEOiBhbnkpIHtcbiAgICAgICAgdGhpcy5fZ3JpZEFQSS5jb2xsYXBzZV9yb3cocm93SUQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgdGhlIGV4cGFuc2lvbiBzdGF0ZSBvZiB0aGUgYElneFRyZWVHcmlkUm93Q29tcG9uZW50YCB3aXRoIHRoZSBzcGVjaWZpZWQgcm93SUQuXG4gICAgICogQHBhcmFtIHJvd0lEIFRoZSBpZGVudGlmaWVyIG9mIHRoZSByb3cgdG8gYmUgdG9nZ2xlZC5cbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogdGhpcy5ncmlkLnRvZ2dsZVJvdygyKTtcbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneFRyZWVHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIHRvZ2dsZVJvdyhyb3dJRDogYW55KSB7XG4gICAgICAgIHRoaXMuX2dyaWRBUEkudG9nZ2xlX3Jvd19leHBhbnNpb24ocm93SUQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4cGFuZHMgYWxsIHJvd3MuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuZ3JpZC5leHBhbmRBbGwoKTtcbiAgICAgKiBgYGBcblx0ICogQG1lbWJlcm9mIElneFRyZWVHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIGV4cGFuZEFsbCgpIHtcbiAgICAgICAgdGhpcy5fZXhwYW5zaW9uRGVwdGggPSBJbmZpbml0eTtcbiAgICAgICAgdGhpcy5leHBhbnNpb25TdGF0ZXMgPSBuZXcgTWFwPGFueSwgYm9vbGVhbj4oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb2xsYXBzZXMgYWxsIHJvd3MuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIHRoaXMuZ3JpZC5jb2xsYXBzZUFsbCgpO1xuICAgICAqIGBgYFxuXHQgKiBAbWVtYmVyb2YgSWd4VHJlZUdyaWRDb21wb25lbnRcbiAgICAgKi9cbiAgICBwdWJsaWMgY29sbGFwc2VBbGwoKSB7XG4gICAgICAgIHRoaXMuX2V4cGFuc2lvbkRlcHRoID0gMDtcbiAgICAgICAgdGhpcy5leHBhbnNpb25TdGF0ZXMgPSBuZXcgTWFwPGFueSwgYm9vbGVhbj4oKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGBJZ3hUcmVlR3JpZFJvd0NvbXBvbmVudGAgd2l0aCB0aGUgZ2l2ZW4gZGF0YS4gSWYgYSBwYXJlbnRSb3dJRCBpcyBub3Qgc3BlY2lmaWVkLCB0aGUgbmV3bHkgY3JlYXRlZFxuICAgICAqIHJvdyB3b3VsZCBiZSBhZGRlZCBhdCB0aGUgcm9vdCBsZXZlbC4gT3RoZXJ3aXNlLCBpdCB3b3VsZCBiZSBhZGRlZCBhcyBhIGNoaWxkIG9mIHRoZSByb3cgd2hvc2UgcHJpbWFyeUtleSBtYXRjaGVzXG4gICAgICogdGhlIHNwZWNpZmllZCBwYXJlbnRSb3dJRC4gSWYgdGhlIHBhcmVudFJvd0lEIGRvZXMgbm90IGV4aXN0LCBhbiBlcnJvciB3b3VsZCBiZSB0aHJvd24uXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IHJlY29yZCA9IHtcbiAgICAgKiAgICAgSUQ6IHRoaXMuZ3JpZC5kYXRhW3RoaXMuZ3JpZDEuZGF0YS5sZW5ndGggLSAxXS5JRCArIDEsXG4gICAgICogICAgIE5hbWU6IHRoaXMubmV3UmVjb3JkXG4gICAgICogfTtcbiAgICAgKiB0aGlzLmdyaWQuYWRkUm93KHJlY29yZCwgMSk7IC8vIEFkZHMgYSBuZXcgY2hpbGQgcm93IHRvIHRoZSByb3cgd2l0aCBJRD0xLlxuICAgICAqIGBgYFxuICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICogQHBhcmFtIHBhcmVudFJvd0lEXG4gICAgICogQG1lbWJlcm9mIElneFRyZWVHcmlkQ29tcG9uZW50XG4gICAgICovXG4gICAgcHVibGljIGFkZFJvdyhkYXRhOiBhbnksIHBhcmVudFJvd0lEPzogYW55KSB7XG4gICAgICAgIGlmIChwYXJlbnRSb3dJRCAhPT0gdW5kZWZpbmVkICYmIHBhcmVudFJvd0lEICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzdXBlci5lbmRFZGl0KHRydWUpO1xuXG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMudHJhbnNhY3Rpb25zLmdldFN0YXRlKHBhcmVudFJvd0lEKTtcbiAgICAgICAgICAgIC8vIHdlIHNob3VsZCBub3QgYWxsb3cgYWRkaW5nIG9mIHJvd3MgYXMgY2hpbGQgb2YgZGVsZXRlZCByb3dcbiAgICAgICAgICAgIGlmIChzdGF0ZSAmJiBzdGF0ZS50eXBlID09PSBUcmFuc2FjdGlvblR5cGUuREVMRVRFKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYENhbm5vdCBhZGQgY2hpbGQgcm93IHRvIGRlbGV0ZWQgcGFyZW50IHJvd2ApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBwYXJlbnRSZWNvcmQgPSB0aGlzLnJlY29yZHMuZ2V0KHBhcmVudFJvd0lEKTtcblxuICAgICAgICAgICAgaWYgKCFwYXJlbnRSZWNvcmQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBwYXJlbnQgcm93IElEIScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdW1tYXJ5U2VydmljZS5jbGVhclN1bW1hcnlDYWNoZSh7cm93SUQ6IHBhcmVudFJlY29yZC5yb3dJRH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJpbWFyeUtleSAmJiB0aGlzLmZvcmVpZ25LZXkpIHtcbiAgICAgICAgICAgICAgICBkYXRhW3RoaXMuZm9yZWlnbktleV0gPSBwYXJlbnRSb3dJRDtcbiAgICAgICAgICAgICAgICBzdXBlci5hZGRSb3coZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudERhdGEgPSBwYXJlbnRSZWNvcmQuZGF0YTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEtleSA9IHRoaXMuY2hpbGREYXRhS2V5O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zYWN0aW9ucy5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvd0lkID0gdGhpcy5wcmltYXJ5S2V5ID8gZGF0YVt0aGlzLnByaW1hcnlLZXldIDogZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF0aDogYW55W10gPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5wdXNoKC4uLnRoaXMuZ2VuZXJhdGVSb3dQYXRoKHBhcmVudFJvd0lEKSk7XG4gICAgICAgICAgICAgICAgICAgIHBhdGgucHVzaChwYXJlbnRSb3dJRCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJhbnNhY3Rpb25zLmFkZCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogcm93SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWU6IGRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBUcmFuc2FjdGlvblR5cGUuQUREXG4gICAgICAgICAgICAgICAgICAgIH0gYXMgSGllcmFyY2hpY2FsVHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBudWxsKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcmVudERhdGFbY2hpbGRLZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnREYXRhW2NoaWxkS2V5XSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudERhdGFbY2hpbGRLZXldLnB1c2goZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMub25Sb3dBZGRlZC5lbWl0KHsgZGF0YSB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9waXBlVHJpZ2dlcisrO1xuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5Q2hhbmdlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJpbWFyeUtleSAmJiB0aGlzLmZvcmVpZ25LZXkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByb3dJRCA9IGRhdGFbdGhpcy5mb3JlaWduS2V5XTtcbiAgICAgICAgICAgICAgICB0aGlzLnN1bW1hcnlTZXJ2aWNlLmNsZWFyU3VtbWFyeUNhY2hlKHtyb3dJRDogcm93SUR9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN1cGVyLmFkZFJvdyhkYXRhKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgcHVibGljIGRlbGV0ZVJvd0J5SWQocm93SWQ6IGFueSkge1xuICAgICAgICAvLyAgaWYgdGhpcyBpcyBmbGF0IHNlbGYtcmVmZXJlbmNpbmcgZGF0YSwgYW5kIENhc2NhZGVPbkRlbGV0ZSBpcyBzZXQgdG8gdHJ1ZVxuICAgICAgICAvLyAgYW5kIGlmIHdlIGhhdmUgdHJhbnNhY3Rpb25zIHdlIHNob3VsZCBzdGFydCBwZW5kaW5nIHRyYW5zYWN0aW9uLiBUaGlzIGFsbG93c1xuICAgICAgICAvLyAgdXMgaW4gY2FzZSBvZiBkZWxldGUgYWN0aW9uIHRvIGRlbGV0ZSBhbGwgY2hpbGQgcm93cyBhcyBzaW5nbGUgdW5kbyBhY3Rpb25cbiAgICAgICAgdGhpcy5fZ3JpZEFQSS5kZWxldGVSb3dCeUlkKHJvd0lkKTtcblxuICAgIH1cblxuICAgIC8qKiBAaGlkZGVuICovXG4gICAgcHVibGljIGdlbmVyYXRlUm93UGF0aChyb3dJZDogYW55KTogYW55W10ge1xuICAgICAgICBjb25zdCBwYXRoOiBhbnlbXSA9IFtdO1xuICAgICAgICBsZXQgcmVjb3JkID0gdGhpcy5yZWNvcmRzLmdldChyb3dJZCk7XG5cbiAgICAgICAgd2hpbGUgKHJlY29yZC5wYXJlbnQpIHtcbiAgICAgICAgICAgIHBhdGgucHVzaChyZWNvcmQucGFyZW50LnJvd0lEKTtcbiAgICAgICAgICAgIHJlY29yZCA9IHJlY29yZC5wYXJlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcGF0aC5yZXZlcnNlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlbiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwcm90ZWN0ZWQgZ2V0RGF0YUJhc2VkQm9keUhlaWdodCgpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gIXRoaXMuZmxhdERhdGEgfHwgKHRoaXMuZmxhdERhdGEubGVuZ3RoIDwgdGhpcy5fZGVmYXVsdFRhcmdldFJlY29yZE51bWJlcikgP1xuICAgICAgICAgICAgMCA6IHRoaXMuZGVmYXVsdFRhcmdldEJvZHlIZWlnaHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByb3RlY3RlZCBzY3JvbGxUbyhyb3c6IGFueSB8IG51bWJlciwgY29sdW1uOiBhbnkgfCBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgbGV0IGRlbGF5U2Nyb2xsaW5nID0gZmFsc2U7XG4gICAgICAgIGxldCByZWNvcmQ6IElUcmVlR3JpZFJlY29yZDtcblxuICAgICAgICBpZiAodHlwZW9mKHJvdykgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBjb25zdCByb3dEYXRhID0gcm93O1xuICAgICAgICAgICAgY29uc3Qgcm93SUQgPSB0aGlzLl9ncmlkQVBJLmdldF9yb3dfaWQocm93RGF0YSk7XG4gICAgICAgICAgICByZWNvcmQgPSB0aGlzLnByb2Nlc3NlZFJlY29yZHMuZ2V0KHJvd0lEKTtcbiAgICAgICAgICAgIHRoaXMuX2dyaWRBUEkuZXhwYW5kX3BhdGhfdG9fcmVjb3JkKHJlY29yZCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnBhZ2luZykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJvd0luZGV4ID0gdGhpcy5wcm9jZXNzZWRFeHBhbmRlZEZsYXREYXRhLmluZGV4T2Yocm93RGF0YSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFnZSA9IE1hdGguZmxvb3Iocm93SW5kZXggLyB0aGlzLnBlclBhZ2UpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucGFnZSAhPT0gcGFnZSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxheVNjcm9sbGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFnZSA9IHBhZ2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlbGF5U2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICB0aGlzLnZlcnRpY2FsU2Nyb2xsQ29udGFpbmVyLm9uRGF0YUNoYW5nZWQucGlwZShmaXJzdCgpKS5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2Nyb2xsRGlyZWN0aXZlKHRoaXMudmVydGljYWxTY3JvbGxDb250YWluZXIsXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZihyb3cpID09PSAnbnVtYmVyJyA/IHJvdyA6IHRoaXMuZGF0YVZpZXcuaW5kZXhPZihyZWNvcmQpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxEaXJlY3RpdmUodGhpcy52ZXJ0aWNhbFNjcm9sbENvbnRhaW5lcixcbiAgICAgICAgICAgICAgICB0eXBlb2Yocm93KSA9PT0gJ251bWJlcicgPyByb3cgOiB0aGlzLmRhdGFWaWV3LmluZGV4T2YocmVjb3JkKSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNjcm9sbFRvSG9yaXpvbnRhbGx5KGNvbHVtbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKi9cbiAgICBwdWJsaWMgZ2V0Q29udGV4dChyb3dEYXRhOiBhbnksIHJvd0luZGV4OiBOdW1iZXIpOiBhbnkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgJGltcGxpY2l0OiByb3dEYXRhLFxuICAgICAgICAgICAgaW5kZXg6IHJvd0luZGV4LFxuICAgICAgICAgICAgdGVtcGxhdGVJRDogdGhpcy5pc1N1bW1hcnlSb3cocm93RGF0YSkgPyAnc3VtbWFyeVJvdycgOiAnZGF0YVJvdydcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdGRvY1xuICAgICAqL1xuICAgIGdldFNlbGVjdGVkRGF0YShmb3JtYXR0ZXJzID0gZmFsc2UsIGhlYWRlcnMgPSBmYWxzZSk6IGFueVtdIHtcbiAgICAgICAgY29uc3Qgc291cmNlID0gW107XG5cbiAgICAgICAgY29uc3QgcHJvY2VzcyA9IChyZWNvcmQpID0+IHtcbiAgICAgICAgICAgIGlmIChyZWNvcmQuc3VtbWFyaWVzKSB7XG4gICAgICAgICAgICAgICAgc291cmNlLnB1c2gobnVsbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc291cmNlLnB1c2gocmVjb3JkLmRhdGEpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZGF0YVZpZXcuZm9yRWFjaChwcm9jZXNzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0cmFjdERhdGFGcm9tU2VsZWN0aW9uKHNvdXJjZSwgZm9ybWF0dGVycywgaGVhZGVycyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBAaGlkZGVuXG4gICAgKi9cbiAgICBwdWJsaWMgZ2V0IHRlbXBsYXRlKCk6IFRlbXBsYXRlUmVmPGFueT4ge1xuICAgICAgICBpZiAodGhpcy5maWx0ZXJlZERhdGEgJiYgdGhpcy5maWx0ZXJlZERhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbXB0eUdyaWRUZW1wbGF0ZSA/IHRoaXMuZW1wdHlHcmlkVGVtcGxhdGUgOiB0aGlzLmVtcHR5RmlsdGVyZWRHcmlkVGVtcGxhdGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5pc0xvYWRpbmcgJiYgKCF0aGlzLmRhdGEgfHwgdGhpcy5kYXRhTGVuZ3RoID09PSAwKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9hZGluZ0dyaWRUZW1wbGF0ZSA/IHRoaXMubG9hZGluZ0dyaWRUZW1wbGF0ZSA6IHRoaXMubG9hZGluZ0dyaWREZWZhdWx0VGVtcGxhdGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5kYXRhTGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbXB0eUdyaWRUZW1wbGF0ZSA/IHRoaXMuZW1wdHlHcmlkVGVtcGxhdGUgOiB0aGlzLmVtcHR5R3JpZERlZmF1bHRUZW1wbGF0ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3RlY3RlZCB3cml0ZVRvRGF0YShyb3dJbmRleDogbnVtYmVyLCB2YWx1ZTogYW55KSB7XG4gICAgICAgIG1lcmdlT2JqZWN0cyh0aGlzLmZsYXREYXRhW3Jvd0luZGV4XSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAqL1xuICAgcHJvdGVjdGVkIGluaXRDb2x1bW5zKGNvbGxlY3Rpb246IFF1ZXJ5TGlzdDxJZ3hDb2x1bW5Db21wb25lbnQ+LCBjYjogRnVuY3Rpb24gPSBudWxsKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc0NvbHVtbkxheW91dHMpIHtcbiAgICAgICAgICAgIC8vIGludmFsaWQgY29uZmlndXJhdGlvbiAtIHRyZWUgZ3JpZCBzaG91bGQgbm90IGFsbG93IGNvbHVtbiBsYXlvdXRzXG4gICAgICAgICAgICAvLyByZW1vdmUgY29sdW1uIGxheW91dHNcbiAgICAgICAgICAgIGNvbnN0IG5vbkNvbHVtbkxheW91dENvbHVtbnMgPSB0aGlzLmNvbHVtbkxpc3QuZmlsdGVyKChjb2wpID0+ICFjb2wuY29sdW1uTGF5b3V0ICYmICFjb2wuY29sdW1uTGF5b3V0Q2hpbGQpO1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5MaXN0LnJlc2V0KG5vbkNvbHVtbkxheW91dENvbHVtbnMpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLmluaXRDb2x1bW5zKGNvbGxlY3Rpb24sIGNiKTtcbiAgICB9XG59XG4iXX0=