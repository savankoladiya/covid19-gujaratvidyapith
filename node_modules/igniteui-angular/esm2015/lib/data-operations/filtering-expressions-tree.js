/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/** @enum {number} */
const FilteringExpressionsTreeType = {
    Regular: 0,
    Advanced: 1,
};
export { FilteringExpressionsTreeType };
FilteringExpressionsTreeType[FilteringExpressionsTreeType.Regular] = 'Regular';
FilteringExpressionsTreeType[FilteringExpressionsTreeType.Advanced] = 'Advanced';
export class FilteringExpressionsTree {
    /**
     * @param {?} operator
     * @param {?=} fieldName
     */
    constructor(operator, fieldName) {
        /**
         * Sets/gets the filtering operands.
         * ```typescript
         * const gridExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And);
         * const expression = [
         * {
         *   condition: IgxStringFilteringOperand.instance().condition('contains'),
         *   fieldName: 'Column Field',
         *   searchVal: 'Value',
         *   ignoreCase: false
         * }];
         * gridExpressionsTree.filteringOperands.push(expression);
         * this.grid.filteringExpressionsTree = gridExpressionsTree;
         * ```
         * ```typescript
         * let filteringOperands = gridExpressionsTree.filteringOperands;
         * ```
         * \@memberof FilteringExpressionsTree
         */
        this.filteringOperands = [];
        this.operator = operator;
        this.fieldName = fieldName;
    }
    /**
     * Checks if filtering expressions tree is empty.
     * @param {?} expressionTree filtering expressions tree.
     * @return {?}
     */
    static empty(expressionTree) {
        return !expressionTree || !expressionTree.filteringOperands || !expressionTree.filteringOperands.length;
    }
    /**
     * Returns the filtering expression for a column with the provided fieldName.
     * ```typescript
     * let filteringExpression = gridExpressionTree.find('Column Field');
     * ```
     * \@memberof FilteringExpressionsTree
     * @param {?} fieldName
     * @return {?}
     */
    find(fieldName) {
        /** @type {?} */
        const index = this.findIndex(fieldName);
        if (index > -1) {
            return this.filteringOperands[index];
        }
        return null;
    }
    /**
     * Returns the index of the filtering expression for a column with the provided fieldName.
     * ```typescript
     * let filteringExpressionIndex = gridExpressionTree.findIndex('Column Field');
     * ```
     * \@memberof FilteringExpressionsTree
     * @param {?} fieldName
     * @return {?}
     */
    findIndex(fieldName) {
        /** @type {?} */
        let expr;
        for (let i = 0; i < this.filteringOperands.length; i++) {
            expr = this.filteringOperands[i];
            if (expr instanceof FilteringExpressionsTree) {
                if (this.isFilteringExpressionsTreeForColumn(expr, fieldName)) {
                    return i;
                }
            }
            else {
                if (((/** @type {?} */ (expr))).fieldName === fieldName) {
                    return i;
                }
            }
        }
        return -1;
    }
    /**
     * @protected
     * @param {?} expressionsTree
     * @param {?} fieldName
     * @return {?}
     */
    isFilteringExpressionsTreeForColumn(expressionsTree, fieldName) {
        if (expressionsTree.fieldName === fieldName) {
            return true;
        }
        /** @type {?} */
        let expr;
        for (let i = 0; i < expressionsTree.filteringOperands.length; i++) {
            expr = expressionsTree.filteringOperands[i];
            if ((expr instanceof FilteringExpressionsTree)) {
                return this.isFilteringExpressionsTreeForColumn(expr, fieldName);
            }
            else {
                return ((/** @type {?} */ (expr))).fieldName === fieldName;
            }
        }
        return false;
    }
}
if (false) {
    /**
     * Sets/gets the filtering operands.
     * ```typescript
     * const gridExpressionsTree = new FilteringExpressionsTree(FilteringLogic.And);
     * const expression = [
     * {
     *   condition: IgxStringFilteringOperand.instance().condition('contains'),
     *   fieldName: 'Column Field',
     *   searchVal: 'Value',
     *   ignoreCase: false
     * }];
     * gridExpressionsTree.filteringOperands.push(expression);
     * this.grid.filteringExpressionsTree = gridExpressionsTree;
     * ```
     * ```typescript
     * let filteringOperands = gridExpressionsTree.filteringOperands;
     * ```
     * \@memberof FilteringExpressionsTree
     * @type {?}
     */
    FilteringExpressionsTree.prototype.filteringOperands;
    /**
     * Sets/gets the operator.
     * ```typescript
     * gridExpressionsTree.operator = FilteringLogic.And;
     * ```
     * ```typescript
     * let operator = gridExpressionsTree.operator;
     * ```
     * \@memberof FilteringExpressionsTree
     * @type {?}
     */
    FilteringExpressionsTree.prototype.operator;
    /**
     * Sets/gets the field name of the column where the filtering expression is placed.
     * ```typescript
     *  gridExpressionTree.fieldName = 'Column Field';
     * ```
     * ```typescript
     * let columnField = expressionTree.fieldName;
     * ```
     * \@memberof FilteringExpressionsTree
     * @type {?}
     */
    FilteringExpressionsTree.prototype.fieldName;
    /**
     * Sets/gets the type of the filtering expressions tree.
     * ```typescript
     *  gridExpressionTree.type = FilteringExpressionsTree.Advanced;
     * ```
     * ```typescript
     * let type = expressionTree.type;
     * ```
     * \@memberof FilteringExpressionsTree
     * @type {?}
     */
    FilteringExpressionsTree.prototype.type;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsdGVyaW5nLWV4cHJlc3Npb25zLXRyZWUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9pZ25pdGV1aS1hbmd1bGFyLyIsInNvdXJjZXMiOlsibGliL2RhdGEtb3BlcmF0aW9ucy9maWx0ZXJpbmctZXhwcmVzc2lvbnMtdHJlZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7SUFJSSxVQUFPO0lBQ1AsV0FBUTs7Ozs7QUFhWixNQUFNLE9BQU8sd0JBQXdCOzs7OztJQTJEakMsWUFBWSxRQUF3QixFQUFFLFNBQWtCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztRQXRDeEQsc0JBQWlCLEdBQXlELEVBQUUsQ0FBQztRQXVDekUsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLENBQUM7UUFDekIsSUFBSSxDQUFDLFNBQVMsR0FBRyxTQUFTLENBQUM7SUFDL0IsQ0FBQzs7Ozs7O0lBT00sTUFBTSxDQUFDLEtBQUssQ0FBQyxjQUF5QztRQUN6RCxPQUFPLENBQUMsY0FBYyxJQUFJLENBQUMsY0FBYyxDQUFDLGlCQUFpQixJQUFJLENBQUMsY0FBYyxDQUFDLGlCQUFpQixDQUFDLE1BQU0sQ0FBQztJQUM1RyxDQUFDOzs7Ozs7Ozs7O0lBU00sSUFBSSxDQUFDLFNBQWlCOztjQUNuQixLQUFLLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxTQUFTLENBQUM7UUFFdkMsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDLEVBQUU7WUFDWixPQUFPLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUN4QztRQUVELE9BQU8sSUFBSSxDQUFDO0lBQ2hCLENBQUM7Ozs7Ozs7Ozs7SUFTTSxTQUFTLENBQUMsU0FBaUI7O1lBQzFCLElBQUk7UUFDUixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUNwRCxJQUFJLEdBQUcsSUFBSSxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ2pDLElBQUksSUFBSSxZQUFZLHdCQUF3QixFQUFFO2dCQUMxQyxJQUFJLElBQUksQ0FBQyxtQ0FBbUMsQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLEVBQUU7b0JBQzNELE9BQU8sQ0FBQyxDQUFDO2lCQUNaO2FBQ0o7aUJBQU07Z0JBQ0gsSUFBSSxDQUFDLG1CQUFBLElBQUksRUFBd0IsQ0FBQyxDQUFDLFNBQVMsS0FBSyxTQUFTLEVBQUU7b0JBQ3hELE9BQU8sQ0FBQyxDQUFDO2lCQUNaO2FBQ0o7U0FDSjtRQUVELE9BQU8sQ0FBQyxDQUFDLENBQUM7SUFDZCxDQUFDOzs7Ozs7O0lBRVMsbUNBQW1DLENBQUMsZUFBMEMsRUFBRSxTQUFpQjtRQUN2RyxJQUFJLGVBQWUsQ0FBQyxTQUFTLEtBQUssU0FBUyxFQUFFO1lBQ3pDLE9BQU8sSUFBSSxDQUFDO1NBQ2Y7O1lBRUcsSUFBSTtRQUNSLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxlQUFlLENBQUMsaUJBQWlCLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQy9ELElBQUksR0FBRyxlQUFlLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDNUMsSUFBSSxDQUFDLElBQUksWUFBWSx3QkFBd0IsQ0FBQyxFQUFFO2dCQUM1QyxPQUFPLElBQUksQ0FBQyxtQ0FBbUMsQ0FBQyxJQUFJLEVBQUUsU0FBUyxDQUFDLENBQUM7YUFDcEU7aUJBQU07Z0JBQ0gsT0FBTyxDQUFDLG1CQUFBLElBQUksRUFBd0IsQ0FBQyxDQUFDLFNBQVMsS0FBSyxTQUFTLENBQUM7YUFDakU7U0FDSjtRQUVELE9BQU8sS0FBSyxDQUFDO0lBQ2pCLENBQUM7Q0FDSjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQS9HRyxxREFBNkU7Ozs7Ozs7Ozs7OztJQVk3RSw0Q0FBeUI7Ozs7Ozs7Ozs7OztJQVl6Qiw2Q0FBbUI7Ozs7Ozs7Ozs7OztJQVluQix3Q0FBb0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJRmlsdGVyaW5nRXhwcmVzc2lvbiwgRmlsdGVyaW5nTG9naWMgfSBmcm9tICcuL2ZpbHRlcmluZy1leHByZXNzaW9uLmludGVyZmFjZSc7XG5pbXBvcnQgeyBJQmFzZUV2ZW50QXJncyB9IGZyb20gJy4uL2NvcmUvdXRpbHMnO1xuXG5leHBvcnQgZW51bSBGaWx0ZXJpbmdFeHByZXNzaW9uc1RyZWVUeXBlIHtcbiAgICBSZWd1bGFyLFxuICAgIEFkdmFuY2VkXG59XG5cbmV4cG9ydCBkZWNsYXJlIGludGVyZmFjZSBJRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlIGV4dGVuZHMgSUJhc2VFdmVudEFyZ3Mge1xuICAgIGZpbHRlcmluZ09wZXJhbmRzOiAoSUZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZSB8IElGaWx0ZXJpbmdFeHByZXNzaW9uKVtdO1xuICAgIG9wZXJhdG9yOiBGaWx0ZXJpbmdMb2dpYztcbiAgICBmaWVsZE5hbWU/OiBzdHJpbmc7XG4gICAgdHlwZT86IEZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZVR5cGU7XG5cbiAgICBmaW5kKGZpZWxkTmFtZTogc3RyaW5nKTogSUZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZSB8IElGaWx0ZXJpbmdFeHByZXNzaW9uO1xuICAgIGZpbmRJbmRleChmaWVsZE5hbWU6IHN0cmluZyk6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIEZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZSBpbXBsZW1lbnRzIElGaWx0ZXJpbmdFeHByZXNzaW9uc1RyZWUge1xuXG4gICAgLyoqXG4gICAgICogU2V0cy9nZXRzIHRoZSBmaWx0ZXJpbmcgb3BlcmFuZHMuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGNvbnN0IGdyaWRFeHByZXNzaW9uc1RyZWUgPSBuZXcgRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlKEZpbHRlcmluZ0xvZ2ljLkFuZCk7XG4gICAgICogY29uc3QgZXhwcmVzc2lvbiA9IFtcbiAgICAgKiB7XG4gICAgICogICBjb25kaXRpb246IElneFN0cmluZ0ZpbHRlcmluZ09wZXJhbmQuaW5zdGFuY2UoKS5jb25kaXRpb24oJ2NvbnRhaW5zJyksXG4gICAgICogICBmaWVsZE5hbWU6ICdDb2x1bW4gRmllbGQnLFxuICAgICAqICAgc2VhcmNoVmFsOiAnVmFsdWUnLFxuICAgICAqICAgaWdub3JlQ2FzZTogZmFsc2VcbiAgICAgKiB9XTtcbiAgICAgKiBncmlkRXhwcmVzc2lvbnNUcmVlLmZpbHRlcmluZ09wZXJhbmRzLnB1c2goZXhwcmVzc2lvbik7XG4gICAgICogdGhpcy5ncmlkLmZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZSA9IGdyaWRFeHByZXNzaW9uc1RyZWU7XG4gICAgICogYGBgXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIGxldCBmaWx0ZXJpbmdPcGVyYW5kcyA9IGdyaWRFeHByZXNzaW9uc1RyZWUuZmlsdGVyaW5nT3BlcmFuZHM7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIEZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZVxuICAgICAqL1xuICAgIGZpbHRlcmluZ09wZXJhbmRzOiAoSUZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZSB8IElGaWx0ZXJpbmdFeHByZXNzaW9uKVtdID0gW107XG5cbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgdGhlIG9wZXJhdG9yLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBncmlkRXhwcmVzc2lvbnNUcmVlLm9wZXJhdG9yID0gRmlsdGVyaW5nTG9naWMuQW5kO1xuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgb3BlcmF0b3IgPSBncmlkRXhwcmVzc2lvbnNUcmVlLm9wZXJhdG9yO1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBGaWx0ZXJpbmdFeHByZXNzaW9uc1RyZWVcbiAgICAgKi9cbiAgICBvcGVyYXRvcjogRmlsdGVyaW5nTG9naWM7XG5cbiAgICAvKipcbiAgICAgKiBTZXRzL2dldHMgdGhlIGZpZWxkIG5hbWUgb2YgdGhlIGNvbHVtbiB3aGVyZSB0aGUgZmlsdGVyaW5nIGV4cHJlc3Npb24gaXMgcGxhY2VkLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiAgZ3JpZEV4cHJlc3Npb25UcmVlLmZpZWxkTmFtZSA9ICdDb2x1bW4gRmllbGQnO1xuICAgICAqIGBgYFxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgY29sdW1uRmllbGQgPSBleHByZXNzaW9uVHJlZS5maWVsZE5hbWU7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIEZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZVxuICAgICAqL1xuICAgIGZpZWxkTmFtZT86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFNldHMvZ2V0cyB0aGUgdHlwZSBvZiB0aGUgZmlsdGVyaW5nIGV4cHJlc3Npb25zIHRyZWUuXG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqICBncmlkRXhwcmVzc2lvblRyZWUudHlwZSA9IEZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZS5BZHZhbmNlZDtcbiAgICAgKiBgYGBcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogbGV0IHR5cGUgPSBleHByZXNzaW9uVHJlZS50eXBlO1xuICAgICAqIGBgYFxuICAgICAqIEBtZW1iZXJvZiBGaWx0ZXJpbmdFeHByZXNzaW9uc1RyZWVcbiAgICAgKi9cbiAgICB0eXBlPzogRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlVHlwZTtcblxuICAgIGNvbnN0cnVjdG9yKG9wZXJhdG9yOiBGaWx0ZXJpbmdMb2dpYywgZmllbGROYW1lPzogc3RyaW5nKSB7XG4gICAgICAgIHRoaXMub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgICAgICAgdGhpcy5maWVsZE5hbWUgPSBmaWVsZE5hbWU7XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgZmlsdGVyaW5nIGV4cHJlc3Npb25zIHRyZWUgaXMgZW1wdHkuXG4gICAgICogQHBhcmFtIGV4cHJlc3Npb25UcmVlIGZpbHRlcmluZyBleHByZXNzaW9ucyB0cmVlLlxuICAgICAqL1xuICAgIHB1YmxpYyBzdGF0aWMgZW1wdHkoZXhwcmVzc2lvblRyZWU6IElGaWx0ZXJpbmdFeHByZXNzaW9uc1RyZWUpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuICFleHByZXNzaW9uVHJlZSB8fCAhZXhwcmVzc2lvblRyZWUuZmlsdGVyaW5nT3BlcmFuZHMgfHwgIWV4cHJlc3Npb25UcmVlLmZpbHRlcmluZ09wZXJhbmRzLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaWx0ZXJpbmcgZXhwcmVzc2lvbiBmb3IgYSBjb2x1bW4gd2l0aCB0aGUgcHJvdmlkZWQgZmllbGROYW1lLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgZmlsdGVyaW5nRXhwcmVzc2lvbiA9IGdyaWRFeHByZXNzaW9uVHJlZS5maW5kKCdDb2x1bW4gRmllbGQnKTtcbiAgICAgKiBgYGBcbiAgICAgKiBAbWVtYmVyb2YgRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlXG4gICAgICovXG4gICAgcHVibGljIGZpbmQoZmllbGROYW1lOiBzdHJpbmcpOiBJRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlIHwgSUZpbHRlcmluZ0V4cHJlc3Npb24ge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZmluZEluZGV4KGZpZWxkTmFtZSk7XG5cbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlcmluZ09wZXJhbmRzW2luZGV4XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaWx0ZXJpbmcgZXhwcmVzc2lvbiBmb3IgYSBjb2x1bW4gd2l0aCB0aGUgcHJvdmlkZWQgZmllbGROYW1lLlxuICAgICAqIGBgYHR5cGVzY3JpcHRcbiAgICAgKiBsZXQgZmlsdGVyaW5nRXhwcmVzc2lvbkluZGV4ID0gZ3JpZEV4cHJlc3Npb25UcmVlLmZpbmRJbmRleCgnQ29sdW1uIEZpZWxkJyk7XG4gICAgICogYGBgXG4gICAgICogQG1lbWJlcm9mIEZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZVxuICAgICAqL1xuICAgIHB1YmxpYyBmaW5kSW5kZXgoZmllbGROYW1lOiBzdHJpbmcpOiBudW1iZXIge1xuICAgICAgICBsZXQgZXhwcjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmZpbHRlcmluZ09wZXJhbmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBleHByID0gdGhpcy5maWx0ZXJpbmdPcGVyYW5kc1tpXTtcbiAgICAgICAgICAgIGlmIChleHByIGluc3RhbmNlb2YgRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNGaWx0ZXJpbmdFeHByZXNzaW9uc1RyZWVGb3JDb2x1bW4oZXhwciwgZmllbGROYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICgoZXhwciBhcyBJRmlsdGVyaW5nRXhwcmVzc2lvbikuZmllbGROYW1lID09PSBmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBpc0ZpbHRlcmluZ0V4cHJlc3Npb25zVHJlZUZvckNvbHVtbihleHByZXNzaW9uc1RyZWU6IElGaWx0ZXJpbmdFeHByZXNzaW9uc1RyZWUsIGZpZWxkTmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIGlmIChleHByZXNzaW9uc1RyZWUuZmllbGROYW1lID09PSBmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGV4cHI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhwcmVzc2lvbnNUcmVlLmZpbHRlcmluZ09wZXJhbmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBleHByID0gZXhwcmVzc2lvbnNUcmVlLmZpbHRlcmluZ09wZXJhbmRzW2ldO1xuICAgICAgICAgICAgaWYgKChleHByIGluc3RhbmNlb2YgRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzRmlsdGVyaW5nRXhwcmVzc2lvbnNUcmVlRm9yQ29sdW1uKGV4cHIsIGZpZWxkTmFtZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAoZXhwciBhcyBJRmlsdGVyaW5nRXhwcmVzc2lvbikuZmllbGROYW1lID09PSBmaWVsZE5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuIl19